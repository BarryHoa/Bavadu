/**
 * Generate Model Registry
 * Scans all *Model.ts files and generates a registry file with static imports
 */

import fs from "fs";
import path from "path";

const modulesDir = path.join(process.cwd(), "modules");
const outputFile = path.join(
  process.cwd(),
  "module-base/server/models/ModelRegistry.ts"
);

/**
 * Recursively find all files matching pattern *Model.ts
 */
function findModelFiles(dir: string, fileList: string[] = []): string[] {
  if (!fs.existsSync(dir)) {
    return fileList;
  }

  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findModelFiles(filePath, fileList);
    } else if (stat.isFile() && file.endsWith("Model.ts")) {
      fileList.push(filePath);
    }
  }

  return fileList;
}

function generateRegistry() {
  console.log("ðŸ” Scanning for model files...");

  if (!fs.existsSync(modulesDir)) {
    console.log("âš ï¸  Modules directory not found");
    return;
  }

  const moduleNames = fs
    .readdirSync(modulesDir, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  const imports: string[] = [];
  const registrations: string[] = [];

  for (const moduleName of moduleNames) {
    const modelsDir = path.join(modulesDir, moduleName, "server", "models");

    if (!fs.existsSync(modelsDir)) {
      continue;
    }

    const modelFiles = findModelFiles(modelsDir);

    for (const modelFilePath of modelFiles) {
      const fileName = path.basename(modelFilePath, ".ts");

      // Build alias path
      const relativeFromCwd = path.relative(process.cwd(), modelFilePath);
      const aliasPath = relativeFromCwd
        .replace(/^modules\//, "@mdl/")
        .replace(/\.ts$/, "")
        .replace(/\\/g, "/");

      // Generate import statement
      const importVar = `${moduleName}_${fileName}`.replace(
        /[^a-zA-Z0-9]/g,
        "_"
      );
      imports.push(`import ${importVar} from "${aliasPath}";`);

      // Generate registration
      registrations.push(`
  // Register ${moduleName}.${fileName}
  if (${importVar} && typeof ${importVar}.getModelId === 'function') {
    const modelId = ${importVar}.getModelId();
    if (modelId && typeof modelId === 'string') {
      modelSystemStore.set(modelId, ${importVar});
      console.log(\`  âœ“ Loaded \${modelId}\`);
      loadedCount++;
    } else {
      console.warn(\`  âš ï¸  Model ${moduleName}.${fileName}: getModelId() returned invalid value\`);
      errorCount++;
    }
  } else {
    console.warn(\`  âš ï¸  Model ${moduleName}.${fileName}: No default export or missing getModelId()\`);
    errorCount++;
  }`);
    }
  }

  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * This file is generated by scripts/generate-model-registry.ts
 * Run: npm run models:generate
 */

import modelSystemStore from "./ModelSystemStore";
${imports.join("\n")}

let loadedCount = 0;
let errorCount = 0;

export function registerAllModels() {
  console.group("ðŸš€ Registering models from registry...");
${registrations.join("")}
  
  console.log(
    \`âœ… Registered \${loadedCount} models\${errorCount > 0 ? \` (\${errorCount} errors)\` : ""}\`
  );
  console.log(
    \`ðŸ“¦ Model store: \${modelSystemStore.size()} model(s)\`,
    modelSystemStore.getAllKeys()
  );
  console.groupEnd();
  
  return { loadedCount, errorCount };
}
`;

  // Ensure directory exists
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputFile, content, "utf-8");
  console.log(`âœ… Generated registry: ${outputFile}`);
  console.log(`   Found ${imports.length} model(s)`);
}

generateRegistry();
