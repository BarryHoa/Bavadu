[{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/admin/model/get-model-list/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/admin/model/reload-model/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/auth/login/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/auth/logout/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/auth/me/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/health/ping/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/health/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/internal/json-rpc/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/media/[type]/[filename]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/media/upload/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/permissions/list/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/roles/create/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/roles/delete/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/roles/get/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/roles/list/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/settings/roles/update/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/utils/get-csrf-token/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/base/workspace/menu/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/cron/cleanup-expired-sessions/route.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":74,"fix":{"range":[143,143],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/models/Sessions/SessionModel`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":57,"fix":{"range":[0,201],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport SessionModel from \"@base/server/models/Sessions/SessionModel\";\nimport { initializeRuntime } from \"@base/server/utils/initializeRuntime\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":24,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":24,"endColumn":16,"suggestions":[{"fix":{"range":[794,853],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":16,"suggestions":[{"fix":{"range":[974,1042],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":18,"suggestions":[{"fix":{"range":[1212,1279],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import SessionModel from \"@base/server/models/Sessions/SessionModel\";\nimport { initializeRuntime } from \"@base/server/utils/initializeRuntime\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport const dynamic = \"force-dynamic\";\nexport const runtime = \"nodejs\";\n\nexport async function GET(request: NextRequest) {\n  try {\n    const cronSecret = process.env.CRON_SECRET;\n\n    // If CRON_SECRET is set, require it in Authorization header\n    if (cronSecret) {\n      const authHeader = request.headers.get(\"authorization\");\n\n      if (authHeader !== `Bearer ${cronSecret}`) {\n        return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n      }\n    }\n\n    // Initialize runtime (database and environment) if not already initialized\n    await initializeRuntime();\n\n    console.log(\"[Cron] Starting cleanup expired sessions...\");\n    const sessionModel = new SessionModel();\n    const deletedCount = await sessionModel.cleanupExpiredSessions();\n\n    console.log(`[Cron] Cleaned up ${deletedCount} expired session(s)`);\n\n    return NextResponse.json({\n      success: true,\n      message: `Cleaned up ${deletedCount} expired session(s)`,\n      deletedCount,\n    });\n  } catch (error) {\n    console.error(\"[Cron] Error cleaning up expired sessions:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/api/cron/compress-logs/route.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":74,"fix":{"range":[160,160],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/models/Logs/LogCompressionModel`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":57,"fix":{"range":[0,218],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport { getLogCompressionModel } from \"@base/server/models/Logs/LogCompressionModel\";\nimport { initializeRuntime } from \"@base/server/utils/initializeRuntime\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":24,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":24,"endColumn":16,"suggestions":[{"fix":{"range":[811,861],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":16,"suggestions":[{"fix":{"range":[975,1140],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":48,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":48,"endColumn":18,"suggestions":[{"fix":{"range":[1656,1691],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":18,"suggestions":[{"fix":{"range":[1755,1788],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":55,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":55,"endColumn":19,"suggestions":[{"fix":{"range":[1838,1909],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":40,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":52},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":18,"suggestions":[{"fix":{"range":[2232,2287],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { getLogCompressionModel } from \"@base/server/models/Logs/LogCompressionModel\";\nimport { initializeRuntime } from \"@base/server/utils/initializeRuntime\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport const dynamic = \"force-dynamic\";\nexport const runtime = \"nodejs\";\n\nexport async function GET(request: NextRequest) {\n  try {\n    const cronSecret = process.env.CRON_SECRET;\n\n    // If CRON_SECRET is set, require it in Authorization header\n    if (cronSecret) {\n      const authHeader = request.headers.get(\"authorization\");\n\n      if (authHeader !== `Bearer ${cronSecret}`) {\n        return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n      }\n    }\n\n    // Initialize runtime (database and environment) if not already initialized\n    await initializeRuntime();\n\n    console.log(\"[Cron] Starting log compression...\");\n    const compressionModel = getLogCompressionModel();\n    const statsBefore = compressionModel.getStats();\n\n    console.log(\n      `[Cron] Files to compress: ${statsBefore.filesToCompress}, ` +\n        `Size: ${(statsBefore.sizeToCompress / 1024 / 1024).toFixed(2)} MB`,\n    );\n\n    const result = await compressionModel.compressLogs();\n\n    let message = \"\";\n\n    if (result.compressed > 0) {\n      const compressionRatio = (\n        (1 - result.compressedSize / result.totalSize) *\n        100\n      ).toFixed(1);\n\n      message =\n        `Compressed ${result.compressed} log files. ` +\n        `Original: ${(result.totalSize / 1024 / 1024).toFixed(2)} MB, ` +\n        `Compressed: ${(result.compressedSize / 1024 / 1024).toFixed(2)} MB ` +\n        `(${compressionRatio}% reduction)`;\n      console.log(`[Cron] ✅ ${message}`);\n    } else {\n      message = \"No log files to compress\";\n      console.log(`[Cron] ${message}`);\n    }\n\n    if (result.errors.length > 0) {\n      console.warn(`[Cron] ⚠️  ${result.errors.length} compression errors:`);\n      result.errors.forEach((error) => console.warn(`  - ${error}`));\n    }\n\n    return NextResponse.json({\n      success: true,\n      message,\n      compressed: result.compressed,\n      totalSize: result.totalSize,\n      compressedSize: result.compressedSize,\n      errors: result.errors,\n    });\n  } catch (error) {\n    console.error(\"[Cron] Error compressing logs:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/error.tsx","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":18,"suggestions":[{"fix":{"range":[259,280],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/global-error.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/layout.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@/config/site` import should occur before import of `./providers`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":44,"fix":{"range":[126,212],"text":"import { siteConfig } from \"@/config/site\";\nimport { Providers } from \"./providers\";\n\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import \"@base/client/styles/fonts.css\";\nimport \"@base/client/styles/globals.css\";\nimport { Metadata, Viewport } from \"next\";\n\nimport { Providers } from \"./providers\";\n\nimport { siteConfig } from \"@/config/site\";\n\nexport const metadata: Metadata = {\n  title: {\n    default: siteConfig.name,\n    template: `%s - ${siteConfig.name}`,\n  },\n  description: siteConfig.description,\n  icons: {\n    icon: [\n      { url: \"/favicon/favicon.ico\" },\n      { url: \"/favicon/favicon-32x32.png\", sizes: \"32x32\", type: \"image/png\" },\n      { url: \"/favicon/favicon-16x16.png\", sizes: \"16x16\", type: \"image/png\" },\n    ],\n    apple: [\n      {\n        url: \"/favicon/apple-touch-icon.png\",\n        sizes: \"180x180\",\n        type: \"image/png\",\n      },\n    ],\n  },\n};\n\nexport const viewport: Viewport = {\n  themeColor: [\n    { media: \"(prefers-color-scheme: light)\", color: \"white\" },\n    { media: \"(prefers-color-scheme: dark)\", color: \"black\" },\n  ],\n};\n\nexport default async function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  // Load messages for the default locale\n  const locale = \"en\";\n\n  return (\n    <html suppressHydrationWarning className=\"light\" lang={locale}>\n      <head />\n      <body>\n        <Providers>\n          <div className=\"relative flex flex-col h-screen\">\n            {/* <Navbar /> */}\n            <main\n              className=\"container mx-auto p-0 flex-1\"\n              style={{ maxWidth: \"1920px\" }}\n            >\n              {children}\n            </main>\n          </div>\n          {/* <ScrollbarReveal /> */}\n        </Providers>\n      </body>\n    </html>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/login/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/not-found.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/providers.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":51,"fix":{"range":[280,280],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { HeroUIProvider } from \"@heroui/system\";\nimport { ToastProvider } from \"@heroui/toast\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useLayoutEffect, useState } from \"react\";\nimport { NavigationLoader } from \"@base/client/components/NavigationLoader\";\nimport { GlobalSettingsProvider } from \"@base/client/contexts/global-settings\";\nimport { usePreventBackspaceNavigation } from \"@base/client/hooks/usePreventBackspaceNavigation\";\n// Import root-store để khởi tạo và test DevTools\nimport { setRootStoreValue } from \"@base/client/stores/root-store\";\n\nexport interface ProvidersProps {\n  children: React.ReactNode;\n}\n\ndeclare module \"@react-types/shared\" {\n  interface RouterConfig {\n    routerOptions: NonNullable<\n      Parameters<ReturnType<typeof useRouter>[\"push\"]>[1]\n    >;\n  }\n}\n\nexport function Providers({ children }: ProvidersProps) {\n  const router = useRouter();\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: 60 * 1000,\n            gcTime: 5 * 60 * 1000,\n            refetchOnWindowFocus: false,\n            refetchOnReconnect: false,\n            retry: 1,\n          },\n        },\n      }),\n  );\n\n  // Initialize root-store và test DevTools\n  useLayoutEffect(() => {\n    setRootStoreValue(\"__init__\", { timestamp: Date.now() });\n  }, []);\n\n  // Prevent Backspace from navigating back in browser\n  usePreventBackspaceNavigation();\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <HeroUIProvider navigate={router.push}>\n        <ToastProvider\n          placement=\"top-right\"\n          toastProps={{ variant: \"solid\" }}\n        />\n        <GlobalSettingsProvider>\n          <NavigationLoader minLoadingTime={300} />\n          {children}\n        </GlobalSettingsProvider>\n      </HeroUIProvider>\n    </QueryClientProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/reset-password/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/admin/models/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/customers/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/customers/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/customers/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/customers/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/deliveries/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/deliveries/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2b-sales/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/customers/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/customers/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/customers/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/customers/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/deliveries/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/deliveries/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/price-lists/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/price-lists/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/price-lists/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/price-lists/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/b2c-sales/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/candidates/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/candidates/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/candidates/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/candidates/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/certificates/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/certificates/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/certificates/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/certificates/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/courses/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/courses/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/courses/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/courses/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/departments/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/departments/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/departments/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/departments/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/employees/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/employees/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/employees/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/employees/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/job-requisitions/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/job-requisitions/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/job-requisitions/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/job-requisitions/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-requests/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-requests/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-requests/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-requests/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-types/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-types/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-types/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/leave-types/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/payroll/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/payroll/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/payroll/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/payroll/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/performance-reviews/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/performance-reviews/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/performance-reviews/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/performance-reviews/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/positions/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/positions/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/positions/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/positions/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/timesheets/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/timesheets/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/timesheets/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/hrm/timesheets/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/categories/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/categories/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/categories/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/categories/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/uom/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/product/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/purchase/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/purchase/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/purchase/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/report/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/stock/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/stock/warehouses/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/stock/warehouses/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/modules/stock/warehouses/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/news/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/settings/roles/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/settings/roles/edit/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/settings/roles/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/app/workspace/settings/roles/view/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/config/fonts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/config/site.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/cron/Kernel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":53,"fix":{"range":[147,147],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`node-cron` import should occur before import of `@base/server/config`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":79,"fix":{"range":[95,227],"text":"import { getTasks, ScheduledTask as NodeCronTask, schedule } from \"node-cron\";\nimport { SYSTEM_CONFIG } from \"@base/server/config\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":24,"suggestions":[{"fix":{"range":[6304,6352],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":233,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":233,"endColumn":26,"suggestions":[{"fix":{"range":[6484,6585],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":237,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":237,"endColumn":28,"suggestions":[{"fix":{"range":[6630,6688],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":246,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":246,"endColumn":20,"suggestions":[{"fix":{"range":[6831,6930],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":252,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":252,"endColumn":16,"suggestions":[{"fix":{"range":[6952,7024],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":264,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":264,"endColumn":16,"suggestions":[{"fix":{"range":[7196,7236],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":16,"suggestions":[{"fix":{"range":[7355,7401],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":276,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":276,"endColumn":16,"suggestions":[{"fix":{"range":[7517,7559],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":2,"source":"/**\n * Cron Scheduler Kernel\n * Similar to Laravel's Kernel.php - defines scheduled tasks\n */\n\nimport { SYSTEM_CONFIG } from \"@base/server/config\";\nimport { getTasks, ScheduledTask as NodeCronTask, schedule } from \"node-cron\";\n\nexport interface ScheduledTask {\n  schedule: string;\n  task: () => Promise<void> | void;\n  name: string;\n  enabled?: boolean;\n}\n\nexport class Kernel {\n  private tasks: Map<string, ScheduledTask> = new Map();\n\n  /**\n   * Schedule a task using custom cron expression\n   * @param expression - Cron expression\n   * @param name - Task name for logging (must be unique)\n   * @param task - Task function to execute\n   * @throws Error if task name already exists\n   */\n  protected makeACronTask(\n    expression: string,\n    name: string,\n    task: () => Promise<void> | void,\n  ): void {\n    // Check if task name already exists\n    if (this.tasks.has(name)) {\n      throw new Error(\n        `Task with name \"${name}\" already exists. Each task must have a unique name.`,\n      );\n    }\n\n    this.tasks.set(name, {\n      schedule: expression,\n      task,\n      name,\n      enabled: true,\n    });\n  }\n\n  /**\n   * Schedule a task to run every N seconds\n   * Note: node-cron uses 5-field format, so this uses every minute with custom logic\n   * For true second-level scheduling, consider using setInterval instead\n   * @param seconds - Number of seconds (1-59)\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   */\n  protected everySeconds(\n    seconds: number,\n    name: string,\n    task: () => Promise<void> | void,\n  ): void {\n    if (seconds < 1 || seconds > 59) {\n      throw new Error(\"Seconds must be between 1 and 59\");\n    }\n    // Use every minute and let the task handle second-level logic\n    // Or use a workaround with multiple tasks\n    this.makeACronTask(\n      `* * * * *`, // Every minute\n      name,\n      async () => {\n        // Run task every N seconds within the minute\n        const interval = setInterval(async () => {\n          await task();\n        }, seconds * 1000);\n\n        // Clear after 60 seconds\n        setTimeout(() => clearInterval(interval), 60000);\n      },\n    );\n  }\n\n  /**\n   * Schedule a task to run every N minutes\n   * @param minutes - Number of minutes\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   */\n  protected everyMinutes(\n    minutes: number,\n    name: string,\n    task: () => Promise<void> | void,\n  ): void {\n    this.makeACronTask(`*/${minutes} * * * *`, name, task);\n  }\n\n  /**\n   * Schedule a task to run hourly\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   * @param minute - Optional minute of the hour (0-59, default: 0)\n   */\n  protected hourly(\n    name: string,\n    task: () => Promise<void> | void,\n    minute: number = 0,\n  ): void {\n    this.makeACronTask(`${minute} * * * *`, name, task);\n  }\n\n  /**\n   * Schedule a task to run every N hours\n   * @param hours - Number of hours\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   * @param minute - Optional minute of the hour (0-59, default: 0)\n   */\n  protected everyHours(\n    hours: number,\n    name: string,\n    task: () => Promise<void> | void,\n    minute: number = 0,\n  ): void {\n    this.makeACronTask(`${minute} */${hours} * * *`, name, task);\n  }\n\n  /**\n   * Schedule a task to run at a specific time daily\n   * @param name - Task name for logging\n   * @param time - Time in HH:mm format (e.g., \"03:00\", \"14:30\")\n   * @param task - Task function to execute\n   */\n  protected dailyAt(\n    name: string,\n    time: string,\n    task: () => Promise<void> | void,\n  ): void {\n    const [hours, minutes] = time.split(\":\").map(Number);\n    const cronExpression = `${minutes} ${hours} * * *`;\n\n    this.makeACronTask(cronExpression, name, task);\n  }\n\n  /**\n   * Schedule a task to run daily\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   * @param time - Optional time in HH:mm format (default: \"00:00\")\n   */\n  protected daily(\n    name: string,\n    task: () => Promise<void> | void,\n    time: string = \"00:00\",\n  ): void {\n    this.dailyAt(name, time, task);\n  }\n\n  /**\n   * Schedule a task to run monthly\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   * @param day - Optional day of the month (1-31, default: 1)\n   * @param time - Optional time in HH:mm format (default: \"00:00\")\n   */\n  protected monthly(\n    name: string,\n    task: () => Promise<void> | void,\n    day: number = 1,\n    time: string = \"00:00\",\n  ): void {\n    const [hours, minutes] = time.split(\":\").map(Number);\n    const cronExpression = `${minutes} ${hours} ${day} * *`;\n\n    this.makeACronTask(cronExpression, name, task);\n  }\n\n  /**\n   * Schedule a task to run yearly\n   * @param name - Task name for logging\n   * @param task - Task function to execute\n   * @param month - Optional month (1-12, default: 1)\n   * @param day - Optional day of the month (1-31, default: 1)\n   * @param time - Optional time in HH:mm format (default: \"00:00\")\n   */\n  protected yearly(\n    name: string,\n    task: () => Promise<void> | void,\n    month: number = 1,\n    day: number = 1,\n    time: string = \"00:00\",\n  ): void {\n    const [hours, minutes] = time.split(\":\").map(Number);\n    const cronExpression = `${minutes} ${hours} ${day} ${month} *`;\n\n    this.makeACronTask(cronExpression, name, task);\n  }\n\n  /**\n   * Get timezone for scheduled tasks\n   * @returns Timezone string (e.g., \"Asia/Ho_Chi_Minh\")\n   */\n  protected getTimezone(): string {\n    return SYSTEM_CONFIG.timezone;\n  }\n\n  /**\n   * Define the application's task schedule\n   * Similar to Laravel's schedule() method\n   * Override this method in child class to define tasks\n   */\n  protected schedule(): void {\n    // Override this method in child class (e.g., ScheduledTask)\n  }\n\n  /**\n   * Start the scheduler\n   * Call this after defining all tasks in schedule()\n   */\n  public start(): void {\n    // Define schedule\n    this.schedule();\n\n    // Register and start all tasks\n    this.tasks.forEach((scheduledTask, taskName) => {\n      if (scheduledTask.enabled !== false) {\n        schedule(\n          scheduledTask.schedule,\n          async () => {\n            const startTime = Date.now();\n\n            console.log(`[Cron] Running task: ${taskName}`);\n\n            try {\n              await scheduledTask.task();\n              const duration = Date.now() - startTime;\n\n              console.log(\n                `[Cron] Task \"${taskName}\" completed in ${duration}ms`,\n              );\n            } catch (error) {\n              console.error(`[Cron] Task \"${taskName}\" failed:`, error);\n            }\n          },\n          {\n            timezone: this.getTimezone(),\n            name: taskName,\n          },\n        );\n\n        console.log(\n          `[Cron] Scheduled task: ${taskName} - ${scheduledTask.schedule}`,\n        );\n      }\n    });\n\n    console.log(`[Cron] Scheduler started with ${this.tasks.size} task(s)`);\n  }\n\n  /**\n   * Stop the scheduler\n   */\n  public stop(): void {\n    const tasks = getTasks();\n\n    tasks.forEach((task: NodeCronTask) => {\n      task.stop();\n    });\n    console.log(\"[Cron] Scheduler stopped\");\n  }\n\n  /**\n   * Restart the scheduler\n   * Stops all tasks and starts them again\n   */\n  public restart(): void {\n    console.log(\"[Cron] Restarting scheduler...\");\n    this.stop();\n    this.tasks.clear(); // Clear tasks to allow schedule() to redefine them\n    this.start();\n    console.log(\"[Cron] Scheduler restarted\");\n  }\n\n  /**\n   * Get list of scheduled tasks\n   */\n  public getTasks(): ScheduledTask[] {\n    return Array.from(this.tasks.values());\n  }\n\n  /**\n   * Get task by name\n   * @param name - Task name\n   * @returns Task if found, undefined otherwise\n   */\n  public getTask(name: string): ScheduledTask | undefined {\n    return this.tasks.get(name);\n  }\n\n  /**\n   * Check if task exists by name\n   * @param name - Task name\n   * @returns true if task exists, false otherwise\n   */\n  public hasTask(name: string): boolean {\n    return this.tasks.has(name);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/cron/ScheduledTask.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":18,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":18,"endColumn":18,"suggestions":[{"fix":{"range":[556,615],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":23,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":23,"endColumn":20,"suggestions":[{"fix":{"range":[760,828],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":22,"suggestions":[{"fix":{"range":[861,928],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":18,"suggestions":[{"fix":{"range":[1116,1166],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":20,"suggestions":[{"fix":{"range":[1304,1481],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":22,"suggestions":[{"fix":{"range":[1732,2042],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":57,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":57,"endColumn":22,"suggestions":[{"fix":{"range":[2070,2117],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":23,"suggestions":[{"fix":{"range":[2179,2275],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":44,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":56},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":67,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":67,"endColumn":22,"suggestions":[{"fix":{"range":[2392,2447],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ScheduledTask\n * Extends Kernel and defines the application's scheduled tasks\n */\n\nimport SessionModel from \"../module-base/server/models/Sessions/SessionModel\";\nimport { getLogCompressionModel } from \"../module-base/server/models/Logs/LogCompressionModel\";\n\nimport { Kernel } from \"./Kernel\";\n\nexport class ScheduledTask extends Kernel {\n  /**\n   * Define the application's task schedule\n   */\n  protected schedule(): void {\n    // Cleanup expired sessions daily at 3:00 AM\n    this.dailyAt(\"cleanup-expired-sessions\", \"03:00\", async () => {\n      console.log(\"[Cron] Starting cleanup expired sessions...\");\n      try {\n        const sessionModel = new SessionModel();\n        const deletedCount = await sessionModel.cleanupExpiredSessions();\n\n        console.log(`[Cron] Cleaned up ${deletedCount} expired session(s)`);\n      } catch (error) {\n        console.error(\"[Cron] Error cleaning up expired sessions:\", error);\n      }\n    });\n\n    // Compress log files daily at 2:00 AM\n    // Compresses logs older than 30 days into monthly archives\n    this.dailyAt(\"compress-logs\", \"02:00\", async () => {\n      console.log(\"[Cron] Starting log compression...\");\n      try {\n        const compressionModel = getLogCompressionModel();\n        const statsBefore = compressionModel.getStats();\n\n        console.log(\n          `[Cron] Files to compress: ${statsBefore.filesToCompress}, ` +\n            `Size: ${(statsBefore.sizeToCompress / 1024 / 1024).toFixed(2)} MB`,\n        );\n\n        const result = await compressionModel.compressLogs();\n\n        if (result.compressed > 0) {\n          const compressionRatio = (\n            (1 - result.compressedSize / result.totalSize) *\n            100\n          ).toFixed(1);\n\n          console.log(\n            `[Cron] ✅ Compressed ${result.compressed} log files. ` +\n              `Original: ${(result.totalSize / 1024 / 1024).toFixed(2)} MB, ` +\n              `Compressed: ${(result.compressedSize / 1024 / 1024).toFixed(2)} MB ` +\n              `(${compressionRatio}% reduction)`,\n          );\n        } else {\n          console.log(\"[Cron] No log files to compress\");\n        }\n\n        if (result.errors.length > 0) {\n          console.warn(\n            `[Cron] ⚠️  ${result.errors.length} compression errors:`,\n          );\n          result.errors.forEach((error) => console.warn(`  - ${error}`));\n        }\n      } catch (error) {\n        console.error(\"[Cron] Error compressing logs:\", error);\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/cron/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/i18n/request.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":58,"fix":{"range":[147,147],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `next/navigation`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":58,"fix":{"range":[90,269],"text":"import { getRequestConfig, GetRequestConfigParams } from \"next-intl/server\";\nimport { notFound } from \"next/navigation\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":86,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":86,"endColumn":20,"suggestions":[{"fix":{"range":[2159,2300],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { existsSync, readdirSync, readFileSync } from \"fs\";\nimport { join } from \"path\";\n\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { getRequestConfig, GetRequestConfigParams } from \"next-intl/server\";\nimport { notFound } from \"next/navigation\";\n\n// Can be imported from a shared config\nconst locales = [\"en\", \"vi\"] as const;\n\nconst FALLBACK_LOCALE = \"en\" satisfies (typeof locales)[number];\n\ntype SupportedLocale = (typeof locales)[number];\n\ntype Loader = () => Promise<Record<string, unknown>>;\n\nconst moduleBaseMessageLoaders: Record<SupportedLocale, Loader> = {\n  en: async () => {\n    try {\n      return (await import(\"@base/client/messages/en.json\")).default ?? {};\n    } catch {\n      return {};\n    }\n  },\n  vi: async () => {\n    try {\n      return (await import(\"@base/client/messages/vi.json\")).default ?? {};\n    } catch {\n      return {};\n    }\n  },\n};\n\n/**\n * Dynamically load messages from all modules\n */\nconst loadModuleMessages = async (\n  locale: SupportedLocale,\n): Promise<Record<string, unknown>> => {\n  const modulesDir = join(process.cwd(), \"modules\");\n\n  if (!existsSync(modulesDir)) {\n    return {};\n  }\n\n  const moduleDirs = readdirSync(modulesDir, { withFileTypes: true })\n    .filter((dirent) => dirent.isDirectory())\n    .map((dirent) => dirent.name);\n\n  const moduleMessages: Record<string, unknown> = {};\n\n  for (const moduleDir of moduleDirs) {\n    const messageFile = join(\n      modulesDir,\n      moduleDir,\n      \"client\",\n      \"messages\",\n      `${locale}.json`,\n    );\n\n    let fileToRead = messageFile;\n\n    // Try fallback locale if current locale doesn't exist\n    if (!existsSync(messageFile)) {\n      const fallbackFile = join(\n        modulesDir,\n        moduleDir,\n        \"client\",\n        \"messages\",\n        `${FALLBACK_LOCALE}.json`,\n      );\n\n      if (existsSync(fallbackFile)) {\n        fileToRead = fallbackFile;\n      } else {\n        continue;\n      }\n    }\n\n    try {\n      const fileContent = readFileSync(fileToRead, \"utf-8\");\n      const messages = JSON.parse(fileContent) as Record<string, unknown>;\n\n      Object.assign(moduleMessages, messages);\n    } catch (error) {\n      console.error(\n        `Error loading messages from ${fileToRead}:`,\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  return moduleMessages;\n};\n\nconst loadMessages = async (locale: SupportedLocale) => {\n  // Load base module messages\n  const fallbackModuleMessages =\n    await moduleBaseMessageLoaders[FALLBACK_LOCALE]();\n  const localeModuleMessages = await moduleBaseMessageLoaders[locale]();\n\n  // Load all module messages\n  const moduleMessages = await loadModuleMessages(locale);\n\n  return {\n    ...fallbackModuleMessages,\n    ...localeModuleMessages,\n    ...moduleMessages,\n  };\n};\n\nexport default getRequestConfig(async ({ locale }: GetRequestConfigParams) => {\n  if (!locale || !locales.includes(locale as SupportedLocale)) notFound();\n\n  const resolvedLocale = locale as SupportedLocale;\n  const messages = await loadMessages(resolvedLocale);\n\n  return {\n    locale: resolvedLocale,\n    messages,\n    timeZone: SYSTEM_TIMEZONE,\n  };\n});\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/lib/module-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/lib/module-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ActionMenu/ActionMenu.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[153,153],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `lucide-react`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[0,231],"text":"import { cn } from \"@heroui/theme\";\nimport { Ellipsis } from \"lucide-react\";\nimport {\n  IBaseButton,\n  IBaseDropdown,\n  IBaseDropdownItem,\n  IBaseDropdownMenu,\n  IBaseDropdownTrigger,\n  IBaseLink,\n} from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import {\n  IBaseButton,\n  IBaseDropdown,\n  IBaseDropdownItem,\n  IBaseDropdownMenu,\n  IBaseDropdownTrigger,\n  IBaseLink,\n} from \"@base/client/components\";\nimport { cn } from \"@heroui/theme\";\nimport { Ellipsis } from \"lucide-react\";\n\ntype ButtonVariant = \"solid\" | \"flat\" | \"bordered\" | \"light\";\n\nexport type ActionItemBase = {\n  key: string;\n  label: string;\n  startContent?: React.ReactNode;\n  disabled?: boolean;\n  placement?: \"inline\" | \"menu\";\n};\n\nexport type ActionItemButton = ActionItemBase & {\n  onPress: () => void;\n  variant?: ButtonVariant;\n};\n\nexport type ActionItemLink = ActionItemBase & {\n  href: string;\n  as?: string;\n  target?: string;\n  variant?: ButtonVariant;\n};\n\nexport type ActionItem = ActionItemButton | ActionItemLink;\n\nexport interface ActionMenuProps {\n  actions: ActionItem[];\n  className?: string;\n}\n\nconst isLink = (action: ActionItem): action is ActionItemLink =>\n  \"href\" in action;\n\nconst ActionMenu: React.FC<ActionMenuProps> = ({ actions, className }) => {\n  const inlineActions = actions.filter((a) => a.placement !== \"menu\");\n  const menuActions = actions.filter((a) => a.placement === \"menu\");\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      {inlineActions.map((action) => {\n        if (isLink(action)) {\n          return (\n            <IBaseButton\n              key={action.key}\n              as={IBaseLink}\n              disabled={action.disabled}\n              href={action.href}\n              rel={action.as}\n              size=\"sm\"\n              startContent={action.startContent}\n              target={action.target}\n              variant={action.variant ?? \"bordered\"}\n            >\n              {action.label}\n            </IBaseButton>\n          );\n        }\n\n        return (\n          <IBaseButton\n            key={action.key}\n            disabled={action.disabled}\n            size=\"sm\"\n            startContent={action.startContent}\n            variant={action.variant ?? \"solid\"}\n            onPress={action.onPress}\n          >\n            {action.label}\n          </IBaseButton>\n        );\n      })}\n\n      {menuActions.length > 0 && (\n        <IBaseDropdown>\n          <IBaseDropdownTrigger>\n            <IBaseButton\n              isIconOnly\n              className=\"min-w-unit-8 h-6\"\n              radius=\"full\"\n              variant=\"faded\"\n            >\n              <Ellipsis className=\"size-4\" />\n            </IBaseButton>\n          </IBaseDropdownTrigger>\n          <IBaseDropdownMenu aria-label=\"Actions\" items={menuActions}>\n            {(action) => (\n              <IBaseDropdownItem\n                key={action.key}\n                isDisabled={action.disabled}\n                startContent={action.startContent}\n                textValue={action.label}\n                onPress={isLink(action) ? undefined : action.onPress}\n                {...(isLink(action)\n                  ? {\n                      href: action.href,\n                      target: action.target,\n                      rel: action.as,\n                    }\n                  : {})}\n              >\n                {action.label}\n              </IBaseDropdownItem>\n            )}\n          </IBaseDropdownMenu>\n        </IBaseDropdown>\n      )}\n    </div>\n  );\n};\n\nexport default ActionMenu;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ActionMenu/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/AddressPicker/AddressPicker.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":34,"fix":{"range":[164,885],"text":"import { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { buildAddressString } from \"@base/client/utils/address/addressUtils\";\nimport { useDisclosure } from \"@heroui/use-disclosure\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapPin } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport dynamic from \"next/dynamic\";\nimport { useMemo, useState } from \"react\";\nimport {\n  IBaseButton,\n  IBaseInput,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n  IBaseSingleSelect,\n  IBaseTooltip,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `react`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":72,"fix":{"range":[386,885],"text":"import locationService from \"@base/client/services/LocationService\";\nimport { buildAddressString } from \"@base/client/utils/address/addressUtils\";\nimport { useDisclosure } from \"@heroui/use-disclosure\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapPin } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport dynamic from \"next/dynamic\";\nimport { useMemo, useState } from \"react\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/LocationService` import should occur after import of `react`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":69,"fix":{"range":[458,885],"text":"import { buildAddressString } from \"@base/client/utils/address/addressUtils\";\nimport { useDisclosure } from \"@heroui/use-disclosure\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapPin } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport dynamic from \"next/dynamic\";\nimport { useMemo, useState } from \"react\";\nimport locationService from \"@base/client/services/LocationService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":78,"fix":{"range":[604,604],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/utils/address/addressUtils` import should occur after import of `react`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":78,"fix":{"range":[527,885],"text":"import { useDisclosure } from \"@heroui/use-disclosure\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapPin } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport dynamic from \"next/dynamic\";\nimport { useMemo, useState } from \"react\";\nimport { buildAddressString } from \"@base/client/utils/address/addressUtils\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":29,"column":45,"nodeType":null,"messageId":"insert","endLine":29,"endColumn":45,"fix":{"range":[1028,1028],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":32,"column":45,"nodeType":null,"messageId":"insert","endLine":32,"endColumn":45,"fix":{"range":[1118,1118],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":78,"column":33,"nodeType":null,"messageId":"insert","endLine":78,"endColumn":33,"fix":{"range":[2451,2451],"text":","}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updatedAddress' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":128,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":8,"source":"\"use client\";\nimport type { Address, countryCode } from \"@base/client/interface/Address\";\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport {\n  IBaseButton,\n  IBaseInput,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n  IBaseSingleSelect,\n  IBaseTooltip,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { buildAddressString } from \"@base/client/utils/address/addressUtils\";\nimport { useDisclosure } from \"@heroui/use-disclosure\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { MapPin } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport dynamic from \"next/dynamic\";\nimport { useMemo, useState } from \"react\";\n// @ts-ignore\n// dynamic import PickerAddressByCountryUS\nconst PickerAddressByCountryUS = dynamic(\n  () => import(\"./PickerAddressByCountryUS\")\n);\nconst PickerAddressByCountryVN = dynamic(\n  () => import(\"./PickerAddressByCountryVN\")\n);\n\nexport interface AddressPickerProps {\n  value?: Address | null;\n  onChange: (value: string) => void;\n  isShowPostalCode?: boolean;\n}\n\nexport default function AddressPicker({\n  value,\n  onChange,\n  isShowPostalCode = false,\n}: AddressPickerProps) {\n  const { isOpen, onOpen, onClose } = useDisclosure();\n  const getLocalizedName = useLocalizedText();\n  const locale = useLocale();\n  const t = useTranslations(\"addressPicker\");\n  const tCommon = useTranslations(\"common\");\n  const isChangeAddress =\n    !!value?.formattedAddress && value.formattedAddress !== \"\";\n\n  // get countries from database\n  const { data: countries = [] } = useQuery({\n    queryKey: [\"countries\"],\n    queryFn: async () => {\n      const response = await locationService.getCountries();\n\n      return response.data || [];\n    },\n  });\n\n  const countryItems = useMemo<SelectItemOption[]>(() => {\n    return countries.map((country) => {\n      const name = getLocalizedName(country.name as LocalizeText);\n      const nameObj = country.name as LocalizeText;\n\n      return {\n        value: country.code,\n        label: name,\n        searchText: `${name} ${nameObj.vi || \"\"} ${nameObj.en || \"\"}`,\n      };\n    });\n  }, [countries, getLocalizedName]);\n\n  const [selectedCountryCode, setSelectedCountryCode] = useState<countryCode>(\n    value?.country?.code ?? \"VN\"\n  );\n\n  const [tempAddress, setTempAddress] = useState<Address>({\n    country: {\n      id: \"\",\n      name: { vi: \"\", en: \"\" },\n      code: selectedCountryCode,\n    },\n    administrativeUnits: [],\n    street: \"\",\n    postalCode: \"\",\n    latitude: undefined,\n    longitude: undefined,\n    formattedAddress: \"\",\n  });\n\n  const handleOpen = () => {\n    // Reset tempAddress when opening modal\n    if (value) {\n      setTempAddress(value);\n    } else {\n      setTempAddress({\n        country: {\n          id: selectedCountryCode,\n          name: (countries.find((c) => c.id === selectedCountryCode)\n            ?.name as LocalizeText) || {\n            vi: \"\",\n            en: \"\",\n          },\n          code: selectedCountryCode,\n        },\n        administrativeUnits: [],\n        street: \"\",\n        postalCode: \"\",\n        latitude: undefined,\n        longitude: undefined,\n        formattedAddress: \"\",\n      });\n    }\n    onOpen();\n  };\n\n  const fullAddress = buildAddressString(tempAddress, locale ?? \"vi\");\n\n  const handleSave = () => {\n    // Build Address object with administrativeUnits array\n    const addressString = buildAddressString(tempAddress, locale ?? \"vi\");\n\n    // Update formattedAddress in tempAddress\n    const updatedAddress: Address = {\n      ...tempAddress,\n      formattedAddress: addressString,\n    };\n\n    // Call onChange with the formatted address string\n    onChange(addressString);\n    onClose();\n  };\n\n  const handleClose = () => {\n    // Reset state when closing modal\n    const initialCountryCode = value?.country?.code ?? \"VN\";\n\n    setSelectedCountryCode(initialCountryCode);\n\n    if (value) {\n      setTempAddress(value);\n    } else {\n      setTempAddress({\n        country: {\n          id: initialCountryCode,\n          name: (countries.find((c) => c.id === initialCountryCode)\n            ?.name as LocalizeText) || {\n            vi: \"\",\n            en: \"\",\n          },\n          code: initialCountryCode,\n        },\n        administrativeUnits: [],\n        street: \"\",\n        postalCode: \"\",\n        latitude: undefined,\n        longitude: undefined,\n        formattedAddress: \"\",\n      });\n    }\n    onClose();\n  };\n\n  const handleCancel = () => {\n    handleClose();\n  };\n\n  const renderPickerAddressByCountry = (countryCode: countryCode) => {\n    switch (countryCode) {\n      case \"VN\":\n        return (\n          <PickerAddressByCountryVN\n            countryCode={countryCode}\n            setTempAddress={setTempAddress}\n            tempAddress={tempAddress}\n          />\n        );\n      default:\n        return (\n          <PickerAddressByCountryUS\n            countryCode={countryCode}\n            setTempAddress={setTempAddress}\n            tempAddress={tempAddress}\n          />\n        );\n    }\n  };\n\n  return (\n    <>\n      <div className=\"flex flex-col gap-2\">\n        <IBaseTooltip\n          content={isChangeAddress ? t(\"tooltip.change\") : t(\"tooltip.select\")}\n          placement=\"top\"\n        >\n          <IBaseButton\n            isIconOnly\n            color=\"primary\"\n            size=\"sm\"\n            startContent={<MapPin size={16} />}\n            type=\"button\"\n            variant=\"bordered\"\n            onPress={handleOpen}\n          />\n        </IBaseTooltip>\n      </div>\n\n      <IBaseModal\n        isOpen={isOpen}\n        scrollBehavior=\"inside\"\n        size=\"2xl\"\n        onClose={handleClose}\n      >\n        <IBaseModalContent>\n          {() => (\n            <>\n              <IBaseModalHeader className=\"flex flex-col gap-1\">\n                {t(\"modal.title\")}\n              </IBaseModalHeader>\n              <IBaseModalBody>\n                <div className=\"flex flex-col gap-4\">\n                  <IBaseSingleSelect\n                    disallowEmptySelection\n                    isRequired\n                    classNames={{\n                      popoverContent: \"max-w-full\",\n                    }}\n                    items={countryItems}\n                    label={t(\"modal.country.label\")}\n                    placeholder={t(\"modal.country.placeholder\")}\n                    selectedKey={selectedCountryCode || \"VN\"}\n                    onSelectionChange={(key) => {\n                      // Prevent deselection - at least one item must be selected\n                      if (key) {\n                        setSelectedCountryCode(key as countryCode);\n                      }\n                    }}\n                  />\n\n                  {renderPickerAddressByCountry(selectedCountryCode)}\n\n                  {isShowPostalCode && (\n                    <IBaseInput\n                      label={t(\"modal.postalCode.label\")}\n                      placeholder={t(\"modal.postalCode.placeholder\")}\n                      value={tempAddress.postalCode || \"\"}\n                      onValueChange={(value) =>\n                        setTempAddress((prev) => ({\n                          ...prev,\n                          postalCode: value,\n                        }))\n                      }\n                    />\n                  )}\n\n                  {/* show is formattedAddress is a string */}\n\n                  <div className=\"flex flex-col gap-2 text-sm text-default-400 italic\">\n                    {fullAddress as string}\n                  </div>\n                </div>\n              </IBaseModalBody>\n              <IBaseModalFooter>\n                <IBaseButton\n                  size=\"sm\"\n                  variant=\"bordered\"\n                  onPress={handleCancel}\n                >\n                  {tCommon(\"modal.buttons.cancel\")}\n                </IBaseButton>\n                <IBaseButton\n                  color=\"primary\"\n                  isDisabled={!selectedCountryCode}\n                  size=\"sm\"\n                  onPress={handleSave}\n                >\n                  {tCommon(\"modal.buttons.apply\")}\n                </IBaseButton>\n              </IBaseModalFooter>\n            </>\n          )}\n        </IBaseModalContent>\n      </IBaseModal>\n    </>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/AddressPicker/PickerAddressByCountryUS.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'countryCode' is assigned a value but never used. Allowed unused args must match /^_.*?$/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tempAddress' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setTempAddress' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Address, countryCode } from \"../../interface/Address\";\n\nimport { Dispatch, SetStateAction } from \"react\";\n\ninterface PickerAddressByCountryUSProps {\n  countryCode?: countryCode;\n  tempAddress: Address;\n  setTempAddress: Dispatch<SetStateAction<Address>>;\n}\n\nconst PickerAddressByCountryUS = ({\n  countryCode = \"US\",\n  tempAddress,\n  setTempAddress,\n}: PickerAddressByCountryUSProps) => {\n  return (\n    <div>\n      <h1>Picker Address By Country US</h1>\n    </div>\n  );\n};\n\nexport default PickerAddressByCountryUS;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/AddressPicker/PickerAddressByCountryVN.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":84,"fix":{"range":[514,514],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":50,"fix":{"range":[192,565],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { createAdministrativeUnit } from \"@base/client/utils/address/addressUtils\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":45,"fix":{"range":[192,610],"text":"import { useTranslations } from \"next-intl\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { createAdministrativeUnit } from \"@base/client/utils/address/addressUtils\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":69,"fix":{"range":[192,679],"text":"import { Dispatch, SetStateAction, useMemo, useState } from \"react\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { createAdministrativeUnit } from \"@base/client/utils/address/addressUtils\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport type {\n  Address,\n  AdministrativeUnit,\n  countryCode,\n} from \"@base/client/interface/Address\";\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport locationService from \"@base/client/services/LocationService\";\nimport { createAdministrativeUnit } from \"@base/client/utils/address/addressUtils\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { Dispatch, SetStateAction, useMemo, useState } from \"react\";\n\ninterface PickerAddressByCountryVNProps {\n  countryCode?: countryCode;\n  tempAddress: Address;\n  setTempAddress: Dispatch<SetStateAction<Address>>;\n}\n\nconst PickerAddressByCountryVN = ({\n  countryCode = \"VN\",\n  tempAddress,\n  setTempAddress,\n}: PickerAddressByCountryVNProps) => {\n  const getLocalizedName = useLocalizedText();\n  const t = useTranslations(\"addressPicker.vietnam\");\n  const [selectedProvinceId, setSelectedProvinceId] = useState<string>(\"\");\n  const [selectedWardId, setSelectedWardId] = useState<string>(\"\");\n\n  // Fetch provinces (level 1, no parent)\n  const { data: provinces = [] } = useQuery({\n    queryKey: [\"provinces\", countryCode],\n    queryFn: async () => {\n      const response = await locationService.getLocationByCountryCode(\n        countryCode,\n        {\n          parentId: null,\n          level: 1,\n        },\n      );\n\n      return response.data || [];\n    },\n  });\n\n  // Fetch wards/communes/townships trực tiếp theo province (cấu trúc mới - level 3)\n  const { data: wards = [] } = useQuery({\n    queryKey: [\"wards\", selectedProvinceId],\n    queryFn: async () => {\n      if (!selectedProvinceId) {\n        return [];\n      }\n\n      // Get all level 3 units (ward, commune, township) under the selected province\n      const response = await locationService.getLocationBy(\n        selectedProvinceId,\n        \"ward\",\n      );\n\n      return response.data || [];\n    },\n    enabled: !!selectedProvinceId,\n  });\n\n  // Convert provinces to SelectItemOption format\n  const provinceItems = useMemo<SelectItemOption[]>(() => {\n    return provinces.map((province) => {\n      const name = getLocalizedName(province.name as LocalizeText);\n      const nameObj = province.name as LocalizeText;\n      // Include both Vietnamese and English names for better search\n      const searchText = `${name} ${nameObj.vi || \"\"} ${nameObj.en || \"\"}`;\n\n      return {\n        value: province.id,\n        label: name,\n        searchText: searchText,\n      };\n    });\n  }, [provinces, getLocalizedName]);\n\n  // Convert wards to SelectItemOption format\n  const wardItems = useMemo<SelectItemOption[]>(() => {\n    return wards.map((ward) => {\n      const name = getLocalizedName(ward.name as LocalizeText);\n      const nameObj = ward.name as LocalizeText;\n      // Include both Vietnamese and English names for better search\n      const searchText = `${name} ${nameObj.vi || \"\"} ${nameObj.en || \"\"}`;\n\n      return {\n        value: ward.id,\n        label: name,\n        searchText: searchText,\n      };\n    });\n  }, [wards, getLocalizedName]);\n\n  // Helper function để build và update administrativeUnits và formattedAddress\n  const updateAdministrativeUnits = (provinceId: string, wardId: string) => {\n    const units: AdministrativeUnit[] = [];\n\n    // Add Province (level 1)\n    if (provinceId) {\n      const province = provinces.find((p) => p.id === provinceId);\n\n      if (province) {\n        units.push(\n          createAdministrativeUnit(\n            province.id,\n            province.name as Record<string, string>,\n            \"province\",\n          ),\n        );\n      }\n    }\n\n    // Add Ward/Commune/Township (level 3) - trực thuộc tỉnh/TP\n    if (wardId) {\n      const ward = wards.find((w) => w.id === wardId);\n\n      if (ward) {\n        units.push(\n          createAdministrativeUnit(\n            ward.id,\n            ward.name as Record<string, string>,\n            ward.type as \"ward\" | \"commune\" | \"township\",\n          ),\n        );\n      }\n    }\n\n    // Build formattedAddress từ tempAddress với administrativeUnits mới\n    const updatedAddress: Address = {\n      ...tempAddress,\n      administrativeUnits: units,\n    };\n\n    setTempAddress(updatedAddress);\n  };\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <IBaseSingleSelect\n        disallowEmptySelection={false}\n        items={provinceItems}\n        label={t(\"province.label\")}\n        placeholder={t(\"province.placeholder\")}\n        selectedKey={selectedProvinceId || undefined}\n        onSelectionChange={(key) => {\n          const newProvinceId = key || \"\";\n\n          setSelectedProvinceId(newProvinceId);\n          // Reset ward khi đổi province\n          setSelectedWardId(\"\");\n          // Update administrativeUnits\n          updateAdministrativeUnits(newProvinceId, \"\");\n        }}\n      />\n\n      {/* Phường/Xã/Thị trấn - Required (trực thuộc tỉnh/TP) */}\n      <IBaseSingleSelect\n        disallowEmptySelection={false}\n        isDisabled={!selectedProvinceId}\n        items={wardItems}\n        label={t(\"ward.label\")}\n        placeholder={t(\"ward.placeholder\")}\n        selectedKey={selectedWardId || undefined}\n        onSelectionChange={(key) => {\n          const newWardId = key || \"\";\n\n          setSelectedWardId(newWardId);\n          // Update administrativeUnits\n          updateAdministrativeUnits(selectedProvinceId, newWardId);\n        }}\n      />\n\n      {/* Địa chỉ đường */}\n      <IBaseInput\n        label={t(\"street.label\")}\n        placeholder={t(\"street.placeholder\")}\n        value={\n          typeof tempAddress.street === \"string\"\n            ? tempAddress.street\n            : getLocalizedName(tempAddress.street) || \"\"\n        }\n        onValueChange={(value) => {\n          const updatedAddress: Address = {\n            ...tempAddress,\n            street: value,\n          };\n\n          setTempAddress({\n            ...updatedAddress,\n          });\n        }}\n      />\n    </div>\n  );\n};\n\nexport default PickerAddressByCountryVN;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/AddressPicker/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseAccordion/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Accordion·as·HeroUIAccordion,·AccordionItem·as·HeroUIAccordionItem,·AccordionProps·` with `⏎··Accordion·as·HeroUIAccordion,⏎··AccordionItem·as·HeroUIAccordionItem,⏎··AccordionProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":93,"fix":{"range":[23,107],"text":"\n  Accordion as HeroUIAccordion,\n  AccordionItem as HeroUIAccordionItem,\n  AccordionProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":12,"column":55,"nodeType":null,"messageId":"delete","endLine":13,"endColumn":1,"fix":{"range":[392,393],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Accordion as HeroUIAccordion, AccordionItem as HeroUIAccordionItem, AccordionProps } from \"@heroui/accordion\";\nimport React from \"react\";\n\nexport type IBaseAccordionProps = AccordionProps & {};\n\nexport const IBaseAccordion: React.FC<IBaseAccordionProps> = (props) => {\n  return <HeroUIAccordion {...props} />;\n};\n\nexport const IBaseAccordionItem = HeroUIAccordionItem;\n\n\nexport default IBaseAccordion;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseAutocomplete/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Autocomplete·as·HeroUIAutocomplete,·AutocompleteItem·as·HeroUIAutocompleteItem,·AutocompleteSection·as·HeroUIAutocompleteSection,·AutocompleteProps·` with `⏎··Autocomplete·as·HeroUIAutocomplete,⏎··AutocompleteItem·as·HeroUIAutocompleteItem,⏎··AutocompleteSection·as·HeroUIAutocompleteSection,⏎··AutocompleteProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":158,"fix":{"range":[23,172],"text":"\n  Autocomplete as HeroUIAutocomplete,\n  AutocompleteItem as HeroUIAutocompleteItem,\n  AutocompleteSection as HeroUIAutocompleteSection,\n  AutocompleteProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":22,"column":67,"nodeType":null,"messageId":"delete","endLine":23,"endColumn":1,"fix":{"range":[753,754],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Autocomplete as HeroUIAutocomplete, AutocompleteItem as HeroUIAutocompleteItem, AutocompleteSection as HeroUIAutocompleteSection, AutocompleteProps } from \"@heroui/autocomplete\";\nimport React from \"react\";\n\nexport type IBaseAutocompleteProps = AutocompleteProps & {};\n\nexport const IBaseAutocomplete = React.forwardRef<\n  HTMLInputElement,\n  IBaseAutocompleteProps\n>((props, ref) => {\n  const { size = \"sm\", variant = \"bordered\", ...rest } = props;\n\n  return (\n    <HeroUIAutocomplete ref={ref} size={size} variant={variant} {...rest} />\n  );\n});\n\nIBaseAutocomplete.displayName = \"IBaseAutocomplete\";\n\nexport const IBaseAutocompleteItem = HeroUIAutocompleteItem;\nexport const IBaseAutocompleteSection = HeroUIAutocompleteSection;\n\n\nexport default IBaseAutocomplete;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseAvatar/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·AvatarGroupProps,·AvatarProps,·Avatar·as·HeroUIAvatar,·AvatarGroup·as·HeroUIAvatarGroup·` with `⏎··AvatarGroupProps,⏎··AvatarProps,⏎··Avatar·as·HeroUIAvatar,⏎··AvatarGroup·as·HeroUIAvatarGroup,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":98,"fix":{"range":[23,112],"text":"\n  AvatarGroupProps,\n  AvatarProps,\n  Avatar as HeroUIAvatar,\n  AvatarGroup as HeroUIAvatarGroup,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":13,"column":4,"nodeType":null,"messageId":"insert","endLine":13,"endColumn":4,"fix":{"range":[424,424],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `HTMLDivElement,·AvatarGroupProps>(⏎··` with `⏎··HTMLDivElement,⏎··AvatarGroupProps⏎>(`","line":18,"column":50,"nodeType":null,"messageId":"replace","endLine":19,"endColumn":3,"fix":{"range":[520,557],"text":"\n  HTMLDivElement,\n  AvatarGroupProps\n>("}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":20,"column":3,"nodeType":null,"messageId":"delete","endLine":20,"endColumn":5,"fix":{"range":[577,579],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":22,"column":1,"nodeType":null,"messageId":"delete","endLine":22,"endColumn":3,"fix":{"range":[620,622],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `··}⏎` with `}`","line":23,"column":1,"nodeType":null,"messageId":"replace","endLine":24,"endColumn":1,"fix":{"range":[686,690],"text":"}"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":6,"source":"\"use client\";\n\nimport { AvatarGroupProps, AvatarProps, Avatar as HeroUIAvatar, AvatarGroup as HeroUIAvatarGroup } from \"@heroui/avatar\";\nimport React from \"react\";\n\nexport type IBaseAvatarProps = AvatarProps & {};\n\nexport const IBaseAvatar = React.forwardRef<HTMLSpanElement, IBaseAvatarProps>(\n  (props, ref) => {\n    const { size = \"sm\", ...rest } = props;\n\n    return <HeroUIAvatar ref={ref} size={size} {...rest} />;\n  }\n);\n\nIBaseAvatar.displayName = \"IBaseAvatar\";\n\nexport const IBaseAvatarGroup = React.forwardRef<HTMLDivElement, AvatarGroupProps>(\n  (props, ref) => {\n    const { size = \"sm\", ...rest } = props;\n\n    return <HeroUIAvatarGroup ref={ref} size={size} {...rest} />;\n  }\n);\n\nIBaseAvatarGroup.displayName = \"IBaseAvatarGroup\";\n\nexport default IBaseAvatar;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseBadge/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseBreadcrumbs/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·BreadcrumbItem·as·HeroUIBreadcrumbItem,·Breadcrumbs·as·HeroUIBreadcrumbs,·BreadcrumbsProps·` with `⏎··BreadcrumbItem·as·HeroUIBreadcrumbItem,⏎··Breadcrumbs·as·HeroUIBreadcrumbs,⏎··BreadcrumbsProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":101,"fix":{"range":[23,115],"text":"\n  BreadcrumbItem as HeroUIBreadcrumbItem,\n  Breadcrumbs as HeroUIBreadcrumbs,\n  BreadcrumbsProps,\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { BreadcrumbItem as HeroUIBreadcrumbItem, Breadcrumbs as HeroUIBreadcrumbs, BreadcrumbsProps } from \"@heroui/breadcrumbs\";\nimport React from \"react\";\n\nexport type IBaseBreadcrumbsProps = BreadcrumbsProps & {};\n\nexport const IBaseBreadcrumbs: React.FC<IBaseBreadcrumbsProps> = (props) => {\n  const { size = \"sm\", ...rest } = props;\n\n  return <HeroUIBreadcrumbs size={size} {...rest} />;\n};\n\nexport const IBaseBreadcrumbItem = HeroUIBreadcrumbItem;\n\nexport default IBaseBreadcrumbs;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseButton/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `HTMLButtonElement,·IBaseButtonProps>(⏎··` with `⏎··HTMLButtonElement,⏎··IBaseButtonProps⏎>(`","line":8,"column":45,"nodeType":null,"messageId":"replace","endLine":9,"endColumn":3,"fix":{"range":[207,247],"text":"\n  HTMLButtonElement,\n  IBaseButtonProps\n>("}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":10,"column":3,"nodeType":null,"messageId":"delete","endLine":10,"endColumn":5,"fix":{"range":[267,269],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":12,"column":1,"nodeType":null,"messageId":"delete","endLine":12,"endColumn":3,"fix":{"range":[329,331],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `··},⏎` with `}`","line":13,"column":1,"nodeType":null,"messageId":"replace","endLine":14,"endColumn":1,"fix":{"range":[408,413],"text":"}"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { Button as HeroUIButton, ButtonProps } from \"@heroui/button\";\nimport React from \"react\";\n\nexport type IBaseButtonProps = ButtonProps & {};\n\nexport const IBaseButton = React.forwardRef<HTMLButtonElement, IBaseButtonProps>(\n  (props, ref) => {\n    const { size = \"sm\", variant = \"solid\", ...rest } = props;\n\n    return <HeroUIButton ref={ref} size={size} variant={variant} {...rest} />;\n  },\n);\n\nIBaseButton.displayName = \"IBaseButton\";\n\nexport default IBaseButton;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseCalendar/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseCard/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Card·as·HeroUICard,·CardBody·as·HeroUICardBody,·CardFooter·as·HeroUICardFooter,·CardHeader·as·HeroUICardHeader,·CardProps·` with `⏎··Card·as·HeroUICard,⏎··CardBody·as·HeroUICardBody,⏎··CardFooter·as·HeroUICardFooter,⏎··CardHeader·as·HeroUICardHeader,⏎··CardProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":132,"fix":{"range":[23,146],"text":"\n  Card as HeroUICard,\n  CardBody as HeroUICardBody,\n  CardFooter as HeroUICardFooter,\n  CardHeader as HeroUICardHeader,\n  CardProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `<HeroUICardBody·{...props}·/>` with `(⏎··<HeroUICardBody·{...props}·/>⏎)`","line":19,"column":56,"nodeType":null,"messageId":"replace","endLine":19,"endColumn":85,"fix":{"range":[584,613],"text":"(\n  <HeroUICardBody {...props} />\n)"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":22,"column":3,"nodeType":null,"messageId":"delete","endLine":23,"endColumn":1,"fix":{"range":[710,711],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { Card as HeroUICard, CardBody as HeroUICardBody, CardFooter as HeroUICardFooter, CardHeader as HeroUICardHeader, CardProps } from \"@heroui/card\";\nimport React from \"react\";\n\nexport type IBaseCardProps = CardProps & {};\n\nexport const IBaseCard = React.forwardRef<HTMLDivElement, IBaseCardProps>(\n  (props, ref) => {\n    return <HeroUICard ref={ref} {...props} />;\n  },\n);\n\nIBaseCard.displayName = \"IBaseCard\";\n\nexport const IBaseCardHeader: React.FC<any> = (props) => (\n  <HeroUICardHeader {...props} />\n);\nexport const IBaseCardBody: React.FC<any> = (props) => <HeroUICardBody {...props} />;\nexport const IBaseCardFooter: React.FC<any> = (props) => (\n  <HeroUICardFooter {...props} />\n);\n\n\nexport default IBaseCard;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseCheckbox/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseChip/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseDigitViewer/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseDivider/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseDropdown/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":64,"column":35,"nodeType":null,"messageId":"insert","endLine":64,"endColumn":35,"fix":{"range":[2097,2097],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":100,"column":175,"nodeType":null,"messageId":"insert","endLine":100,"endColumn":175,"fix":{"range":[3228,3228],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  Dropdown,\n  DropdownItem,\n  DropdownMenu,\n  DropdownSection,\n  DropdownTrigger,\n  type DropdownItemProps,\n  type DropdownMenuProps,\n  type DropdownProps,\n} from \"@heroui/dropdown\";\nimport clsx from \"clsx\";\nimport React from \"react\";\n\nexport type IBaseDropdownItem = DropdownItemProps & { key: React.Key };\n\nexport type IBaseDropdownProps<\n  TItem extends IBaseDropdownItem = IBaseDropdownItem,\n> = Omit<DropdownProps, \"children\"> & {\n  /**\n   * Items to render in the dropdown menu. If provided, the component acts as a wrapper\n   * automatically rendering DropdownTrigger and DropdownMenu.\n   */\n  items?: Iterable<TItem>;\n  /**\n   * Content. If `items` is provided, this is treated as the trigger content.\n   * If `items` is NOT provided, this should contain standard HeroUI children (Trigger and Menu).\n   */\n  children: React.ReactNode;\n  /**\n   * Props forwarded to the underlying `<DropdownMenu />`. Only used in wrapper mode (when `items` is provided).\n   */\n  menu?: Omit<DropdownMenuProps<TItem>, \"children\"> & {\n    /**\n     * Provide custom children for `<DropdownMenu />`. If set, it takes priority over `items` + `menu.renderItem`.\n     */\n    children?: DropdownMenuProps<TItem>[\"children\"];\n    /**\n     * Custom item renderer (for dynamic items). If provided, you should return a `<DropdownItem />` (or compatible).\n     * `key` will be auto-applied from `item.key` if missing.\n     */\n    renderItem?: (item: TItem) => React.ReactNode;\n  };\n};\n\nconst getTextValue = (item: IBaseDropdownItem) =>\n  item.textValue ??\n  (typeof item.title === \"string\"\n    ? item.title\n    : typeof item.children === \"string\"\n      ? item.children\n      : String(item.key));\n\n/**\n * IBaseDropdown is a wrapper around HeroUI Dropdown.\n * It supports two modes:\n * 1. Wrapper mode: provide `items` and optionally `menu`. The first child will be used as the trigger.\n * 2. Standard mode: provide standard HeroUI Dropdown children (Trigger and Menu).\n */\nexport const IBaseDropdown = <\n  TItem extends IBaseDropdownItem = IBaseDropdownItem,\n>(\n  props: IBaseDropdownProps<TItem>\n) => {\n  const { items, children, menu, ...dropdownProps } = props;\n\n  // If no items provided and no menu config, act as a standard Dropdown wrapper\n  if (!items && !menu) {\n    return (\n      <Dropdown {...(dropdownProps as DropdownProps)}>\n        {children as any}\n      </Dropdown>\n    );\n  }\n\n  const {\n    renderItem,\n    items: menuItems,\n    children: menuChildren,\n    ...menuProps\n  } = (menu ?? {}) as DropdownMenuProps<TItem> & {\n    renderItem?: (item: TItem) => React.ReactNode;\n  };\n\n  const itemClasses = (menuProps as any)?.itemClasses ?? {};\n  const hasMenuColor = (menuProps as any)?.color != null;\n\n  const menuPropsMerged = {\n    variant: \"flat\",\n    ...(menuProps ?? {}),\n    itemClasses: {\n      ...itemClasses,\n      base: hasMenuColor\n        ? itemClasses.base\n        : clsx(\n            itemClasses.base,\n            \"data-[hover=true]:!bg-[var(--dropdown-hover)]\",\n            \"data-[focus=true]:!bg-[var(--dropdown-hover)]\",\n            \"data-[focus-visible=true]:ring-2 data-[focus-visible=true]:ring-primary data-[focus-visible=true]:ring-offset-2 data-[focus-visible=true]:ring-offset-background\"\n          ),\n    },\n  } as DropdownMenuProps<TItem>;\n\n  return (\n    <Dropdown {...(dropdownProps as DropdownProps)}>\n      <DropdownTrigger>{children}</DropdownTrigger>\n      {menuChildren != null ? (\n        typeof menuChildren === \"function\" ? (\n          <DropdownMenu\n            {...menuPropsMerged}\n            items={(menuItems ?? items) as any}\n          >\n            {menuChildren as any}\n          </DropdownMenu>\n        ) : (\n          <DropdownMenu {...menuPropsMerged}>\n            {menuChildren as any}\n          </DropdownMenu>\n        )\n      ) : (\n        <DropdownMenu {...menuPropsMerged} items={(menuItems ?? items) as any}>\n          {\n            ((item: TItem, index: number) => {\n              const node = renderItem\n                ? renderItem(item)\n                : (() => {\n                    const { children: itemChildren, ...itemProps } =\n                      item as unknown as IBaseDropdownItem;\n\n                    return (\n                      <DropdownItem\n                        {...(itemProps as any)}\n                        key={item.key ?? String(index)}\n                        textValue={getTextValue(item as any)}\n                      >\n                        {itemChildren}\n                      </DropdownItem>\n                    );\n                  })();\n\n              if (React.isValidElement(node) && node.key == null) {\n                return React.cloneElement(node, {\n                  key: (item as unknown as IBaseDropdownItem).key,\n                } as never);\n              }\n\n              return node as never;\n            }) as any\n          }\n        </DropdownMenu>\n      )}\n    </Dropdown>\n  );\n};\n\nexport const IBaseDropdownTrigger = DropdownTrigger;\nexport const IBaseDropdownMenu = DropdownMenu;\nexport const IBaseDropdownItem = DropdownItem;\nexport const IBaseDropdownSection = DropdownSection;\n\nexport default IBaseDropdown;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseImage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseInput/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":34,"column":47,"nodeType":null,"messageId":"insert","endLine":34,"endColumn":47,"fix":{"range":[975,975],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":46,"column":4,"nodeType":null,"messageId":"insert","endLine":46,"endColumn":4,"fix":{"range":[1276,1276],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Input as HeroUIInput, InputProps } from \"@heroui/input\";\nimport clsx from \"clsx\";\nimport { useTranslations } from \"next-intl\";\nimport React from \"react\";\n\nexport type IBaseInputProps = Omit<InputProps, \"type\"> & {\n  /**\n   * `type=\"date\"` is intentionally disallowed. Use `IBaseDatePicker` instead.\n   */\n  type?: Exclude<InputProps[\"type\"], \"date\">;\n};\nexport const IBaseInput = React.forwardRef<HTMLInputElement, IBaseInputProps>(\n  (props, ref) => {\n    const t = useTranslations(\"components.input\");\n    const {\n      isDisabled,\n      size = \"sm\",\n      labelPlacement = \"outside\",\n      placeholder,\n      ...rest\n    } = props;\n    const defaultPlaceholder = t(\"placeholder\");\n\n    return (\n      <HeroUIInput\n        ref={ref}\n        classNames={{\n          base: \"max-w opacity-100\",\n          label: \"text-small text-default-600\",\n          mainWrapper: clsx(\n            \"cursor-not-allowed\",\n            isDisabled ? \"bg-default-200\" : \"\"\n          ),\n          input: \"placeholder:text-default-400 italic text-sm\",\n        }}\n        labelPlacement={labelPlacement}\n        placeholder={placeholder ?? defaultPlaceholder}\n        size={size}\n        variant=\"bordered\"\n        {...rest}\n        isDisabled={isDisabled}\n      />\n    );\n  }\n);\n\nIBaseInput.displayName = \"IBaseInput\";\n\nexport default IBaseInput;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseInputMultipleLang/TranslateModal.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[179,179],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[15,321],"text":"import { Languages } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport { useMemo, useState } from \"react\";\nimport {\n  IBaseButton,\n  IBaseInput,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":82,"column":49,"nodeType":null,"messageId":"insert","endLine":82,"endColumn":49,"fix":{"range":[2095,2095],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseInput,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\nimport { Languages } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport { useMemo, useState } from \"react\";\n\nimport {\n  DEFAULT_SUPPORTED_LANGS,\n  LocalizeText,\n  LocalizeTextKey,\n} from \"../../interface/LocalizeText\";\n\nexport interface TranslateModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSave: (langs: LocalizeText) => void;\n  value?: LocalizeText | string;\n}\n\nexport default function TranslateModal({\n  isOpen,\n  onClose,\n  onSave,\n  value,\n}: TranslateModalProps) {\n  const t = useTranslations(\"components.translate\");\n  const tCommon = useTranslations(\"common.actions\");\n  const currentLocale = useLocale();\n  const [langValues, setLangValues] = useState<LocalizeText>(() => {\n    if (typeof value === \"object\" && value !== null) {\n      return value as LocalizeText;\n    }\n\n    return DEFAULT_SUPPORTED_LANGS.reduce<LocalizeText>((acc, lang) => {\n      acc[lang as LocalizeTextKey] =\n        (value as unknown as LocalizeText)?.[lang as LocalizeTextKey] ?? \"\";\n\n      return acc;\n    }, {} as LocalizeText);\n  });\n  const labelText = useMemo(() => {\n    return {\n      en: t(\"english\"),\n      vi: t(\"vietnamese\"),\n    };\n  }, [t]);\n\n  // Update when initialLangs change\n\n  const handleLangChange = (lang: LocalizeTextKey, newValue: string) => {\n    setLangValues((prev) => ({\n      ...prev,\n      [lang]: newValue,\n    }));\n  };\n\n  const handleSave = () => {\n    onSave(langValues);\n    onClose();\n  };\n\n  return (\n    <IBaseModal isOpen={isOpen} placement=\"center\" size=\"md\" onClose={onClose}>\n      <IBaseModalContent>\n        {() => (\n          <>\n            <IBaseModalHeader className=\"flex items-center gap-2\">\n              <Languages size={20} />\n              {t(\"title\")}\n            </IBaseModalHeader>\n            <IBaseModalBody className=\"space-y-4\">\n              {DEFAULT_SUPPORTED_LANGS.filter(\n                (lang) => lang !== currentLocale\n              ).map((lang) => (\n                <div key={lang} className=\"flex flex-col gap-2\">\n                  <label className=\"text-sm font-medium\">\n                    {labelText[lang as LocalizeTextKey] ?? lang.toUpperCase()}\n                  </label>\n                  <IBaseInput\n                    value={langValues[lang as LocalizeTextKey]}\n                    variant=\"bordered\"\n                    onValueChange={(val) =>\n                      handleLangChange(lang as LocalizeTextKey, val)\n                    }\n                  />\n                </div>\n              ))}\n            </IBaseModalBody>\n            <IBaseModalFooter>\n              <IBaseButton variant=\"light\" onPress={onClose}>\n                {tCommon(\"cancel\")}\n              </IBaseButton>\n              <IBaseButton color=\"primary\" onPress={handleSave}>\n                {tCommon(\"save\")}\n              </IBaseButton>\n            </IBaseModalFooter>\n          </>\n        )}\n      </IBaseModalContent>\n    </IBaseModal>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseInputMultipleLang/index.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":54,"fix":{"range":[118,118],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":54,"fix":{"range":[65,333],"text":"import { Button } from \"@heroui/button\";\nimport { ArrowRight, Languages } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport React, { useCallback, useMemo, useState } from \"react\";\nimport { IBaseInput } from \"@base/client/components\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":31,"column":24,"nodeType":null,"messageId":"insert","endLine":31,"endColumn":24,"fix":{"range":[883,883],"text":","}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'defaultLangs' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":49,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":45},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":56,"column":20,"nodeType":null,"messageId":"insert","endLine":56,"endColumn":20,"fix":{"range":[1559,1559],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":63,"column":32,"nodeType":null,"messageId":"insert","endLine":63,"endColumn":32,"fix":{"range":[1789,1789],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":66,"column":58,"nodeType":null,"messageId":"insert","endLine":66,"endColumn":58,"fix":{"range":[1908,1908],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":94,"column":35,"nodeType":null,"messageId":"insert","endLine":94,"endColumn":35,"fix":{"range":[2740,2740],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":106,"column":25,"nodeType":null,"messageId":"insert","endLine":106,"endColumn":25,"fix":{"range":[3118,3118],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":116,"column":20,"nodeType":null,"messageId":"insert","endLine":116,"endColumn":20,"fix":{"range":[3331,3331],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":155,"column":61,"nodeType":null,"messageId":"insert","endLine":155,"endColumn":61,"fix":{"range":[4351,4351],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":10,"source":"\"use client\";\n\nimport type { InputProps } from \"@heroui/input\";\n\nimport { IBaseInput } from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { ArrowRight, Languages } from \"lucide-react\";\nimport { useLocale, useTranslations } from \"next-intl\";\nimport React, { useCallback, useMemo, useState } from \"react\";\n\nimport {\n  DEFAULT_SUPPORTED_LANGS,\n  LocalizeText,\n  LocalizeTextKey,\n} from \"../../interface/LocalizeText\";\n\nimport TranslateModal from \"./TranslateModal\";\n\nexport type IBaseInputMultipleLangProps = Omit<\n  InputProps,\n  \"endContent\" | \"value\" | \"onValueChange\"\n> & {\n  value?: LocalizeText | string;\n  onValueChange?: (value: LocalizeText) => void;\n  defaultLangs?: LocalizeText;\n};\n\n// Helper function outside component to avoid recreation on each render\nconst getLangValue = (\n  value: LocalizeText | string | undefined,\n  lang: LocalizeTextKey\n): string => {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (typeof value === \"object\" && value !== null) {\n    return value[lang] ?? \"\";\n  }\n\n  return \"\";\n};\n\nexport const IBaseInputMultipleLang = React.forwardRef<\n  HTMLInputElement,\n  IBaseInputMultipleLangProps\n>((props, ref) => {\n  const t = useTranslations(\"components.translate\");\n  const locale = useLocale();\n  const { value, onValueChange, defaultLangs, ...restProps } = props;\n\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  // Get current locale value for main input\n  const currentLocaleValue = useMemo(\n    () => getLangValue(value, locale as LocalizeTextKey),\n    [value, locale]\n  );\n\n  // Check if should show copy button\n  const shouldShowCopyButton = useMemo(() => {\n    const currentValue = currentLocaleValue.trim();\n    const otherLangs = DEFAULT_SUPPORTED_LANGS.filter(\n      (lang) => lang !== locale\n    );\n    const otherLangsValues = otherLangs.map((lang) =>\n      getLangValue(value, lang as LocalizeTextKey).trim()\n    );\n\n    // Case 1: Current locale is empty but at least one other lang has value\n    if (!currentValue && otherLangsValues.some((val) => val.length > 0)) {\n      return true;\n    }\n\n    // Case 2: Current locale has value but all other langs are empty\n    if (currentValue && otherLangsValues.every((val) => !val)) {\n      return true;\n    }\n\n    return false;\n  }, [currentLocaleValue, value, locale]);\n\n  const handleMainInputChange = useCallback(\n    (newValue: string) => {\n      // Update the current locale's value\n      const currentValue =\n        typeof value === \"object\" && value !== null ? value : {};\n      const newLocalizeValue = {\n        ...currentValue,\n        [locale as LocalizeTextKey]: newValue,\n      } as LocalizeText;\n\n      onValueChange?.(newLocalizeValue);\n    },\n    [value, locale, onValueChange]\n  );\n\n  const handleCopyToAll = useCallback(() => {\n    // Copy current locale value to all languages (including current locale)\n    const valueToCopy = currentLocaleValue;\n    const newLocalizeValue = DEFAULT_SUPPORTED_LANGS.reduce<LocalizeText>(\n      (acc, lang) => {\n        acc[lang as LocalizeTextKey] = valueToCopy;\n\n        return acc;\n      },\n      {} as LocalizeText\n    );\n\n    onValueChange?.(newLocalizeValue);\n  }, [currentLocaleValue, onValueChange]);\n\n  const handleSave = useCallback(\n    (langs: LocalizeText) => {\n      onValueChange?.(langs);\n    },\n    [onValueChange]\n  );\n\n  const handleOpenModal = useCallback(() => {\n    setIsModalOpen(true);\n  }, []);\n\n  const handleCloseModal = useCallback(() => {\n    setIsModalOpen(false);\n  }, []);\n\n  // Memoize endContent to prevent unnecessary re-renders\n  const endContent = useMemo(\n    () => (\n      <div className=\"flex items-center gap-1\">\n        {shouldShowCopyButton && (\n          <Button\n            isIconOnly\n            className=\"min-w-0 w-6 h-6\"\n            size=\"sm\"\n            title={t(\"copyToAll\")}\n            variant=\"light\"\n            onPress={handleCopyToAll}\n          >\n            <ArrowRight className=\"text-primary\" size={16} />\n          </Button>\n        )}\n        <Button\n          isIconOnly\n          className=\"min-w-0 w-6 h-6\"\n          size=\"sm\"\n          title={t(\"title\")}\n          variant=\"light\"\n          onPress={handleOpenModal}\n        >\n          <Languages className=\"text-primary\" size={16} />\n        </Button>\n      </div>\n    ),\n    [shouldShowCopyButton, handleCopyToAll, handleOpenModal]\n  );\n\n  return (\n    <>\n      <IBaseInput\n        ref={ref}\n        endContent={endContent}\n        value={currentLocaleValue}\n        onValueChange={handleMainInputChange}\n        {...restProps}\n      />\n      {isModalOpen && (\n        <TranslateModal\n          isOpen={isModalOpen}\n          value={value}\n          onClose={handleCloseModal}\n          onSave={handleSave}\n        />\n      )}\n    </>\n  );\n});\n\nIBaseInputMultipleLang.displayName = \"IBaseInputMultipleLang\";\n\nexport default IBaseInputMultipleLang;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseInputNumber/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseInputSearch/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseKbd/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseLink/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseModal/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Modal·as·HeroUIModal,·ModalBody·as·HeroUIModalBody,·ModalContent·as·HeroUIModalContent,·ModalFooter·as·HeroUIModalFooter,·ModalHeader·as·HeroUIModalHeader,·type·ModalBodyProps·as·HeroUIModalBodyProps,·type·ModalContentProps·as·HeroUIModalContentProps,·type·ModalFooterProps·as·HeroUIModalFooterProps,·type·ModalHeaderProps·as·HeroUIModalHeaderProps,·type·ModalProps·as·HeroUIModalProps·` with `⏎··Modal·as·HeroUIModal,⏎··ModalBody·as·HeroUIModalBody,⏎··ModalContent·as·HeroUIModalContent,⏎··ModalFooter·as·HeroUIModalFooter,⏎··ModalHeader·as·HeroUIModalHeader,⏎··type·ModalBodyProps·as·HeroUIModalBodyProps,⏎··type·ModalContentProps·as·HeroUIModalContentProps,⏎··type·ModalFooterProps·as·HeroUIModalFooterProps,⏎··type·ModalHeaderProps·as·HeroUIModalHeaderProps,⏎··type·ModalProps·as·HeroUIModalProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":396,"fix":{"range":[23,410],"text":"\n  Modal as HeroUIModal,\n  ModalBody as HeroUIModalBody,\n  ModalContent as HeroUIModalContent,\n  ModalFooter as HeroUIModalFooter,\n  ModalHeader as HeroUIModalHeader,\n  type ModalBodyProps as HeroUIModalBodyProps,\n  type ModalContentProps as HeroUIModalContentProps,\n  type ModalFooterProps as HeroUIModalFooterProps,\n  type ModalHeaderProps as HeroUIModalHeaderProps,\n  type ModalProps as HeroUIModalProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":67,"column":50,"nodeType":null,"messageId":"delete","endLine":68,"endColumn":1,"fix":{"range":[2141,2142],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Modal as HeroUIModal, ModalBody as HeroUIModalBody, ModalContent as HeroUIModalContent, ModalFooter as HeroUIModalFooter, ModalHeader as HeroUIModalHeader, type ModalBodyProps as HeroUIModalBodyProps, type ModalContentProps as HeroUIModalContentProps, type ModalFooterProps as HeroUIModalFooterProps, type ModalHeaderProps as HeroUIModalHeaderProps, type ModalProps as HeroUIModalProps } from \"@heroui/modal\";\nimport React from \"react\";\n\n// Export types\nexport type IBaseModalProps = HeroUIModalProps;\nexport type IBaseModalBodyProps = HeroUIModalBodyProps;\nexport type IBaseModalContentProps = HeroUIModalContentProps;\nexport type IBaseModalFooterProps = HeroUIModalFooterProps;\nexport type IBaseModalHeaderProps = HeroUIModalHeaderProps;\n\n// Main Modal component with default props\nexport const IBaseModal = React.forwardRef<HTMLDivElement, IBaseModalProps>(\n  (props, ref) => {\n    const {\n      placement = \"center\",\n      scrollBehavior = \"inside\",\n      backdrop = \"blur\",\n      ...rest\n    } = props;\n\n    return (\n      <HeroUIModal\n        ref={ref}\n        backdrop={backdrop}\n        placement={placement}\n        scrollBehavior={scrollBehavior}\n        {...rest}\n      />\n    );\n  },\n);\n\nIBaseModal.displayName = \"IBaseModal\";\n\n// ModalContent component\nexport const IBaseModalContent: React.FC<IBaseModalContentProps> = (props) => {\n  return <HeroUIModalContent {...props} />;\n};\n\nIBaseModalContent.displayName = \"IBaseModalContent\";\n\n// ModalHeader component\nexport const IBaseModalHeader: React.FC<IBaseModalHeaderProps> = (props) => {\n  return <HeroUIModalHeader {...props} />;\n};\n\nIBaseModalHeader.displayName = \"IBaseModalHeader\";\n\n// ModalBody component\nexport const IBaseModalBody: React.FC<IBaseModalBodyProps> = (props) => {\n  return <HeroUIModalBody {...props} />;\n};\n\nIBaseModalBody.displayName = \"IBaseModalBody\";\n\n// ModalFooter component\nexport const IBaseModalFooter: React.FC<IBaseModalFooterProps> = (props) => {\n  return <HeroUIModalFooter {...props} />;\n};\n\nIBaseModalFooter.displayName = \"IBaseModalFooter\";\n\n// Export all components\n\n// Also export with shorter names for convenience\n\n\n// Default export\nexport default IBaseModal;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseNavbar/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Navbar·as·HeroUINavbar,·NavbarBrand·as·HeroUINavbarBrand,·NavbarContent·as·HeroUINavbarContent,·NavbarItem·as·HeroUINavbarItem,·NavbarMenu·as·HeroUINavbarMenu,·NavbarMenuItem·as·HeroUINavbarMenuItem,·NavbarMenuToggle·as·HeroUINavbarMenuToggle,·NavbarProps·` with `⏎··Navbar·as·HeroUINavbar,⏎··NavbarBrand·as·HeroUINavbarBrand,⏎··NavbarContent·as·HeroUINavbarContent,⏎··NavbarItem·as·HeroUINavbarItem,⏎··NavbarMenu·as·HeroUINavbarMenu,⏎··NavbarMenuItem·as·HeroUINavbarMenuItem,⏎··NavbarMenuToggle·as·HeroUINavbarMenuToggle,⏎··NavbarProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":266,"fix":{"range":[23,280],"text":"\n  Navbar as HeroUINavbar,\n  NavbarBrand as HeroUINavbarBrand,\n  NavbarContent as HeroUINavbarContent,\n  NavbarItem as HeroUINavbarItem,\n  NavbarMenu as HeroUINavbarMenu,\n  NavbarMenuItem as HeroUINavbarMenuItem,\n  NavbarMenuToggle as HeroUINavbarMenuToggle,\n  NavbarProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":17,"column":61,"nodeType":null,"messageId":"delete","endLine":18,"endColumn":1,"fix":{"range":[814,815],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Navbar as HeroUINavbar, NavbarBrand as HeroUINavbarBrand, NavbarContent as HeroUINavbarContent, NavbarItem as HeroUINavbarItem, NavbarMenu as HeroUINavbarMenu, NavbarMenuItem as HeroUINavbarMenuItem, NavbarMenuToggle as HeroUINavbarMenuToggle, NavbarProps } from \"@heroui/navbar\";\nimport React from \"react\";\n\nexport type IBaseNavbarProps = NavbarProps & {};\n\nexport const IBaseNavbar: React.FC<IBaseNavbarProps> = (props) => {\n  return <HeroUINavbar {...props} />;\n};\n\nexport const IBaseNavbarBrand = HeroUINavbarBrand;\nexport const IBaseNavbarContent = HeroUINavbarContent;\nexport const IBaseNavbarItem = HeroUINavbarItem;\nexport const IBaseNavbarMenu = HeroUINavbarMenu;\nexport const IBaseNavbarMenuItem = HeroUINavbarMenuItem;\nexport const IBaseNavbarMenuToggle = HeroUINavbarMenuToggle;\n\n\nexport default IBaseNavbar;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePagination/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Pagination·as·HeroUIPagination,·PaginationProps·` with `⏎··Pagination·as·HeroUIPagination,⏎··PaginationProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":58,"fix":{"range":[23,72],"text":"\n  Pagination as HeroUIPagination,\n  PaginationProps,\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Pagination as HeroUIPagination, PaginationProps } from \"@heroui/pagination\";\nimport React from \"react\";\n\nexport type IBasePaginationProps = PaginationProps & {};\n\nexport const IBasePagination: React.FC<IBasePaginationProps> = (props) => {\n  const { size = \"sm\", variant = \"flat\", ...rest } = props;\n\n  return <HeroUIPagination size={size} variant={variant} {...rest} />;\n};\n\nexport default IBasePagination;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/IBaseDatePicker.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components/IBaseInput` import should occur after import of `react`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":61,"fix":{"range":[157,619],"text":"import { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Calendar } from \"@heroui/calendar\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport IBaseInput from \"@base/client/components/IBaseInput\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":58,"fix":{"range":[275,275],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `react`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":58,"fix":{"range":[218,619],"text":"import { Calendar } from \"@heroui/calendar\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":116,"column":39,"nodeType":null,"messageId":"insert","endLine":116,"endColumn":39,"fix":{"range":[3063,3063],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":127,"column":32,"nodeType":null,"messageId":"insert","endLine":127,"endColumn":32,"fix":{"range":[3372,3372],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":131,"column":32,"nodeType":null,"messageId":"insert","endLine":131,"endColumn":32,"fix":{"range":[3502,3502],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":176,"column":34,"nodeType":null,"messageId":"insert","endLine":176,"endColumn":34,"fix":{"range":[4802,4802],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":262,"column":39,"nodeType":null,"messageId":"insert","endLine":262,"endColumn":39,"fix":{"range":[6450,6450],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":333,"column":22,"nodeType":null,"messageId":"insert","endLine":333,"endColumn":22,"fix":{"range":[7966,7966],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":382,"column":6,"nodeType":null,"messageId":"insert","endLine":382,"endColumn":6,"fix":{"range":[9111,9111],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":487,"column":61,"nodeType":null,"messageId":"insert","endLine":487,"endColumn":61,"fix":{"range":[12440,12440],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":11,"source":"\"use client\";\n\nimport type { InputProps } from \"@heroui/input\";\nimport type { DateValue } from \"@react-types/calendar\";\nimport type { Dayjs } from \"dayjs\";\n\nimport IBaseInput from \"@base/client/components/IBaseInput\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Calendar } from \"@heroui/calendar\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport {\n  calendarDateToDayjs,\n  dayjsToCalendarDate,\n  formatDayjs,\n  nowInTz,\n  toDayjs,\n} from \"../../utils/date/parseDateInput\";\n\nimport ButtonFastChoose from \"./components/ButtonFastChoose\";\n\nexport type IBaseDatePickerValue = string | Dayjs | null;\n\ntype CalendarPassThroughProps = Omit<\n  React.ComponentProps<typeof Calendar>,\n  | \"value\"\n  | \"minValue\"\n  | \"maxValue\"\n  | \"onChange\"\n  | \"bottomContent\"\n  | \"showHelper\"\n>;\n\nexport type IBaseDatePickerQuickSelect =\n  | false\n  | {\n      label: React.ReactNode;\n      getValue: (now: Dayjs) => Dayjs;\n    };\n\nexport interface IBaseDatePickerProps extends Omit<\n  InputProps,\n  \"value\" | \"defaultValue\" | \"onChange\" | \"onValueChange\" | \"type\"\n> {\n  value?: IBaseDatePickerValue;\n  defaultValue?: IBaseDatePickerValue;\n  onChange?: (value: string | null) => void;\n  /**\n   * Allow clearing the current value via a clear icon.\n   * - true: show clear icon (when input has value) and allow setting value to null\n   * - false: hide clear icon and prevent clearing; empty input reverts to previous value\n   * @default true\n   */\n  allowClear?: boolean;\n  format?: string;\n  minDate?: string | Dayjs;\n  maxDate?: string | Dayjs;\n  timezone?: string;\n  showToday?: boolean;\n  quickSelect?: IBaseDatePickerQuickSelect;\n  calendarProps?: CalendarPassThroughProps;\n  dropdownRenderer?: (params: {\n    content: React.ReactNode;\n    close: () => void;\n    isOpen: boolean;\n  }) => React.ReactNode;\n}\n\nconst DEFAULT_FORMAT = \"DD/MM/YYYY\";\n\nexport function IBaseDatePicker(props: IBaseDatePickerProps) {\n  const t = useTranslations(\"components.picker\");\n  const {\n    value,\n    defaultValue,\n    onChange,\n    format = DEFAULT_FORMAT,\n    allowClear = true,\n    minDate,\n    maxDate,\n    timezone = SYSTEM_TIMEZONE,\n    showToday = true,\n    quickSelect,\n    calendarProps,\n    dropdownRenderer,\n    isDisabled,\n    endContent,\n    className,\n    onKeyDown,\n    onClick,\n    ...rest\n  } = props;\n\n  const hasTime = useMemo(() => /H|m|s/.test(format), [format]);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const [isOpen, setIsOpen] = useState(false);\n  const [uncontrolledValue, setUncontrolledValue] =\n    useState<IBaseDatePickerValue>(defaultValue ?? null);\n\n  const committedValue: IBaseDatePickerValue =\n    value !== undefined ? value : uncontrolledValue;\n\n  const committedDayjs = useMemo(\n    () => toDayjs(committedValue, format, timezone),\n    [committedValue, format, timezone]\n  );\n\n  const committedText = useMemo(() => {\n    if (!committedDayjs) return \"\";\n\n    return formatDayjs(committedDayjs, format, timezone);\n  }, [committedDayjs, format, timezone]);\n\n  const minDayjs = useMemo(\n    () => (minDate ? toDayjs(minDate, format, timezone) : null),\n    [minDate, format, timezone]\n  );\n  const maxDayjs = useMemo(\n    () => (maxDate ? toDayjs(maxDate, format, timezone) : null),\n    [maxDate, format, timezone]\n  );\n\n  const minValue = useMemo(() => {\n    if (!minDayjs) return undefined;\n\n    return dayjsToCalendarDate(minDayjs, timezone);\n  }, [minDayjs, timezone]);\n  const maxValue = useMemo(() => {\n    if (!maxDayjs) return undefined;\n\n    return dayjsToCalendarDate(maxDayjs, timezone);\n  }, [maxDayjs, timezone]);\n\n  // Draft state while popover is open / typing\n  const [draftText, setDraftText] = useState(committedText);\n  const [draftDayjs, setDraftDayjs] = useState<Dayjs | null>(committedDayjs);\n  const [isDraftInvalid, setIsDraftInvalid] = useState(false);\n\n  // Keep input text in sync with committed value when not open.\n  useEffect(() => {\n    if (isOpen) return;\n    setDraftText(committedText);\n    setDraftDayjs(committedDayjs);\n    setIsDraftInvalid(false);\n  }, [committedText, committedDayjs, isOpen]);\n\n  const validateAgainstMinMax = useCallback(\n    (d: Dayjs) => {\n      const candidate = hasTime ? d : d.startOf(\"day\");\n\n      if (minDayjs) {\n        const minC = hasTime ? minDayjs : minDayjs.startOf(\"day\");\n\n        if (candidate.isBefore(minC)) return false;\n      }\n\n      if (maxDayjs) {\n        const maxC = hasTime ? maxDayjs : maxDayjs.endOf(\"day\");\n\n        if (candidate.isAfter(maxC)) return false;\n      }\n\n      return true;\n    },\n    [hasTime, maxDayjs, minDayjs]\n  );\n\n  const commit = useCallback(() => {\n    const text = draftText.trim();\n\n    if (!text) {\n      if (!allowClear) {\n        // Prevent clearing: revert to last committed value\n        setDraftText(committedText);\n        setDraftDayjs(committedDayjs);\n        setIsDraftInvalid(false);\n\n        return true;\n      }\n      setIsDraftInvalid(false);\n\n      if (value === undefined) setUncontrolledValue(null);\n      onChange?.(null);\n\n      return true;\n    }\n\n    const parsed = toDayjs(text, format, timezone);\n\n    if (!parsed) {\n      setIsDraftInvalid(true);\n\n      return false;\n    }\n\n    if (!validateAgainstMinMax(parsed)) {\n      setIsDraftInvalid(true);\n\n      return false;\n    }\n\n    const out = formatDayjs(parsed, format, timezone);\n\n    setIsDraftInvalid(false);\n\n    if (value === undefined) setUncontrolledValue(out);\n    onChange?.(out);\n\n    return true;\n  }, [\n    allowClear,\n    committedDayjs,\n    committedText,\n    draftText,\n    format,\n    onChange,\n    timezone,\n    validateAgainstMinMax,\n    value,\n  ]);\n\n  const close = useCallback(() => {\n    setIsOpen(false);\n  }, []);\n\n  const commitAndClose = useCallback(() => {\n    commit();\n    close();\n  }, [close, commit]);\n\n  const open = useCallback(() => {\n    if (isDisabled) return;\n\n    setIsOpen(true);\n    // focus input for immediate typing\n    requestAnimationFrame(() => inputRef.current?.focus());\n  }, [isDisabled]);\n\n  const handleOpenChange = useCallback(\n    (openState: boolean) => {\n      if (isDisabled) return;\n\n      if (!openState) {\n        commitAndClose();\n\n        return;\n      }\n\n      open();\n    },\n    [commitAndClose, isDisabled, open]\n  );\n\n  const handleInputClick: React.MouseEventHandler<HTMLInputElement> = (e) => {\n    onClick?.(e);\n    if (isDisabled) return;\n\n    // Open popover on click if not already open\n    if (!isOpen) {\n      open();\n    }\n  };\n\n  const handleKeyDown: React.KeyboardEventHandler<HTMLInputElement> = (e) => {\n    onKeyDown?.(e);\n    if (e.defaultPrevented) return;\n    if (isDisabled) return;\n\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      if (!isOpen) {\n        open();\n      } else {\n        commitAndClose();\n      }\n    }\n  };\n\n  const handleTextChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {\n    const next = e.target.value;\n\n    setDraftText(next);\n\n    const parsed = toDayjs(next, format, timezone);\n\n    if (!next.trim()) {\n      if (!allowClear) {\n        // Prevent clearing: revert to last committed value\n        setDraftText(committedText);\n        setDraftDayjs(committedDayjs);\n        setIsDraftInvalid(false);\n\n        return;\n      }\n      setDraftDayjs(null);\n      setIsDraftInvalid(false);\n\n      return;\n    }\n\n    if (!parsed) {\n      setDraftDayjs(null);\n      setIsDraftInvalid(true);\n\n      return;\n    }\n\n    if (!validateAgainstMinMax(parsed)) {\n      setDraftDayjs(parsed);\n      setIsDraftInvalid(true);\n\n      return;\n    }\n\n    setDraftDayjs(parsed);\n    setIsDraftInvalid(false);\n  };\n\n  const today = useMemo(() => nowInTz(timezone), [timezone]);\n  const todayCalendarValue = useMemo(\n    () => dayjsToCalendarDate(today, timezone),\n    [today, timezone]\n  );\n\n  const handleCalendarChange = useCallback(\n    (val: DateValue | null) => {\n      if (!val) {\n        if (!allowClear) {\n          // Prevent clearing: revert to last committed value\n          setDraftText(committedText);\n          setDraftDayjs(committedDayjs);\n          setIsDraftInvalid(false);\n          close();\n\n          return;\n        }\n        setDraftDayjs(null);\n        setDraftText(\"\");\n        setIsDraftInvalid(false);\n        setFocusedValue(todayCalendarValue);\n\n        if (value === undefined) setUncontrolledValue(null);\n        onChange?.(null);\n        close();\n\n        return;\n      }\n      const d = calendarDateToDayjs(val, timezone);\n      const out = formatDayjs(d, format, timezone);\n\n      setDraftDayjs(d);\n      setDraftText(out);\n      setIsDraftInvalid(false);\n      setFocusedValue(val);\n\n      // Apply immediately then close\n      if (value === undefined) setUncontrolledValue(out);\n      onChange?.(out);\n      close();\n    },\n    [\n      allowClear,\n      close,\n      committedDayjs,\n      committedText,\n      format,\n      onChange,\n      timezone,\n      todayCalendarValue,\n      value,\n    ]\n  );\n\n  const selectedValue = useMemo(() => {\n    if (!draftDayjs) return null;\n\n    return dayjsToCalendarDate(draftDayjs, timezone);\n  }, [draftDayjs, timezone]);\n\n  // Control the calendar focus so we can programmatically \"jump\" the view\n  // (e.g. when clicking ButtonFastChoose).\n  const [focusedValue, setFocusedValue] = useState<DateValue | null>(null);\n\n  useEffect(() => {\n    if (!isOpen) return;\n    setFocusedValue(selectedValue ?? todayCalendarValue);\n  }, [isOpen, selectedValue, todayCalendarValue]);\n\n  const resolvedQuickSelect: Exclude<IBaseDatePickerQuickSelect, false> | null =\n    useMemo(() => {\n      if (quickSelect === false) return null;\n      if (quickSelect) return quickSelect;\n      if (!showToday) return null;\n\n      return {\n        label: t(\"date.quickToday\"),\n        getValue: (now) => (hasTime ? now : now.startOf(\"day\")),\n      };\n    }, [hasTime, quickSelect, showToday, t]);\n\n  const content = (\n    <div className=\"flex flex-col gap-2 \">\n      <Calendar\n        {...calendarProps}\n        bottomContent={\n          resolvedQuickSelect ? (\n            <ButtonFastChoose\n              label={resolvedQuickSelect.label}\n              onPress={() => {\n                const d = resolvedQuickSelect.getValue(today);\n                const out = formatDayjs(d, format, timezone);\n                const nextFocus = dayjsToCalendarDate(d, timezone);\n\n                setDraftDayjs(d);\n                setDraftText(out);\n                setIsDraftInvalid(false);\n                setFocusedValue(nextFocus);\n                // If consumer provided controlled focus handling, notify them too.\n                calendarProps?.onFocusChange?.(nextFocus as any);\n\n                // Apply immediately then close\n                if (value === undefined) setUncontrolledValue(out);\n                onChange?.(out);\n                close();\n              }}\n            />\n          ) : null\n        }\n        focusedValue={calendarProps?.focusedValue ?? focusedValue}\n        maxValue={maxValue}\n        minValue={minValue}\n        showHelper={false}\n        value={selectedValue}\n        onChange={(val) => {\n          handleCalendarChange(val);\n          if (val) setFocusedValue(val);\n        }}\n        onFocusChange={(date) => {\n          setFocusedValue(date);\n          calendarProps?.onFocusChange?.(date);\n        }}\n      />\n    </div>\n  );\n\n  const renderedContent = dropdownRenderer\n    ? dropdownRenderer({ content, close: commitAndClose, isOpen })\n    : content;\n\n  const showClearIcon = allowClear && Boolean(draftText.trim());\n  const resolvedPlaceholder = useMemo(() => {\n    if (rest.placeholder) return rest.placeholder;\n\n    return hasTime\n      ? t(\"date.placeholderDateTime\", { format })\n      : t(\"date.placeholder\", { format });\n  }, [format, hasTime, rest.placeholder, t]);\n\n  const handleClear = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (isDisabled) return;\n\n      setDraftText(\"\");\n      setDraftDayjs(null);\n      setIsDraftInvalid(false);\n      setFocusedValue(todayCalendarValue);\n\n      if (value === undefined) setUncontrolledValue(null);\n      onChange?.(null);\n      close();\n\n      requestAnimationFrame(() => inputRef.current?.focus());\n    },\n    [close, isDisabled, onChange, todayCalendarValue, value]\n  );\n\n  return (\n    <Popover\n      classNames={{\n        // Prevent HeroUI Popover trigger from shrinking/fading when open\n        trigger: \"aria-expanded:!scale-100 aria-expanded:!opacity-100\",\n      }}\n      isOpen={isOpen}\n      placement=\"bottom\"\n      onOpenChange={handleOpenChange}\n    >\n      <PopoverTrigger>\n        <div className={clsx(\"w-full\", className)}>\n          <IBaseInput\n            {...rest}\n            ref={inputRef}\n            endContent={\n              <div className=\"flex items-center gap-1 cursor-pointer\">\n                {showClearIcon ? (\n                  <button\n                    aria-label={t(\"date.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onClick={handleClear}\n                    onMouseDown={(e) => {\n                      // keep input focused\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}\n                  >\n                    <X className=\"size-4\" />\n                  </button>\n                ) : null}\n                {endContent ?? (\n                  <CalendarIcon\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                )}\n              </div>\n            }\n            isDisabled={isDisabled}\n            isInvalid={rest.isInvalid || isDraftInvalid}\n            placeholder={resolvedPlaceholder}\n            value={draftText}\n            onChange={handleTextChange}\n            onClick={handleInputClick}\n            onKeyDown={handleKeyDown}\n          />\n        </div>\n      </PopoverTrigger>\n      <PopoverContent className=\"p-0\">{renderedContent}</PopoverContent>\n    </Popover>\n  );\n}\nexport default IBaseDatePicker;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/IBaseDateRangePicker.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components/IBaseInput` import should occur after import of `react`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":61,"fix":{"range":[163,666],"text":"import { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Button } from \"@heroui/button\";\nimport { RangeCalendar } from \"@heroui/calendar\";\nimport { InputProps } from \"@heroui/input\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport IBaseInput from \"@base/client/components/IBaseInput\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":58,"fix":{"range":[281,281],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `react`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":58,"fix":{"range":[224,666],"text":"import { Button } from \"@heroui/button\";\nimport { RangeCalendar } from \"@heroui/calendar\";\nimport { InputProps } from \"@heroui/input\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":48,"column":63,"nodeType":null,"messageId":"insert","endLine":48,"endColumn":63,"fix":{"range":[1376,1376],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":89,"column":4,"nodeType":null,"messageId":"insert","endLine":89,"endColumn":4,"fix":{"range":[2479,2479],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":241,"column":74,"nodeType":null,"messageId":"insert","endLine":241,"endColumn":74,"fix":{"range":[6254,6254],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":244,"column":70,"nodeType":null,"messageId":"insert","endLine":244,"endColumn":70,"fix":{"range":[6352,6352],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"\"use client\";\n\nimport type { DateValue } from \"@react-types/calendar\";\nimport type { RangeValue } from \"@react-types/shared\";\nimport type { Dayjs } from \"dayjs\";\n\nimport IBaseInput from \"@base/client/components/IBaseInput\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Button } from \"@heroui/button\";\nimport { RangeCalendar } from \"@heroui/calendar\";\nimport { InputProps } from \"@heroui/input\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport { Calendar as CalendarIcon, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport {\n  calendarDateToDayjs,\n  dayjsToCalendarDate,\n  formatDayjs,\n  nowInTz,\n  toDayjs,\n} from \"../../utils/date/parseDateInput\";\n\nexport type IBaseDateRangePickerValue = {\n  start: string | Dayjs | null;\n  end: string | Dayjs | null;\n} | null;\n\nexport interface RangePreset {\n  key: string;\n  label: React.ReactNode;\n  range: (now: Dayjs) => { start: Dayjs; end: Dayjs };\n}\n\nexport interface IBaseDateRangePickerProps extends Omit<\n  InputProps,\n  | \"value\"\n  | \"defaultValue\"\n  | \"onChange\"\n  | \"onValueChange\"\n  | \"type\"\n  | \"startContent\"\n> {\n  value?: IBaseDateRangePickerValue;\n  defaultValue?: IBaseDateRangePickerValue;\n  onChange?: (\n    value: { start: string | null; end: string | null } | null\n  ) => void;\n  startPlaceholder?: string;\n  endPlaceholder?: string;\n  /**\n   * Allow clearing the current value via clear icons.\n   * - true: allow clearing both start/end\n   * - false: prevent clearing both start/end (empty input reverts)\n   * - [start, end]: allow clearing start/end individually\n   * @default true\n   */\n  allowClear?: boolean | [boolean, boolean];\n  format?: string;\n  minDate?: string | Dayjs;\n  maxDate?: string | Dayjs;\n  timezone?: string;\n  presets?: RangePreset[];\n  dropdownRenderer?: (params: {\n    content: React.ReactNode;\n    close: () => void;\n    isOpen: boolean;\n  }) => React.ReactNode;\n}\n\nconst DEFAULT_FORMAT = \"DD/MM/YYYY\";\n\nfunction defaultPresets(\n  tz: string,\n  labels: {\n    today: React.ReactNode;\n    thisWeek: React.ReactNode;\n    lastWeek: React.ReactNode;\n    thisMonth: React.ReactNode;\n    lastMonth: React.ReactNode;\n    last3Months: React.ReactNode;\n    last6Months: React.ReactNode;\n    thisYear: React.ReactNode;\n    lastYear: React.ReactNode;\n    last2Years: React.ReactNode;\n    last3Years: React.ReactNode;\n    last5Years: React.ReactNode;\n  }\n): RangePreset[] {\n  const presets: RangePreset[] = [\n    {\n      key: \"today\",\n      label: labels.today,\n      range: (now) => ({ start: now.startOf(\"day\"), end: now.endOf(\"day\") }),\n    },\n    {\n      key: \"this-week\",\n      label: labels.thisWeek,\n      range: (now) => ({ start: now.startOf(\"week\"), end: now.endOf(\"week\") }),\n    },\n    {\n      key: \"last-week\",\n      label: labels.lastWeek,\n      range: (now) => {\n        const start = now.subtract(1, \"week\").startOf(\"week\");\n\n        return { start, end: start.endOf(\"week\") };\n      },\n    },\n    {\n      key: \"this-month\",\n      label: labels.thisMonth,\n      range: (now) => ({\n        start: now.startOf(\"month\"),\n        end: now.endOf(\"month\"),\n      }),\n    },\n    {\n      key: \"last-month\",\n      label: labels.lastMonth,\n      range: (now) => {\n        const start = now.subtract(1, \"month\").startOf(\"month\");\n\n        return { start, end: start.endOf(\"month\") };\n      },\n    },\n    {\n      key: \"last-3-months\",\n      label: labels.last3Months,\n      range: (now) => ({\n        start: now.subtract(3, \"month\").startOf(\"month\"),\n        end: now.endOf(\"month\"),\n      }),\n    },\n    {\n      key: \"last-6-months\",\n      label: labels.last6Months,\n      range: (now) => ({\n        start: now.subtract(6, \"month\").startOf(\"month\"),\n        end: now.endOf(\"month\"),\n      }),\n    },\n    {\n      key: \"this-year\",\n      label: labels.thisYear,\n      range: (now) => ({ start: now.startOf(\"year\"), end: now.endOf(\"year\") }),\n    },\n    {\n      key: \"last-year\",\n      label: labels.lastYear,\n      range: (now) => {\n        const start = now.subtract(1, \"year\").startOf(\"year\");\n\n        return { start, end: start.endOf(\"year\") };\n      },\n    },\n    {\n      key: \"last-2-years\",\n      label: labels.last2Years,\n      range: (now) => ({\n        start: now.subtract(2, \"year\").startOf(\"year\"),\n        end: now.endOf(\"year\"),\n      }),\n    },\n    {\n      key: \"last-3-years\",\n      label: labels.last3Years,\n      range: (now) => ({\n        start: now.subtract(3, \"year\").startOf(\"year\"),\n        end: now.endOf(\"year\"),\n      }),\n    },\n    {\n      key: \"last-5-years\",\n      label: labels.last5Years,\n      range: (now) => ({\n        start: now.subtract(5, \"year\").startOf(\"year\"),\n        end: now.endOf(\"year\"),\n      }),\n    },\n  ];\n\n  return presets;\n}\n\nexport function IBaseDateRangePicker(props: IBaseDateRangePickerProps) {\n  const {\n    value,\n    defaultValue,\n    onChange,\n    format = DEFAULT_FORMAT,\n    startPlaceholder,\n    endPlaceholder,\n    timezone = SYSTEM_TIMEZONE,\n    minDate,\n    maxDate,\n    allowClear = true,\n    presets: customPresets,\n    dropdownRenderer,\n    label,\n    errorMessage,\n    isInvalid,\n    isDisabled,\n    endContent,\n    ...rest\n  } = props;\n\n  const t = useTranslations(\"components.dateRangePicker\");\n\n  const [isOpen, setIsOpen] = useState(false);\n  const startRef = useRef<HTMLInputElement>(null);\n  const endRef = useRef<HTMLInputElement>(null);\n\n  // --- Initial value logic ---\n  const initialValue = useMemo(() => {\n    const v = value !== undefined ? value : defaultValue;\n\n    if (!v) return { start: null, end: null };\n\n    return {\n      start: toDayjs(v.start, timezone),\n      end: toDayjs(v.end, timezone),\n    };\n  }, [value, defaultValue, timezone]);\n\n  const [selectedRange, setSelectedRange] = useState<{\n    start: Dayjs | null;\n    end: Dayjs | null;\n  }>(initialValue);\n\n  // Local text state for inputs\n  const [draftStartText, setDraftStartText] = useState(\"\");\n  const [draftEndText, setDraftEndText] = useState(\"\");\n\n  const [isDraftInvalid, setIsDraftInvalid] = useState(false);\n\n  // Sync draft text with selectedRange\n  useEffect(() => {\n    setDraftStartText(\n      selectedRange.start ? formatDayjs(selectedRange.start, format) : \"\"\n    );\n    setDraftEndText(\n      selectedRange.end ? formatDayjs(selectedRange.end, format) : \"\"\n    );\n    setIsDraftInvalid(false);\n  }, [selectedRange, format]);\n\n  // Sync when controlled value changes\n  useEffect(() => {\n    if (value !== undefined) {\n      const v = value || { start: null, end: null };\n\n      setSelectedRange({\n        start: toDayjs(v.start, timezone),\n        end: toDayjs(v.end, timezone),\n      });\n    }\n  }, [value, timezone]);\n\n  const resolvedStartPlaceholder = startPlaceholder || t(\"range.startLabel\");\n  const resolvedEndPlaceholder = endPlaceholder || t(\"range.endLabel\");\n\n  const presets = useMemo(() => {\n    if (customPresets) return customPresets;\n\n    return defaultPresets(timezone, {\n      today: t(\"presets.today\"),\n      thisWeek: t(\"presets.thisWeek\"),\n      lastWeek: t(\"presets.lastWeek\"),\n      thisMonth: t(\"presets.thisMonth\"),\n      lastMonth: t(\"presets.lastMonth\"),\n      last3Months: t(\"presets.last3Months\"),\n      last6Months: t(\"presets.last6Months\"),\n      thisYear: t(\"presets.thisYear\"),\n      lastYear: t(\"presets.lastYear\"),\n      last2Years: t(\"presets.last2Years\"),\n      last3Years: t(\"presets.last3Years\"),\n      last5Years: t(\"presets.last5Years\"),\n    });\n  }, [customPresets, timezone, t]);\n\n  const minCalendarDate = useMemo(() => {\n    const d = toDayjs(minDate, timezone);\n\n    return d ? dayjsToCalendarDate(d) : undefined;\n  }, [minDate, timezone]);\n  const maxCalendarDate = useMemo(() => {\n    const d = toDayjs(maxDate, timezone);\n\n    return d ? dayjsToCalendarDate(d) : undefined;\n  }, [maxDate, timezone]);\n\n  const heroRangeValue: RangeValue<DateValue> | null = useMemo(() => {\n    if (selectedRange.start && selectedRange.end) {\n      return {\n        start: dayjsToCalendarDate(selectedRange.start),\n        end: dayjsToCalendarDate(selectedRange.end),\n      };\n    }\n\n    return null;\n  }, [selectedRange]);\n\n  const handleRangeChange = (range: RangeValue<DateValue> | null) => {\n    if (!range) {\n      const newVal = { start: null, end: null };\n\n      setSelectedRange(newVal);\n      onChange?.(newVal);\n    } else {\n      const start = calendarDateToDayjs(range.start, timezone).startOf(\"day\");\n      const end = calendarDateToDayjs(range.end, timezone).endOf(\"day\");\n      const newVal = { start, end };\n\n      setSelectedRange(newVal);\n      onChange?.({\n        start: start.toISOString(),\n        end: end.toISOString(),\n      });\n    }\n  };\n\n  const handlePresetClick = (preset: RangePreset) => {\n    const now = nowInTz(timezone);\n    const { start, end } = preset.range(now);\n    const newVal = { start, end };\n\n    setSelectedRange(newVal);\n    onChange?.({\n      start: start.toISOString(),\n      end: end.toISOString(),\n    });\n    setIsOpen(false);\n  };\n\n  const handleStartChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value;\n\n    setDraftStartText(val);\n    const d = toDayjs(val, timezone, format);\n\n    if (d && d.isValid()) {\n      const newStart = d.startOf(\"day\");\n\n      setSelectedRange((prev) => {\n        const newVal = { ...prev, start: newStart };\n\n        if (newVal.start && newVal.end && newVal.start.isAfter(newVal.end)) {\n          newVal.end = newVal.start.endOf(\"day\");\n        }\n        onChange?.({\n          start: newVal.start?.toISOString() || null,\n          end: newVal.end?.toISOString() || null,\n        });\n\n        return newVal;\n      });\n      setIsDraftInvalid(false);\n    } else {\n      setIsDraftInvalid(val.length > 0);\n    }\n  };\n\n  const handleEndChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const val = e.target.value;\n\n    setDraftEndText(val);\n    const d = toDayjs(val, timezone, format);\n\n    if (d && d.isValid()) {\n      const newEnd = d.endOf(\"day\");\n\n      setSelectedRange((prev) => {\n        const newVal = { ...prev, end: newEnd };\n\n        if (newVal.start && newVal.end && newVal.end.isBefore(newVal.start)) {\n          newVal.start = newVal.end.startOf(\"day\");\n        }\n        onChange?.({\n          start: newVal.start?.toISOString() || null,\n          end: newVal.end?.toISOString() || null,\n        });\n\n        return newVal;\n      });\n      setIsDraftInvalid(false);\n    } else {\n      setIsDraftInvalid(val.length > 0);\n    }\n  };\n\n  const handleClearStart = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const newVal = { ...selectedRange, start: null };\n\n    setSelectedRange(newVal);\n    onChange?.({\n      start: null,\n      end: newVal.end?.toISOString() || null,\n    });\n  };\n\n  const handleClearEnd = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const newVal = { ...selectedRange, end: null };\n\n    setSelectedRange(newVal);\n    onChange?.({\n      start: newVal.start?.toISOString() || null,\n      end: null,\n    });\n  };\n\n  const handleInputClick = () => {\n    if (!isDisabled) setIsOpen(true);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" || e.key === \" \") {\n      setIsOpen(true);\n    }\n  };\n\n  const allowClearStart = Array.isArray(allowClear)\n    ? allowClear[0]\n    : allowClear;\n  const allowClearEnd = Array.isArray(allowClear) ? allowClear[1] : allowClear;\n\n  const renderedContent = (\n    <div className=\"flex flex-col sm:flex-row bg-content1 shadow-medium rounded-medium overflow-hidden\">\n      {/* Presets Sidebar */}\n      {presets.length > 0 && (\n        <div className=\"flex flex-col gap-1 p-2 border-r border-divider min-w-[160px] bg-default-50\">\n          <p className=\"px-2 py-1 text-tiny font-bold text-default-400 uppercase tracking-wider\">\n            {t(\"presets.title\")}\n          </p>\n          {presets.map((p) => (\n            <Button\n              key={p.key}\n              fullWidth\n              className=\"justify-start h-8 text-small font-normal hover:bg-default-100\"\n              size=\"sm\"\n              variant=\"light\"\n              onPress={() => handlePresetClick(p)}\n            >\n              {p.label}\n            </Button>\n          ))}\n        </div>\n      )}\n\n      {/* Calendar Area */}\n      <div className=\"p-3\">\n        <RangeCalendar\n          aria-label={t(\"range.calendarAriaLabel\")}\n          maxValue={maxCalendarDate}\n          minValue={minCalendarDate}\n          value={heroRangeValue}\n          onChange={handleRangeChange}\n        />\n        <div className=\"mt-4 flex items-center justify-between gap-2 border-t border-divider pt-3\">\n          <div className=\"flex flex-col\">\n            <span className=\"text-tiny text-default-400\">\n              {t(\"range.selectedLabel\")}\n            </span>\n            <span className=\"text-small font-medium\">\n              {selectedRange.start\n                ? formatDayjs(selectedRange.start, format)\n                : \"---\"}{\" \"}\n              -{\" \"}\n              {selectedRange.end\n                ? formatDayjs(selectedRange.end, format)\n                : \"---\"}\n            </span>\n          </div>\n          <div className=\"flex gap-2\">\n            <Button\n              size=\"sm\"\n              variant=\"flat\"\n              onPress={() => {\n                const newVal = { start: null, end: null };\n\n                setSelectedRange(newVal);\n                onChange?.(newVal);\n                setIsOpen(false);\n              }}\n            >\n              {t(\"actions.clear\")}\n            </Button>\n            <Button color=\"primary\" size=\"sm\" onPress={() => setIsOpen(false)}>\n              {t(\"actions.close\")}\n            </Button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <Popover isOpen={isOpen} placement=\"bottom-start\" onOpenChange={setIsOpen}>\n      <PopoverTrigger>\n        <div className=\"flex flex-col gap-1.5 w-full\">\n          {label && (\n            <label className=\"text-small font-medium text-default-600\">\n              {label}\n            </label>\n          )}\n          <div className=\"flex items-center gap-2\">\n            <IBaseInput\n              {...rest}\n              ref={startRef}\n              endContent={\n                <div className=\"flex items-center gap-1 cursor-pointer\">\n                  {allowClearStart && draftStartText.trim() ? (\n                    <button\n                      aria-label={t(\"range.clearStartAriaLabel\")}\n                      className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                      type=\"button\"\n                      onClick={handleClearStart}\n                      onMouseDown={(e) => {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }}\n                    >\n                      <X className=\"size-4\" />\n                    </button>\n                  ) : null}\n                  <CalendarIcon\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                </div>\n              }\n              errorMessage={errorMessage}\n              isDisabled={isDisabled}\n              isInvalid={isInvalid || isDraftInvalid}\n              placeholder={resolvedStartPlaceholder}\n              value={draftStartText}\n              onChange={handleStartChange}\n              onClick={handleInputClick}\n              onKeyDown={handleKeyDown}\n            />\n            <div className=\"text-default-400\">\n              <span className=\"px-1\">—</span>\n            </div>\n            <IBaseInput\n              {...rest}\n              ref={endRef}\n              endContent={\n                <div className=\"flex items-center gap-1 cursor-pointer\">\n                  {allowClearEnd && draftEndText.trim() ? (\n                    <button\n                      aria-label={t(\"range.clearEndAriaLabel\")}\n                      className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                      type=\"button\"\n                      onClick={handleClearEnd}\n                      onMouseDown={(e) => {\n                        e.preventDefault();\n                        e.stopPropagation();\n                      }}\n                    >\n                      <X className=\"size-4\" />\n                    </button>\n                  ) : null}\n                  {endContent ?? (\n                    <CalendarIcon\n                      aria-hidden=\"true\"\n                      className=\"text-default-400\"\n                      size={16}\n                    />\n                  )}\n                </div>\n              }\n              isDisabled={isDisabled}\n              isInvalid={isInvalid || isDraftInvalid}\n              placeholder={resolvedEndPlaceholder}\n              value={draftEndText}\n              onChange={handleEndChange}\n              onClick={handleInputClick}\n              onKeyDown={handleKeyDown}\n            />\n          </div>\n        </div>\n      </PopoverTrigger>\n      <PopoverContent className=\"p-0\">\n        {dropdownRenderer\n          ? dropdownRenderer({\n              content: renderedContent,\n              close: () => setIsOpen(false),\n              isOpen,\n            })\n          : renderedContent}\n      </PopoverContent>\n    </Popover>\n  );\n}\nexport default IBaseDateRangePicker;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/IBaseMonthPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/IBaseTimePicker.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components/IBaseInput` import should occur after import of `react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":61,"fix":{"range":[101,540],"text":"import { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Button } from \"@heroui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Clock, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport IBaseInput from \"@base/client/components/IBaseInput\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":58,"fix":{"range":[219,219],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `react`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":58,"fix":{"range":[162,540],"text":"import { Button } from \"@heroui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Clock, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":81,"fix":{"range":[621,621],"text":"\n"}},{"ruleId":"padding-line-between-statements","severity":1,"message":"Expected blank line before this statement.","line":114,"column":9,"nodeType":"ReturnStatement","messageId":"expectedBlankLine","endLine":114,"endColumn":21,"fix":{"range":[3217,3217],"text":"\n"}},{"ruleId":"padding-line-between-statements","severity":1,"message":"Expected blank line before this statement.","line":190,"column":5,"nodeType":"ReturnStatement","messageId":"expectedBlankLine","endLine":190,"endColumn":46,"fix":{"range":[5069,5069],"text":"\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":206,"column":34,"nodeType":null,"messageId":"insert","endLine":206,"endColumn":34,"fix":{"range":[5569,5569],"text":","}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":213,"column":7,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":213,"endColumn":17,"fix":{"range":[5606,5859],"text":"classNames={{\n        // Prevent HeroUI Popover trigger from shrinking/fading when open\n        trigger: \"aria-expanded:!scale-100 aria-expanded:!opacity-100\",\n      }}\n      isOpen={isOpen}\n      placement=\"bottom\"\n      onOpenChange={handleOpenChange}"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":225,"column":13,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":225,"endColumn":23,"fix":{"range":[5997,7733],"text":"ref={inputRef}\n            endContent={\n              <div className=\"flex items-center gap-1 cursor-pointer\">\n                {showClearIcon ? (\n                  <button\n                    aria-label={t(\"time.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onMouseDown={(e) => {\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}\n                    onClick={handleClear}\n                  >\n                    <X className=\"size-4\" />\n                  </button>\n                ) : null}\n                {endContent ?? (\n                  <Clock\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                )}\n              </div>\n            }\n            isDisabled={isDisabled}\n            isInvalid={rest.isInvalid || isDraftInvalid}\n            placeholder={resolvedPlaceholder}\n            value={draftText}\n            onChange={(e) => {\n              const next = e.target.value;\n\n              if (!allowClear && !next.trim()) {\n                // Prevent clearing: revert to last committed value\n                setDraftText(committedText);\n                setIsDraftInvalid(false);\n                return;\n              }\n              setDraftText(next);\n              if (!next.trim()) {\n                setIsDraftInvalid(false);\n\n                return;\n              }\n              setIsDraftInvalid(!toDayjs(next, format, timezone));\n            }}\n            onClick={handleClick}\n            onKeyDown={handleKey}"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":236,"column":21,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":236,"endColumn":28,"fix":{"range":[6235,6620],"text":"aria-label={t(\"time.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onClick={handleClear}\n                    onMouseDown={(e) => {\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":250,"column":13,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":250,"endColumn":23,"fix":{"range":[5997,7733],"text":"ref={inputRef}\n            endContent={\n              <div className=\"flex items-center gap-1 cursor-pointer\">\n                {showClearIcon ? (\n                  <button\n                    aria-label={t(\"time.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onMouseDown={(e) => {\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}\n                    onClick={handleClear}\n                  >\n                    <X className=\"size-4\" />\n                  </button>\n                ) : null}\n                {endContent ?? (\n                  <Clock\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                )}\n              </div>\n            }\n            isDisabled={isDisabled}\n            isInvalid={rest.isInvalid || isDraftInvalid}\n            placeholder={resolvedPlaceholder}\n            value={draftText}\n            onChange={(e) => {\n              const next = e.target.value;\n\n              if (!allowClear && !next.trim()) {\n                // Prevent clearing: revert to last committed value\n                setDraftText(committedText);\n                setIsDraftInvalid(false);\n                return;\n              }\n              setDraftText(next);\n              if (!next.trim()) {\n                setIsDraftInvalid(false);\n\n                return;\n              }\n              setIsDraftInvalid(!toDayjs(next, format, timezone));\n            }}\n            onClick={handleClick}\n            onKeyDown={handleKey}"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":251,"column":13,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":251,"endColumn":22,"fix":{"range":[5997,7733],"text":"ref={inputRef}\n            endContent={\n              <div className=\"flex items-center gap-1 cursor-pointer\">\n                {showClearIcon ? (\n                  <button\n                    aria-label={t(\"time.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onMouseDown={(e) => {\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}\n                    onClick={handleClear}\n                  >\n                    <X className=\"size-4\" />\n                  </button>\n                ) : null}\n                {endContent ?? (\n                  <Clock\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                )}\n              </div>\n            }\n            isDisabled={isDisabled}\n            isInvalid={rest.isInvalid || isDraftInvalid}\n            placeholder={resolvedPlaceholder}\n            value={draftText}\n            onChange={(e) => {\n              const next = e.target.value;\n\n              if (!allowClear && !next.trim()) {\n                // Prevent clearing: revert to last committed value\n                setDraftText(committedText);\n                setIsDraftInvalid(false);\n                return;\n              }\n              setDraftText(next);\n              if (!next.trim()) {\n                setIsDraftInvalid(false);\n\n                return;\n              }\n              setIsDraftInvalid(!toDayjs(next, format, timezone));\n            }}\n            onClick={handleClick}\n            onKeyDown={handleKey}"}},{"ruleId":"padding-line-between-statements","severity":1,"message":"Expected blank line before this statement.","line":260,"column":17,"nodeType":"ReturnStatement","messageId":"expectedBlankLine","endLine":260,"endColumn":24,"fix":{"range":[7392,7392],"text":"\n"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":281,"column":15,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":281,"endColumn":20,"fix":{"range":[7938,8213],"text":"align=\"end\"\n              label={t(\"time.now\")}\n              wrapperClassName=\"pt-0\"\n              onPress={() => {\n                const out = formatDayjs(now, format, timezone);\n\n                setDraftText(out);\n                setIsDraftInvalid(false);\n              }}"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":14,"source":"\"use client\";\n\nimport type { InputProps } from \"@heroui/input\";\nimport type { Dayjs } from \"dayjs\";\n\nimport IBaseInput from \"@base/client/components/IBaseInput\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { Button } from \"@heroui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@heroui/popover\";\nimport clsx from \"clsx\";\nimport { Clock, X } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { formatDayjs, nowInTz, toDayjs } from \"../../utils/date/parseDateInput\";\nimport ButtonFastChoose from \"./components/ButtonFastChoose\";\n\nexport type IBaseTimePickerValue = string | Dayjs | null;\n\nexport interface IBaseTimePickerProps extends Omit<\n  InputProps,\n  \"value\" | \"defaultValue\" | \"onChange\" | \"onValueChange\" | \"type\"\n> {\n  value?: IBaseTimePickerValue;\n  defaultValue?: IBaseTimePickerValue;\n  onChange?: (value: string | null) => void;\n  /**\n   * Allow clearing the current value via a clear icon.\n   * - true: show clear icon (when input has value) and allow setting value to null\n   * - false: hide clear icon and prevent clearing; empty input reverts to previous value\n   * @default true\n   */\n  allowClear?: boolean;\n  format?: string; // default HH:mm\n  timezone?: string;\n  showNow?: boolean;\n  minuteStep?: number; // default 30\n}\n\nconst DEFAULT_FORMAT = \"HH:mm\";\n\nfunction buildTimes(step: number) {\n  const s = Math.max(1, Math.min(60, Math.floor(step)));\n  const items: string[] = [];\n\n  for (let h = 0; h < 24; h++) {\n    for (let m = 0; m < 60; m += s) {\n      items.push(`${String(h).padStart(2, \"0\")}:${String(m).padStart(2, \"0\")}`);\n    }\n  }\n\n  return items;\n}\n\nexport function IBaseTimePicker(props: IBaseTimePickerProps) {\n  const t = useTranslations(\"components.picker\");\n  const {\n    value,\n    defaultValue,\n    onChange,\n    allowClear = true,\n    format = DEFAULT_FORMAT,\n    timezone = SYSTEM_TIMEZONE,\n    showNow = true,\n    minuteStep = 30,\n    isDisabled,\n    endContent,\n    className,\n    onKeyDown,\n    onClick,\n    ...rest\n  } = props;\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [isOpen, setIsOpen] = useState(false);\n\n  const [uncontrolledValue, setUncontrolledValue] =\n    useState<IBaseTimePickerValue>(defaultValue ?? null);\n  const committedValue = value !== undefined ? value : uncontrolledValue;\n\n  const committedDayjs = useMemo(\n    () => toDayjs(committedValue, format, timezone),\n    [committedValue, format, timezone],\n  );\n\n  const committedText = useMemo(\n    () => (committedDayjs ? formatDayjs(committedDayjs, format, timezone) : \"\"),\n    [committedDayjs, format, timezone],\n  );\n\n  const [draftText, setDraftText] = useState(committedText);\n  const [isDraftInvalid, setIsDraftInvalid] = useState(false);\n\n  useEffect(() => {\n    if (isOpen) return;\n    setDraftText(committedText);\n    setIsDraftInvalid(false);\n  }, [committedText, isOpen]);\n\n  const commit = useCallback(() => {\n    const text = draftText.trim();\n\n    if (!text) {\n      if (!allowClear) {\n        // Prevent clearing: revert to last committed value\n        setDraftText(committedText);\n        setIsDraftInvalid(false);\n        return true;\n      }\n      setIsDraftInvalid(false);\n\n      if (value === undefined) setUncontrolledValue(null);\n      onChange?.(null);\n\n      return true;\n    }\n\n    const parsed = toDayjs(text, format, timezone);\n\n    if (!parsed) {\n      setIsDraftInvalid(true);\n\n      return false;\n    }\n\n    const out = formatDayjs(parsed, format, timezone);\n\n    setIsDraftInvalid(false);\n\n    if (value === undefined) setUncontrolledValue(out);\n    onChange?.(out);\n\n    return true;\n  }, [allowClear, committedText, draftText, format, onChange, timezone, value]);\n\n  const close = useCallback(() => setIsOpen(false), []);\n  const commitAndClose = useCallback(() => {\n    commit();\n    close();\n  }, [close, commit]);\n\n  const open = useCallback(() => {\n    if (isDisabled) return;\n\n    setIsOpen(true);\n    requestAnimationFrame(() => inputRef.current?.focus());\n  }, [isDisabled]);\n\n  const handleOpenChange = useCallback(\n    (openState: boolean) => {\n      if (isDisabled) return;\n      if (!openState) {\n        commitAndClose();\n\n        return;\n      }\n      open();\n    },\n    [commitAndClose, isDisabled, open],\n  );\n\n  const handleKey: React.KeyboardEventHandler<HTMLInputElement> = (e) => {\n    onKeyDown?.(e);\n    if (e.defaultPrevented) return;\n    if (isDisabled) return;\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      if (!isOpen) open();\n      else commitAndClose();\n    }\n  };\n\n  const handleClick: React.MouseEventHandler<HTMLInputElement> = (e) => {\n    onClick?.(e);\n    if (isDisabled) return;\n    if (!isOpen) open();\n  };\n\n  const times = useMemo(() => buildTimes(minuteStep), [minuteStep]);\n  const now = useMemo(() => nowInTz(timezone), [timezone]);\n  const showClearIcon = allowClear && Boolean(draftText.trim());\n  const resolvedPlaceholder = useMemo(() => {\n    if (rest.placeholder) return rest.placeholder;\n    return t(\"time.placeholder\", { format });\n  }, [format, rest.placeholder, t]);\n\n  const handleClear = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (isDisabled) return;\n\n      setDraftText(\"\");\n      setIsDraftInvalid(false);\n      if (value === undefined) setUncontrolledValue(null);\n      onChange?.(null);\n      setIsOpen(false);\n      requestAnimationFrame(() => inputRef.current?.focus());\n    },\n    [isDisabled, onChange, value]\n  );\n\n  return (\n    <Popover\n      isOpen={isOpen}\n      placement=\"bottom\"\n      classNames={{\n        // Prevent HeroUI Popover trigger from shrinking/fading when open\n        trigger: \"aria-expanded:!scale-100 aria-expanded:!opacity-100\",\n      }}\n      onOpenChange={handleOpenChange}\n    >\n      <PopoverTrigger>\n        <div className={clsx(\"w-full\", className)}>\n          <IBaseInput\n            {...rest}\n            ref={inputRef}\n            placeholder={resolvedPlaceholder}\n            endContent={\n              <div className=\"flex items-center gap-1 cursor-pointer\">\n                {showClearIcon ? (\n                  <button\n                    aria-label={t(\"time.clearAriaLabel\")}\n                    className=\"cursor-pointer rounded-small p-1 text-default-400 transition-colors hover:text-danger-500\"\n                    type=\"button\"\n                    onMouseDown={(e) => {\n                      e.preventDefault();\n                      e.stopPropagation();\n                    }}\n                    onClick={handleClear}\n                  >\n                    <X className=\"size-4\" />\n                  </button>\n                ) : null}\n                {endContent ?? (\n                  <Clock\n                    aria-hidden=\"true\"\n                    className=\"text-default-400\"\n                    size={16}\n                  />\n                )}\n              </div>\n            }\n            isDisabled={isDisabled}\n            isInvalid={rest.isInvalid || isDraftInvalid}\n            value={draftText}\n            onChange={(e) => {\n              const next = e.target.value;\n\n              if (!allowClear && !next.trim()) {\n                // Prevent clearing: revert to last committed value\n                setDraftText(committedText);\n                setIsDraftInvalid(false);\n                return;\n              }\n              setDraftText(next);\n              if (!next.trim()) {\n                setIsDraftInvalid(false);\n\n                return;\n              }\n              setIsDraftInvalid(!toDayjs(next, format, timezone));\n            }}\n            onClick={handleClick}\n            onKeyDown={handleKey}\n          />\n        </div>\n      </PopoverTrigger>\n      <PopoverContent className=\"p-2\">\n        <div className=\"flex flex-col gap-2\">\n          {showNow ? (\n            <ButtonFastChoose\n              align=\"end\"\n              wrapperClassName=\"pt-0\"\n              label={t(\"time.now\")}\n              onPress={() => {\n                const out = formatDayjs(now, format, timezone);\n\n                setDraftText(out);\n                setIsDraftInvalid(false);\n              }}\n            />\n          ) : null}\n          <div className=\"max-h-64 w-56 overflow-auto\">\n            <div className=\"grid grid-cols-2 gap-1\">\n              {times.map((t) => (\n                <Button\n                  key={t}\n                  className=\"justify-start\"\n                  size=\"sm\"\n                  variant=\"light\"\n                  onPress={() => {\n                    setDraftText(t);\n                    setIsDraftInvalid(false);\n                  }}\n                >\n                  {t}\n                </Button>\n              ))}\n            </div>\n          </div>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}\nexport default IBaseTimePicker;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/IBaseYearPicker.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":36,"fix":{"range":[50,50],"text":"\n"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":26,"column":7,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":26,"endColumn":20,"fix":{"range":[662,1033],"text":"calendarProps={{ showMonthAndYearPickers: true, ...rest.calendarProps }}\n      format={format}\n      placeholder={placeholder ?? t(\"year.placeholder\", { format })}\n      quickSelect={\n        showThisYear\n          ? ({\n              label: t(\"year.thisYear\"),\n              getValue: (now: Dayjs) => now.startOf(\"year\"),\n            } as const)\n          : false\n      }"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":27,"column":7,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":27,"endColumn":13,"fix":{"range":[662,1033],"text":"calendarProps={{ showMonthAndYearPickers: true, ...rest.calendarProps }}\n      format={format}\n      placeholder={placeholder ?? t(\"year.placeholder\", { format })}\n      quickSelect={\n        showThisYear\n          ? ({\n              label: t(\"year.thisYear\"),\n              getValue: (now: Dayjs) => now.startOf(\"year\"),\n            } as const)\n          : false\n      }"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport type { Dayjs } from \"dayjs\";\nimport { useTranslations } from \"next-intl\";\n\nimport IBaseDatePicker, {\n  type IBaseDatePickerProps,\n  type IBaseDatePickerValue,\n} from \"./IBaseDatePicker\";\n\nexport type IBaseYearPickerValue = IBaseDatePickerValue;\n\nexport type IBaseYearPickerProps = Omit<IBaseDatePickerProps, \"quickSelect\"> & {\n  format?: string; // default YYYY\n  showThisYear?: boolean;\n};\n\nexport function IBaseYearPicker(props: IBaseYearPickerProps) {\n  const t = useTranslations(\"components.picker\");\n  const { placeholder, format = \"YYYY\", showThisYear = true, ...rest } = props;\n\n  return (\n    <IBaseDatePicker\n      {...rest}\n      placeholder={placeholder ?? t(\"year.placeholder\", { format })}\n      calendarProps={{ showMonthAndYearPickers: true, ...rest.calendarProps }}\n      format={format}\n      quickSelect={\n        showThisYear\n          ? ({\n              label: t(\"year.thisYear\"),\n              getValue: (now: Dayjs) => now.startOf(\"year\"),\n            } as const)\n          : false\n      }\n    />\n  );\n}\nexport default IBaseYearPicker;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/components/ButtonFastChoose.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":51,"fix":{"range":[65,65],"text":"\n"}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":39,"column":9,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":39,"endColumn":14,"fix":{"range":[879,986],"text":"color=\"primary\"\n        size=\"sm\"\n        variant=\"flat\"\n        {...buttonProps}\n        onPress={onPress}"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { ButtonProps } from \"@heroui/button\";\nimport { Button } from \"@heroui/button\";\nimport clsx from \"clsx\";\nimport React from \"react\";\n\nexport type ButtonFastChooseProps = {\n  label: React.ReactNode;\n  onPress: () => void;\n  align?: \"start\" | \"center\" | \"end\";\n  wrapperClassName?: string;\n  buttonProps?: Omit<ButtonProps, \"children\" | \"onPress\">;\n};\n\nconst alignClass = (align: ButtonFastChooseProps[\"align\"]) => {\n  switch (align) {\n    case \"start\":\n      return \"justify-start\";\n    case \"end\":\n      return \"justify-end\";\n    case \"center\":\n    default:\n      return \"justify-center\";\n  }\n};\n\nexport default function ButtonFastChoose({\n  label,\n  onPress,\n  align = \"center\",\n  wrapperClassName,\n  buttonProps,\n}: ButtonFastChooseProps) {\n  return (\n    <div className={clsx(\"flex py-1\", alignClass(align), wrapperClassName)}>\n      <Button\n        size=\"sm\"\n        color=\"primary\"\n        variant=\"flat\"\n        {...buttonProps}\n        onPress={onPress}\n      >\n        {label}\n      </Button>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePicker/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":84,"column":1,"nodeType":null,"messageId":"delete","endLine":85,"endColumn":1,"fix":{"range":[2293,2294],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { ComponentType } from \"react\";\n\nimport IBaseDatePicker, {\n  type IBaseDatePickerProps,\n  type IBaseDatePickerValue,\n} from \"./IBaseDatePicker\";\nimport IBaseDateRangePicker, {\n  type IBaseDateRangePickerProps,\n  type IBaseDateRangePickerValue,\n  type RangePreset,\n} from \"./IBaseDateRangePicker\";\nimport IBaseMonthPicker, {\n  type IBaseMonthPickerProps,\n  type IBaseMonthPickerValue,\n} from \"./IBaseMonthPicker\";\nimport IBaseTimePicker, {\n  type IBaseTimePickerProps,\n  type IBaseTimePickerValue,\n} from \"./IBaseTimePicker\";\nimport IBaseYearPicker, {\n  type IBaseYearPickerProps,\n  type IBaseYearPickerValue,\n} from \"./IBaseYearPicker\";\nimport ButtonFastChoose, {\n  type ButtonFastChooseProps,\n} from \"./components/ButtonFastChoose\";\n\nexport type IBasePickerDateProps = IBaseDatePickerProps;\nexport type IBasePickerRangeProps = IBaseDateRangePickerProps;\nexport type IBasePickerTimeProps = IBaseTimePickerProps;\nexport type IBasePickerMonthProps = IBaseMonthPickerProps;\nexport type IBasePickerYearProps = IBaseYearPickerProps;\n\n// Re-export canonical component names/types for `@base/client/components` barrel.\nexport {\n  ButtonFastChoose,\n  IBaseDatePicker,\n  IBaseDateRangePicker,\n  IBaseMonthPicker,\n  IBaseTimePicker,\n  IBaseYearPicker,\n};\nexport type {\n  ButtonFastChooseProps,\n  IBaseDatePickerProps,\n  IBaseDatePickerValue,\n  IBaseDateRangePickerProps,\n  IBaseDateRangePickerValue,\n  IBaseMonthPickerProps,\n  IBaseMonthPickerValue,\n  IBaseTimePickerProps,\n  IBaseTimePickerValue,\n  IBaseYearPickerProps,\n  IBaseYearPickerValue,\n  RangePreset,\n};\n\nexport type IBasePickerComponent = ComponentType<IBaseDatePickerProps> & {\n  Date: ComponentType<IBaseDatePickerProps>;\n  Range: ComponentType<IBaseDateRangePickerProps>;\n  Time: ComponentType<IBaseTimePickerProps>;\n  Month: ComponentType<IBaseMonthPickerProps>;\n  Year: ComponentType<IBaseYearPickerProps>;\n};\n\n/**\n * IBasePicker\n * - default export: IBaseDatePicker\n * - static: Date / Range / Time / Month / Year\n */\nexport const IBasePicker = Object.assign(IBaseDatePicker, {\n  Date: IBaseDatePicker,\n  Range: IBaseDateRangePicker,\n  Time: IBaseTimePicker,\n  Month: IBaseMonthPicker,\n  Year: IBaseYearPicker,\n}) as IBasePickerComponent;\n\nexport default IBasePicker;\n\n// Named exports (optional convenience)\n\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBasePopover/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Popover·as·HeroUIPopover,·PopoverContent·as·HeroUIPopoverContent,·PopoverTrigger·as·HeroUIPopoverTrigger,·PopoverProps·` with `⏎··Popover·as·HeroUIPopover,⏎··PopoverContent·as·HeroUIPopoverContent,⏎··PopoverTrigger·as·HeroUIPopoverTrigger,⏎··PopoverProps,⏎`","line":3,"column":9,"nodeType":null,"messageId":"replace","endLine":3,"endColumn":129,"fix":{"range":[23,143],"text":"\n  Popover as HeroUIPopover,\n  PopoverContent as HeroUIPopoverContent,\n  PopoverTrigger as HeroUIPopoverTrigger,\n  PopoverProps,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":13,"column":57,"nodeType":null,"messageId":"delete","endLine":14,"endColumn":1,"fix":{"range":[475,476],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Popover as HeroUIPopover, PopoverContent as HeroUIPopoverContent, PopoverTrigger as HeroUIPopoverTrigger, PopoverProps } from \"@heroui/popover\";\nimport React from \"react\";\n\nexport type IBasePopoverProps = PopoverProps & {};\n\nexport const IBasePopover: React.FC<IBasePopoverProps> = (props) => {\n  return <HeroUIPopover {...props} />;\n};\n\nexport const IBasePopoverTrigger = HeroUIPopoverTrigger;\nexport const IBasePopoverContent = HeroUIPopoverContent;\n\n\nexport default IBasePopover;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseProgress/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseRadio/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":18,"column":4,"nodeType":null,"messageId":"insert","endLine":18,"endColumn":4,"fix":{"range":[422,422],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport {\n  Radio as HeroUIRadio,\n  RadioGroup as HeroUIRadioGroup,\n  RadioGroupProps,\n  RadioProps,\n} from \"@heroui/radio\";\nimport React from \"react\";\n\nexport type IBaseRadioProps = RadioProps & {};\n\nexport const IBaseRadio = React.forwardRef<HTMLInputElement, IBaseRadioProps>(\n  (props, ref) => {\n    const { size = \"sm\", ...rest } = props;\n\n    return <HeroUIRadio ref={ref} size={size} {...rest} />;\n  }\n);\n\nIBaseRadio.displayName = \"IBaseRadio\";\n\nexport const IBaseRadioGroup = React.forwardRef<\n  HTMLDivElement,\n  RadioGroupProps\n>((props, ref) => {\n  const { size = \"sm\", ...rest } = props;\n\n  return <HeroUIRadioGroup ref={ref} size={size} {...rest} />;\n});\n\nIBaseRadioGroup.displayName = \"IBaseRadioGroup\";\n\nexport default IBaseRadio;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseScrollShadow/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSelect/IBaseSelect.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":27,"column":34,"nodeType":null,"messageId":"insert","endLine":27,"endColumn":34,"fix":{"range":[717,717],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":31,"column":30,"nodeType":null,"messageId":"insert","endLine":31,"endColumn":30,"fix":{"range":[838,838],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import {\n  SelectItem,\n  Select as SelectPrimitive,\n  SelectProps,\n} from \"@heroui/select\";\nimport clsx from \"clsx\";\nimport React from \"react\";\n\nexport type IBaseSelectProps = SelectProps & {};\nexport const IBaseSelect = React.forwardRef<\n  HTMLSelectElement,\n  IBaseSelectProps\n>((props, ref) => {\n  const { isDisabled, classNames, ...rest } = props;\n\n  return (\n    <SelectPrimitive\n      {...rest}\n      ref={ref}\n      fullWidth\n      classNames={{\n        base: clsx(\"max-w opacity-100\", classNames?.base),\n        label: clsx(\"text-small text-default-600\", classNames?.label),\n        mainWrapper: clsx(\n          \"cursor-not-allowed\",\n          isDisabled && \"bg-default-200\",\n          classNames?.mainWrapper\n        ),\n        trigger: clsx(\n          \"placeholder:text-default-400 italic text-sm\",\n          classNames?.trigger\n        ),\n        popoverContent: clsx(\"p-0\", classNames?.popoverContent),\n        listbox: clsx(\"p-0\", classNames?.listbox),\n        helperWrapper: classNames?.helperWrapper,\n        description: classNames?.description,\n        errorMessage: classNames?.errorMessage,\n        value: classNames?.value,\n        selectorIcon: classNames?.selectorIcon,\n        listboxWrapper: classNames?.listboxWrapper,\n        innerWrapper: classNames?.innerWrapper,\n      }}\n      labelPlacement=\"outside\"\n      placeholder=\"Please select...\"\n      popoverProps={{\n        classNames: {\n          base: \"p-0\",\n          content: \"p-1\",\n        },\n        ...rest.popoverProps,\n      }}\n      scrollShadowProps={{ size: 0 }}\n      size=\"sm\"\n      variant=\"bordered\"\n    />\n  );\n});\n\nIBaseSelect.displayName = \"IBaseSelect\";\n\nexport const IBaseSelectItem = SelectItem;\n\nexport default IBaseSelect;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSelect/IBaseSingleSelect.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'searchRules' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":47,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { SelectItem } from \"@heroui/select\";\nimport MiniSearch from \"minisearch\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { useLocalizedText } from \"../../hooks/useLocalizedText\";\nimport { LocalizeText } from \"../../interface/LocalizeText\";\nimport IBaseInputSearch from \"../IBaseInputSearch\";\n\nimport IBaseSelect, { IBaseSelectProps } from \"./IBaseSelect\";\n\nexport interface SelectItemOption extends Record<string, unknown> {\n  value: string | number;\n  label: string | LocalizeText;\n  localizedLabel?: string;\n  searchText?: string; // Optional additional text for search\n  [key: string]: unknown;\n}\n\nexport interface IBaseSingleSelectProps extends Omit<\n  IBaseSelectProps,\n  \"children\" | \"selectionMode\" | \"onSelectionChange\" | \"selectedKeys\"\n> {\n  selectedKey?: string;\n  onSelectionChange?: (key?: string, item?: SelectItemOption) => void;\n  onRenderOption?: (item: SelectItemOption) => React.ReactNode;\n  items?: SelectItemOption[];\n  searchPlaceholder?: string;\n  searchShowMaxResults?: number;\n  searchRules?: {\n    by?: \"label\" | \"searchText\";\n    prefix?: boolean;\n    fuzzy?: number;\n  }[];\n}\n\nexport const IBaseSingleSelect = React.forwardRef<\n  HTMLSelectElement,\n  IBaseSingleSelectProps\n>((props, ref) => {\n  const {\n    items,\n    selectedKey,\n    onSelectionChange,\n    searchPlaceholder = \"Search...\",\n    searchRules = [{ by: \"label\", prefix: true, fuzzy: 0.2 }],\n    searchShowMaxResults = 10,\n    onRenderOption,\n    ...rest\n  } = props;\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n  const searchInputRef = useRef<HTMLInputElement>(null);\n  const localizedText = useLocalizedText();\n  // Create MiniSearch index for items with phrase support\n  const miniSearch = useMemo(() => {\n    if (!items || items.length === 0) {\n      return null;\n    }\n\n    // Filter out items with invalid values and ensure value is a string\n    const validItems = items.filter(\n      (item) =>\n        item.value !== undefined && item.value !== null && item.value !== \"\",\n    );\n\n    if (validItems.length === 0) {\n      return null;\n    }\n\n    const searchableItems = validItems.map((item) => ({\n      id: String(item.value),\n      label: String(item.label || \"\"),\n      searchText: String(item.searchText || item.label || \"\"),\n      // Add full phrase for exact matching\n      fullPhrase:\n        `${item.label || \"\"} ${item.searchText || item.label || \"\"}`.toLowerCase(),\n    }));\n\n    const ms = new MiniSearch<{\n      id: string;\n      label: string;\n      searchText: string;\n      fullPhrase: string;\n    }>({\n      fields: [\"label\", \"searchText\", \"fullPhrase\"],\n      storeFields: [\"id\", \"label\", \"searchText\", \"fullPhrase\"],\n      idField: \"id\",\n    });\n\n    ms.addAll(searchableItems);\n\n    return ms;\n  }, [items]);\n\n  // Filter items using MiniSearch with phrase support\n  const filteredItems = useMemo(() => {\n    if (!items || items.length === 0) return [];\n\n    const term = searchTerm.trim();\n\n    if (!term || !miniSearch) return items;\n\n    // Check if search term contains quotes (exact phrase)\n    const isPhraseSearch = (term.match(/\"/g) || []).length >= 2;\n    const cleanTerm = term.replace(/\"/g, \"\").trim().toLowerCase();\n\n    let results;\n\n    if (isPhraseSearch && cleanTerm) {\n      // Exact phrase search - search for the entire phrase\n      // First try exact match on fullPhrase field\n      results = miniSearch.search(cleanTerm, {\n        prefix: false,\n        fuzzy: 0.1, // Lower fuzzy for exact phrases\n        combineWith: \"AND\", // All words must be present\n      });\n\n      // Also filter by exact phrase match in fullPhrase\n      if (results.length > 0) {\n        results = results.filter((result) =>\n          result.fullPhrase?.includes(cleanTerm),\n        );\n      }\n    } else {\n      // Regular search - can match individual words or phrases\n      const words = cleanTerm.split(/\\s+/).filter((w) => w.length > 0);\n\n      if (words.length > 1) {\n        // Multiple words - use AND to require all words (phrase search)\n        results = miniSearch.search(cleanTerm, {\n          prefix: true,\n          fuzzy: 0.2,\n          combineWith: \"AND\", // All words must match (phrase-like behavior)\n        });\n\n        // Boost results that contain the full phrase\n        const phraseResults = results.filter((result) =>\n          result.fullPhrase?.includes(cleanTerm),\n        );\n\n        // Combine: phrase matches first, then word matches\n        const otherResults = results.filter(\n          (result) => !phraseResults.some((pr) => pr.id === result.id),\n        );\n\n        results = [...phraseResults, ...otherResults];\n      } else {\n        // Single word - use prefix matching\n        results = miniSearch.search(cleanTerm, {\n          prefix: true,\n          fuzzy: 0.2,\n        });\n      }\n    }\n\n    if (results.length === 0) return [];\n\n    // Map results back to original items\n    const resultMap = new Map(results.map((result) => [result.id, result]));\n\n    return items.filter((item) => resultMap.has(String(item.value)));\n  }, [items, miniSearch, searchTerm]);\n\n  // Focus search input when dropdown opens\n  useEffect(() => {\n    if (!isOpen) {\n      setSearchTerm(\"\");\n    }\n    if (isOpen && searchInputRef.current) {\n      // Small delay to ensure the input is rendered in the DOM\n      setTimeout(() => {\n        searchInputRef.current?.focus();\n      }, 100);\n    }\n  }, [isOpen]);\n\n  const handleOpenChange = (open: boolean) => {\n    // Prevent opening if disabled\n\n    if (rest.isDisabled) {\n      setIsOpen(false);\n\n      return;\n    }\n\n    setIsOpen(open);\n    if (rest.onOpenChange) {\n      rest.onOpenChange(open);\n    }\n  };\n\n  const handleSelectionChange = (\n    keys: Parameters<NonNullable<IBaseSelectProps[\"onSelectionChange\"]>>[0],\n  ) => {\n    // Prevent selection of the search input item\n    if (typeof keys === \"string\") return;\n    const keySet = keys as Set<string>;\n    const selected = Array.from(keySet)[0] as string | undefined;\n\n    if (selected === \"__search__\") {\n      return;\n    }\n\n    if (!onSelectionChange) return;\n\n    // Handle clearing selection (empty set)\n    if (!selected || keySet.size === 0) {\n      // Find a placeholder item or use empty string\n      // For clearing, we'll pass empty string and a minimal item\n      const emptyItem: SelectItemOption = { value: \"\", label: \"\" };\n\n      onSelectionChange(\"\", emptyItem);\n\n      return;\n    }\n\n    // Find the selected item\n    const selectedItem = items?.find((item) => item.value === selected);\n\n    if (selectedItem) {\n      onSelectionChange(selected, selectedItem);\n    }\n  };\n\n  return (\n    <IBaseSelect\n      {...rest}\n      ref={ref}\n      classNames={rest.classNames}\n      isOpen={isOpen}\n      items={filteredItems}\n      selectedKeys={selectedKey ? new Set([selectedKey]) : undefined}\n      selectionMode=\"single\"\n      onOpenChange={handleOpenChange}\n      onSelectionChange={handleSelectionChange}\n    >\n      <>\n        {items && items.length > searchShowMaxResults && (\n          <SelectItem\n            key=\"__search__\"\n            hideSelectedIcon\n            isReadOnly\n            className=\"sticky top-0 z-100 pointer-events-auto data-[hover=true]:bg-content1 bg-content1  border-default-200 p-0 py-1\"\n            textValue=\"Search\"\n          >\n            <IBaseInputSearch\n              ref={searchInputRef}\n              // Avoid autoFocus for better accessibility; focus is managed via effect\n              classNames={{\n                base: \"w-full\",\n                input: \"text-sm\",\n              }}\n              placeholder={searchPlaceholder}\n              showClearButton={false}\n              size=\"sm\"\n              value={searchTerm}\n              onKeyDown={(e) => {\n                if (e.key === \"Enter\") {\n                  e.preventDefault();\n                }\n                if (e.key === \"Escape\") {\n                  e.preventDefault();\n                  setSearchTerm(\"\");\n                }\n              }}\n              onValueChange={setSearchTerm}\n            />\n          </SelectItem>\n        )}\n\n        {filteredItems.map((item) => {\n          const localizedLabel = localizedText(item.label);\n\n          return (\n            <SelectItem key={item.value} textValue={localizedLabel}>\n              {onRenderOption\n                ? onRenderOption({\n                    ...item,\n                    localizedLabel,\n                  })\n                : localizedLabel}\n            </SelectItem>\n          );\n        })}\n      </>\n    </IBaseSelect>\n  );\n});\n\nIBaseSingleSelect.displayName = \"IBaseSingleSelect\";\n\nexport default IBaseSingleSelect;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSelect/IBaseSingleSelectAsync.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":87,"fix":{"range":[284,284],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/DropdownOptionsService` import should occur after import of `react`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":87,"fix":{"range":[198,535],"text":"import { SelectItem } from \"@heroui/select\";\nimport { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useId,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { dropdownOptionsService } from \"@base/client/services/DropdownOptionsService\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type {\n  DropdownOptionsParams,\n  DropdownOptionsResponse,\n} from \"@base/client/services/DropdownOptionsService\";\nimport type { SelectItemOption } from \"./IBaseSingleSelect\";\n\nimport { dropdownOptionsService } from \"@base/client/services/DropdownOptionsService\";\nimport { SelectItem } from \"@heroui/select\";\nimport { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport React, {\n  useCallback,\n  useEffect,\n  useId,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { useLocalizedText } from \"../../hooks/useLocalizedText\";\nimport IBaseInputSearch from \"../IBaseInputSearch\";\n\nimport IBaseSelect, { IBaseSelectProps } from \"./IBaseSelect\";\n\nexport interface FetchOptionsParams extends DropdownOptionsParams {}\n\nexport type ServiceFetch = (\n  params: FetchOptionsParams,\n) => Promise<DropdownOptionsResponse>;\n\nexport interface IBaseSingleSelectAsyncProps extends Omit<\n  IBaseSelectProps,\n  \"children\" | \"selectionMode\" | \"onSelectionChange\" | \"selectedKeys\"\n> {\n  selectedKey?: string;\n  onRenderOption?: (item: SelectItemOption) => React.ReactNode;\n  onSelectionChange?: (key?: string, item?: SelectItemOption) => void;\n  // Either provide a fetch function or a model string\n  model?: string;\n  serviceFn?: ServiceFetch;\n  callWhen?: \"open\" | \"mount\";\n  onTheFirstFetchSuccess?: (data: DropdownOptionsResponse) => void;\n  onFinishFetch?: (data: DropdownOptionsResponse) => void;\n  onErrorFetch?: (error: Error) => void;\n  onFetching?: (isFetching: boolean) => void;\n  searchPlaceholder?: string;\n  defaultLimit?: number;\n  isShowSearch?: boolean;\n  // Additional params to pass to fetch function\n  defaultParams?: Omit<FetchOptionsParams, \"limit\" | \"offset\" | \"search\">;\n}\n\nexport const IBaseSingleSelectAsync = React.forwardRef<\n  HTMLSelectElement,\n  IBaseSingleSelectAsyncProps\n>((props, ref) => {\n  const {\n    serviceFn,\n    model,\n    callWhen = \"open\",\n    selectedKey,\n    onSelectionChange,\n    onTheFirstFetchSuccess,\n    onFinishFetch,\n    onErrorFetch,\n    onFetching,\n    searchPlaceholder,\n    defaultLimit = 20,\n    defaultParams = {},\n    isShowSearch = true,\n    onRenderOption,\n    ...rest\n  } = props;\n  const componentKeyId = useId();\n\n  const localizedText = useLocalizedText();\n\n  const tSelectAsync = useTranslations(\"components.selectAsync\");\n\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n  const searchInputRef = useRef<HTMLInputElement>(null);\n  const searchDebounceRef = useRef<NodeJS.Timeout | null>(null);\n  const isFirstFetchRef = useRef(true);\n  // Memoize fetch function to avoid recreating on every render\n  const fetchFn = useMemo(() => {\n    if (serviceFn) {\n      return serviceFn;\n    }\n    if (model) {\n      return async (params: FetchOptionsParams) => {\n        return dropdownOptionsService.getOptionsDropdown(model, params);\n      };\n    }\n\n    return null;\n  }, [serviceFn, model]);\n\n  // Memoize defaultParams to prevent unnecessary query key changes\n  const stableDefaultParams = useMemo(() => defaultParams, [defaultParams]);\n\n  // Debounce search term to avoid excessive API calls\n  useEffect(() => {\n    if (searchDebounceRef.current) {\n      clearTimeout(searchDebounceRef.current);\n    }\n\n    searchDebounceRef.current = setTimeout(() => {\n      setDebouncedSearchTerm(searchTerm);\n    }, 300);\n\n    return () => {\n      if (searchDebounceRef.current) {\n        clearTimeout(searchDebounceRef.current);\n      }\n    };\n  }, [searchTerm]);\n\n  // Memoize query function to prevent recreation\n  const queryFn = useCallback(\n    async ({ pageParam = 0 }: { pageParam?: number }) => {\n      if (!fetchFn) {\n        throw new Error(\"Either fetchOptions or model must be provided\");\n      }\n      onFetching?.(true);\n\n      const data = await fetchFn({\n        offset: pageParam,\n        limit: defaultLimit,\n        search: debouncedSearchTerm || undefined,\n        ...stableDefaultParams,\n      })\n        .then((data) => {\n          if (isFirstFetchRef.current) {\n            onTheFirstFetchSuccess?.(data);\n            isFirstFetchRef.current = false;\n          }\n          onFinishFetch?.(data);\n\n          return data;\n        })\n        .catch((error) => {\n          onErrorFetch?.(error);\n\n          return {\n            data: [],\n            total: 0,\n          };\n        })\n        .finally(() => {\n          onFetching?.(false);\n        });\n\n      return data;\n    },\n    [\n      fetchFn,\n      defaultLimit,\n      debouncedSearchTerm,\n      stableDefaultParams,\n      onTheFirstFetchSuccess,\n      onFetching,\n      onFinishFetch,\n    ],\n  );\n\n  // Memoize getNextPageParam to prevent recreation\n  const getNextPageParam = useCallback(\n    (\n      lastPage: DropdownOptionsResponse,\n      allPages: DropdownOptionsResponse[],\n    ) => {\n      const currentTotal = lastPage.total || 0;\n      // Calculate current offset: sum of all items loaded so far\n      const currentOffset = allPages.reduce(\n        (sum, page) => sum + (page.data?.length || 0),\n        0,\n      );\n\n      // If current offset is less than total, return next offset\n      if (currentOffset < currentTotal) {\n        return currentOffset;\n      }\n\n      // No more pages\n      return undefined;\n    },\n    [],\n  );\n\n  // Memoize query key to prevent unnecessary refetches\n  const queryKey = useMemo(\n    () => [\n      \"singleSelectAsync\",\n      model || componentKeyId,\n      debouncedSearchTerm,\n      defaultLimit,\n      stableDefaultParams,\n    ],\n    [model, debouncedSearchTerm, defaultLimit, stableDefaultParams],\n  );\n\n  // Fetch data using useInfiniteQuery\n  const {\n    data,\n    isLoading,\n    isFetching,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery({\n    queryKey,\n    queryFn,\n    enabled: !!fetchFn && (callWhen === \"open\" ? isOpen : true),\n    initialPageParam: 0,\n    getNextPageParam,\n    staleTime: 30000, // Cache for 30 seconds\n  });\n\n  // Flatten all pages into a single array of items\n  const allItems = useMemo(() => {\n    if (!data?.pages) return [];\n\n    return data.pages.flatMap((page) =>\n      page.data.map((item) => ({\n        ...item,\n        value: item.value,\n        label: item.label,\n      })),\n    );\n  }, [data?.pages]);\n\n  // // Get total from last page\n  // const total = useMemo(() => {\n  //   if (!data?.pages || data.pages.length === 0) return 0;\n  //   return data.pages[data.pages.length - 1].total || 0;\n  // }, [data?.pages]);\n\n  // Handle scroll for infinite loading - memoized to prevent recreation\n  const handleScroll = useCallback(\n    (e: React.UIEvent<HTMLUListElement>) => {\n      const target = e.currentTarget;\n      const scrollTop = target.scrollTop;\n      const scrollHeight = target.scrollHeight;\n      const clientHeight = target.clientHeight;\n\n      // Load more when scrolled near bottom (within 50px)\n      if (\n        scrollHeight - scrollTop - clientHeight < 50 &&\n        hasNextPage &&\n        !isFetchingNextPage &&\n        !isLoading &&\n        !isFetching\n      ) {\n        fetchNextPage();\n      }\n    },\n    [hasNextPage, isFetchingNextPage, isLoading, isFetching, fetchNextPage],\n  );\n\n  // Focus search input when dropdown opens\n  useEffect(() => {\n    if (!isOpen) {\n      setSearchTerm(\"\");\n      setDebouncedSearchTerm(\"\");\n    } else if (isOpen && isShowSearch && searchInputRef.current) {\n      setTimeout(() => {\n        searchInputRef.current?.focus();\n      }, 100);\n    }\n  }, [isOpen, isShowSearch]);\n\n  const handleOpenChange = useCallback(\n    (open: boolean) => {\n      if (rest.isDisabled) {\n        setIsOpen(false);\n\n        return;\n      }\n\n      setIsOpen(open);\n      if (rest.onOpenChange) {\n        rest.onOpenChange(open);\n      }\n    },\n    [rest.isDisabled, rest.onOpenChange, setIsOpen],\n  );\n\n  // Memoize selection change handler to prevent recreation\n  const handleSelectionChange = useCallback(\n    (\n      keys: Parameters<NonNullable<IBaseSelectProps[\"onSelectionChange\"]>>[0],\n    ) => {\n      if (typeof keys === \"string\") return;\n      const keySet = keys as Set<string>;\n      const selected = Array.from(keySet)[0] as string | undefined;\n\n      if (selected === \"__search__\") {\n        return;\n      }\n\n      if (!onSelectionChange) return;\n\n      // Handle clearing selection\n      if (!selected || keySet.size === 0) {\n        const emptyItem: SelectItemOption = { value: \"\", label: \"\" };\n\n        onSelectionChange(\"\", emptyItem);\n\n        return;\n      }\n\n      // Find the selected item\n      const selectedItem = allItems.find((item) => item.value === selected);\n\n      if (selectedItem) {\n        onSelectionChange(selected, selectedItem);\n      }\n    },\n    [allItems, onSelectionChange],\n  );\n\n  // Memoize loading state\n  const isLoadingData = useMemo(\n    () => isLoading || isFetching,\n    [isLoading, isFetching],\n  );\n\n  // Memoize selectedKeys to prevent creating new Set on every render\n  const selectedKeysSet = useMemo(\n    () => (selectedKey ? new Set([selectedKey]) : undefined),\n    [selectedKey],\n  );\n\n  // Memoize listboxProps to prevent object recreation\n  const listboxPropsMemo = useMemo(\n    () => ({\n      onScroll: handleScroll,\n      ...rest.listboxProps,\n    }),\n    [handleScroll, rest.listboxProps],\n  );\n\n  // Memoize search input classNames\n  const searchInputClassNames = useMemo(\n    () => ({\n      base: \"w-full\",\n      input: \"text-sm\",\n    }),\n    [],\n  );\n\n  // Memoize search input keydown handler\n  const handleSearchKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n      }\n      if (e.key === \"Escape\") {\n        e.preventDefault();\n        setSearchTerm(\"\");\n      }\n    },\n    [],\n  );\n\n  return (\n    <IBaseSelect\n      {...rest}\n      ref={ref}\n      classNames={rest.classNames}\n      isOpen={isOpen}\n      items={allItems}\n      listboxProps={listboxPropsMemo}\n      selectedKeys={selectedKeysSet}\n      selectionMode=\"single\"\n      onOpenChange={handleOpenChange}\n      onSelectionChange={handleSelectionChange}\n    >\n      <>\n        {isShowSearch && (\n          <SelectItem\n            key=\"__search__\"\n            hideSelectedIcon\n            isReadOnly\n            className=\"sticky top-0 z-100 pointer-events-auto data-[hover=true]:bg-content1 bg-content1 border-default-200 p-0 py-1\"\n            textValue={tSelectAsync(\"searchLabel\")}\n          >\n            <IBaseInputSearch\n              ref={searchInputRef}\n              // Avoid autoFocus for better accessibility; focus is handled via effect\n              classNames={searchInputClassNames}\n              placeholder={searchPlaceholder}\n              showClearButton={false}\n              size=\"sm\"\n              value={searchTerm}\n              onKeyDown={handleSearchKeyDown}\n              onValueChange={setSearchTerm}\n            />\n          </SelectItem>\n        )}\n\n        {error && (\n          <SelectItem\n            key=\"__error__\"\n            hideSelectedIcon\n            isReadOnly\n            className=\"text-danger\"\n            textValue={tSelectAsync(\"error\")}\n          >\n            {tSelectAsync(\"error\")}\n          </SelectItem>\n        )}\n\n        {isLoadingData && allItems.length === 0 && (\n          <SelectItem\n            key=\"__loading__\"\n            hideSelectedIcon\n            isReadOnly\n            textValue={tSelectAsync(\"loading\")}\n          >\n            {tSelectAsync(\"loading\")}\n          </SelectItem>\n        )}\n\n        {allItems.length === 0 && !isLoadingData && !error && (\n          <SelectItem\n            key=\"__empty__\"\n            hideSelectedIcon\n            isReadOnly\n            textValue={tSelectAsync(\"noResults\")}\n          >\n            {tSelectAsync(\"noResults\")}\n          </SelectItem>\n        )}\n\n        {allItems.map((item) => {\n          const localizedLabel = localizedText(item.label);\n\n          return (\n            <SelectItem key={item.value} textValue={localizedLabel}>\n              {onRenderOption\n                ? onRenderOption({\n                    ...item,\n                    localizedLabel,\n                  })\n                : localizedLabel}\n            </SelectItem>\n          );\n        })}\n\n        {isFetchingNextPage && (\n          <SelectItem\n            key=\"__loading_more__\"\n            hideSelectedIcon\n            isReadOnly\n            textValue={tSelectAsync(\"loadingMore\")}\n          >\n            {tSelectAsync(\"loadingMore\")}\n          </SelectItem>\n        )}\n      </>\n    </IBaseSelect>\n  );\n});\n\nIBaseSingleSelectAsync.displayName = \"IBaseSingleSelectAsync\";\n\nexport default IBaseSingleSelectAsync;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSelect/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSkeleton/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSnippet/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSpacer/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSpinner/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseSwitch/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":13,"column":4,"nodeType":null,"messageId":"insert","endLine":13,"endColumn":4,"fix":{"range":[373,373],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Switch as HeroUISwitch, SwitchProps } from \"@heroui/switch\";\nimport React from \"react\";\n\nexport type IBaseSwitchProps = SwitchProps & {};\n\nexport const IBaseSwitch = React.forwardRef<HTMLInputElement, IBaseSwitchProps>(\n  (props, ref) => {\n    const { size = \"sm\", ...rest } = props;\n\n    return <HeroUISwitch ref={ref} size={size} {...rest} />;\n  }\n);\n\nIBaseSwitch.displayName = \"IBaseSwitch\";\n\nexport default IBaseSwitch;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/IBaseTable.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":33,"fix":{"range":[256,256],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":56,"fix":{"range":[312,312],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `next-intl`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":56,"fix":{"range":[257,383],"text":"import clsx from \"clsx\";\nimport { useTranslations } from \"next-intl\";\nimport { IBaseTooltip } from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cellValue' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":175,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport type { IBaseTableCoreColumn } from \"@base/client/components\";\nimport type { Selection } from \"@heroui/table\";\nimport type { TableProps } from \"@heroui/table\";\n\nimport { RefreshCw } from \"lucide-react\";\nimport { useMemo } from \"react\";\nimport { IBaseTooltip } from \"@base/client/components\";\nimport clsx from \"clsx\";\nimport { useTranslations } from \"next-intl\";\n\nimport PaginationComponent from \"../Pagination/Pagination\";\nimport { PAGINATION_DEFAULT_PAGE_SIZE } from \"../Pagination/paginationConsts\";\n\nimport { useIBaseTableCore } from \"./IBaseTableCore\";\nimport {\n  I_BASE_TABLE_COLUMN_KEY_ROW_NUMBER,\n  type IBaseTableProps as IBaseTablePropsType,\n} from \"./IBaseTableInterface\";\nimport IBaseTableUI from \"./IBaseTableUI\";\nimport useColumns from \"./hooks/useColumns\";\nimport { useIBaseTablePagination } from \"./hooks/useIBaseTablePagination\";\n\nexport function IBaseTable<T = any>({\n  columns,\n  dataSource,\n  total: totalProps = 0,\n  rowKey = \"id\",\n  pagination = { pageSize: PAGINATION_DEFAULT_PAGE_SIZE, page: 1 },\n  loading = false,\n  color = \"primary\",\n  summary: _summary,\n  rowSelection = false,\n  onChangeTable,\n  classNames = {},\n  emptyContent = \"No data available\",\n  tableLayout = \"auto\",\n  isResizableColumns = true,\n  isDraggableColumns = true,\n  isRefreshData = true,\n  onRefresh,\n  ...rest\n}: IBaseTablePropsType<T>) {\n  const t = useTranslations(\"dataTable\");\n\n  const processedColumns = useColumns(columns);\n\n  // Convert ProcessedIBaseTableColumn to IBaseTableCoreColumn\n  const iBaseTableColumns = useMemo<IBaseTableCoreColumn<T>[]>(() => {\n    return processedColumns.map((col) => ({\n      key: col.key,\n      title: col.title,\n      label: col.label,\n      dataIndex: col.dataIndex,\n      align: col.align,\n      width: col.width,\n      minWidth: col.minWidth,\n      maxWidth: col.maxWidth,\n      sortable: col.sortable,\n      fixed: col.fixed,\n      render: (value: any, record: T, index: number) => {\n        // Use renderValue from processed column\n        return col.renderValue(record, index);\n      },\n      isResizable: col.isResizable,\n      isDraggable: col.isDraggable,\n      enableSorting: col.sortable,\n      enablePinning: !!col.fixed,\n      enableResizing: col.isResizable,\n      meta: {\n        frozenStyle: col.frozenStyle,\n        frozenClassName: col.frozenClassName,\n        isRowNumber: col.key === I_BASE_TABLE_COLUMN_KEY_ROW_NUMBER,\n      },\n    }));\n  }, [processedColumns]);\n\n  // Core table logic - all logic is now in useIBaseTableCore\n  const core = useIBaseTableCore<T>({\n    data: dataSource,\n    columns: iBaseTableColumns,\n    rowKey,\n    pagination:\n      pagination && typeof pagination === \"object\"\n        ? {\n            page: pagination.page ?? 1,\n            pageSize: pagination.pageSize ?? PAGINATION_DEFAULT_PAGE_SIZE,\n            total: Math.max(0, typeof totalProps === \"number\" ? totalProps : 0),\n          }\n        : false,\n    manualPagination: true,\n    manualSorting: true,\n    rowSelection:\n      rowSelection === false\n        ? false\n        : {\n            type: rowSelection?.type || \"multiple\",\n            selectedRowKeys: rowSelection?.selectedRowKeys,\n            onChange: rowSelection?.onChange,\n          },\n    enableColumnResizing: isResizableColumns,\n    enableColumnPinning: true,\n    enableColumnOrdering: isDraggableColumns,\n    onChangeTable, // Combined callback for pagination + sorting\n    onRowSelectionChange: (selectedRowKeys, selectedRows) => {\n      if (rowSelection !== false && rowSelection?.onChange) {\n        rowSelection.onChange(selectedRowKeys, selectedRows);\n      }\n    },\n  });\n\n  // All pagination logic is handled by useIBaseTablePagination hook\n  const paginationState = useIBaseTablePagination({\n    pagination,\n    total: totalProps,\n    paginationInfo: core.paginationInfo,\n  });\n\n  // Convert row selection state to HeroUI format\n  const selectionProps = useMemo(() => {\n    if (rowSelection === false) {\n      return undefined;\n    }\n\n    const selectedKeysSet = new Set(core.selectedRowKeys);\n\n    return {\n      selectionMode: (rowSelection?.type === \"single\"\n        ? \"single\"\n        : \"multiple\") as TableProps[\"selectionMode\"],\n      selectedKeys: selectedKeysSet.size > 0 ? selectedKeysSet : undefined,\n      onSelectionChange: (keys: Selection) => {\n        if (keys === \"all\") {\n          core.toggleAllRowsSelection(true);\n        } else if (keys instanceof Set) {\n          const newSelection: Record<string, boolean> = {};\n\n          keys.forEach((key) => {\n            newSelection[String(key)] = true;\n          });\n          core.setRowSelection(newSelection);\n        } else {\n          core.resetRowSelection();\n        }\n      },\n    };\n  }, [rowSelection, core]);\n\n  // Use pagination summary from hook and translate it\n  const paginationSummary = useMemo(() => {\n    return t(\"summary\", paginationState.paginationSummary);\n  }, [paginationState.paginationSummary, t]);\n\n  const shouldRenderFooter =\n    isRefreshData ||\n    Boolean(paginationSummary) ||\n    (paginationState.showPaginationControls &&\n      paginationState.paginationInfo.pages > 1);\n\n  return (\n    <div className={clsx(\"w-full bg-content1\", classNames.wrapper)}>\n      <div className=\"flex flex-1 flex-col gap-4\">\n        <IBaseTableUI\n          aria-label={t(\"ariaLabel\")}\n          classNames={classNames}\n          color={color}\n          emptyContent={emptyContent ?? t(\"empty\")}\n          getRowKey={core.getRowKey}\n          headerGroups={core.headerGroups}\n          isCompact={true}\n          isHeaderSticky={true}\n          isStriped={true}\n          loading={loading}\n          renderCell={(column, row, cellValue) => {\n            // Handle row number column with pagination offset\n            const meta = (column.columnDef.meta as Record<string, any>) || {};\n\n            if (meta.isRowNumber && paginationState.paginationInfo) {\n              return paginationState.paginationInfo.from + row.index + 1;\n            }\n\n            // Return undefined - IBaseTableUI will check and use flexRender if undefined\n            return undefined;\n          }}\n          rows={core.rows}\n          selectedKeys={selectionProps?.selectedKeys}\n          selectionMode={selectionProps?.selectionMode}\n          sortDescriptor={core.sortDescriptor}\n          tableLayout={tableLayout}\n          visibleColumns={core.visibleColumns}\n          onSelectionChange={selectionProps?.onSelectionChange}\n          onSortChange={core.handleSortChange}\n          {...rest}\n        />\n      </div>\n\n      {shouldRenderFooter && (\n        <div\n          className={clsx(\n            \"flex flex-col items-center justify-between px-2 sm:flex-row\",\n            classNames.pagination,\n          )}\n        >\n          <div className=\"flex items-center py-2 text-small text-default-500\">\n            {paginationSummary}\n            {isRefreshData && (\n              <IBaseTooltip content={t(\"refresh\")}>\n                <button\n                  aria-label={t(\"refresh\")}\n                  className=\"ml-2 inline-flex items-center rounded p-1 transition-colors hover:bg-default-100\"\n                  type=\"button\"\n                  onClick={onRefresh}\n                >\n                  <RefreshCw className=\"h-4 w-4 text-default-500 hover:text-primary\" />\n                </button>\n              </IBaseTooltip>\n            )}\n          </div>\n\n          {paginationState.showPaginationControls &&\n            core.handlePageChange &&\n            core.handlePageSizeChange && (\n              <PaginationComponent\n                page={paginationState.paginationInfo.currentPage}\n                pageSize={paginationState.paginationInfo.pageSize}\n                pageSizeOptions={\n                  paginationState.paginationDefault.pageSizeOptions\n                }\n                pages={paginationState.paginationInfo.pages}\n                onChange={core.handlePageChange}\n                onPageSizeChange={core.handlePageSizeChange}\n              />\n            )}\n        </div>\n      )}\n    </div>\n  );\n}\nexport default IBaseTable;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/IBaseTableCore.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":491,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":491,"endColumn":18,"suggestions":[{"fix":{"range":[13511,13555],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SortDescriptor } from \"@react-types/shared\";\nimport type { ReactNode } from \"react\";\n\nimport {\n  getCoreRowModel,\n  getExpandedRowModel,\n  getFilteredRowModel,\n  getGroupedRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n  type ColumnDef,\n  type ColumnOrderState,\n  type ColumnPinningState,\n  type ColumnSizingState,\n  type ExpandedState,\n  type GroupingState,\n  type PaginationState,\n  type RowSelectionState,\n  type SortingState,\n  type Table as TanStackTable,\n  type VisibilityState,\n} from \"@tanstack/react-table\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport { PAGINATION_DEFAULT_PAGE_SIZE } from \"../Pagination/paginationConsts\";\n\n// Column Definition Type (compatible with DataTableColumnDefinition)\nexport interface IBaseTableCoreColumn<T = any> {\n  key: string;\n  title?: ReactNode;\n  label?: string;\n  dataIndex?: string | string[];\n  align?: \"start\" | \"center\" | \"end\";\n  width?: number;\n  minWidth?: number;\n  maxWidth?: number;\n  sortable?: boolean;\n  fixed?: \"left\" | \"right\";\n  render?: (value: any, record: T, index: number) => ReactNode;\n  isResizable?: boolean;\n  isDraggable?: boolean;\n  enableSorting?: boolean;\n  enablePinning?: boolean;\n  enableResizing?: boolean;\n  meta?: Record<string, any>;\n}\n\n// Props for the core hook\nexport interface IBaseTableCoreProps<T = any> {\n  data: T[];\n  columns: IBaseTableCoreColumn<T>[];\n  rowKey?: string | ((record: T, index: number) => string);\n\n  // Pagination\n  pagination?:\n    | {\n        page?: number;\n        pageSize?: number;\n        total?: number;\n      }\n    | false;\n  manualPagination?: boolean;\n\n  // Sorting\n  sorting?: SortDescriptor | undefined;\n  manualSorting?: boolean;\n  enableSorting?: boolean;\n\n  // Selection\n  rowSelection?:\n    | {\n        type?: \"single\" | \"multiple\";\n        selectedRowKeys?: (string | number)[];\n        onChange?: (\n          selectedRowKeys: (string | number)[],\n          selectedRows: T[],\n        ) => void;\n      }\n    | false;\n\n  // Column features\n  enableColumnResizing?: boolean;\n  enableColumnPinning?: boolean;\n  enableColumnVisibility?: boolean;\n  enableColumnOrdering?: boolean;\n\n  // Grouping\n  enableGrouping?: boolean;\n  grouping?: string[];\n  onGroupingChange?: (grouping: string[]) => void;\n  expanded?: ExpandedState;\n  onExpandedChange?: (expanded: ExpandedState) => void;\n\n  onRowSelectionChange?: (\n    selectedRowKeys: (string | number)[],\n    selectedRows: T[],\n  ) => void;\n  onColumnOrderChange?: (columnOrder: string[]) => void;\n\n  // DataTable specific: Combined onChange callback\n  onChangeTable?: (params: {\n    page: number;\n    pageSize: number;\n    sort?: SortDescriptor;\n  }) => void;\n}\n\n// Return type for the core hook\nexport interface IBaseTableCoreReturn<T = any> {\n  table: TanStackTable<T>;\n  // State\n  paginationState: PaginationState;\n  sortingState: SortingState;\n  rowSelectionState: RowSelectionState;\n  columnPinningState: ColumnPinningState;\n  columnSizingState: ColumnSizingState;\n  columnVisibilityState: VisibilityState;\n  columnOrderState: ColumnOrderState;\n  groupingState: GroupingState;\n  expandedState: ExpandedState;\n  // Computed\n  rows: ReturnType<TanStackTable<T>[\"getRowModel\"]>[\"rows\"];\n  headerGroups: ReturnType<TanStackTable<T>[\"getHeaderGroups\"]>;\n  visibleColumns: ReturnType<TanStackTable<T>[\"getVisibleLeafColumns\"]>;\n  selectedRows: T[];\n  selectedRowKeys: (string | number)[];\n  setRowSelection: (\n    selection:\n      | RowSelectionState\n      | ((prev: RowSelectionState) => RowSelectionState),\n  ) => void;\n  setColumnOrder: (columnOrder: ColumnOrderState) => void;\n  setGrouping: (grouping: GroupingState) => void;\n  setExpanded: (expanded: ExpandedState) => void;\n  toggleRowSelection: (rowId: string, select?: boolean) => void;\n  toggleAllRowsSelection: (select?: boolean) => void;\n  resetRowSelection: () => void;\n  // Pagination info (1-based for UI)\n  paginationInfo?: {\n    currentPage: number;\n    pageSize: number;\n    pages: number;\n    from: number;\n    to: number;\n    total: number;\n  };\n  // Row key function\n  getRowKey: (record: T, index: number) => string;\n  // Sort descriptor for UI\n  sortDescriptor?: SortDescriptor;\n  // Page change handlers (for pagination UI)\n  handlePageChange?: (nextPage: number) => void;\n  handlePageSizeChange?: (nextPageSize: number) => void;\n  handleSortChange?: (sort: SortDescriptor) => void;\n}\n\n// Convert column definition to TanStack format\nfunction convertToTanStackColumn<T>(\n  column: IBaseTableCoreColumn<T>,\n): ColumnDef<T> {\n  const accessorKey =\n    typeof column.dataIndex === \"string\" ? column.dataIndex : column.key;\n  const useAccessorKey = accessorKey !== column.key;\n\n  const headerValue = column.title || column.label || column.key;\n  const headerFn =\n    typeof headerValue === \"string\" || typeof headerValue === \"number\"\n      ? () => String(headerValue)\n      : () => headerValue;\n\n  const columnDef: ColumnDef<T> = {\n    id: column.key,\n    ...(useAccessorKey && typeof accessorKey === \"string\"\n      ? { accessorKey }\n      : {}),\n    header: headerFn,\n    cell: ({ row, getValue }) => {\n      if (column.render) {\n        return column.render(getValue(), row.original, row.index);\n      }\n\n      return getValue() ?? null;\n    },\n    enableSorting: column.sortable ?? column.enableSorting ?? false,\n    enablePinning: column.enablePinning ?? !!column.fixed,\n    enableResizing: column.enableResizing ?? column.isResizable ?? false,\n    size: column.width,\n    minSize: column.minWidth,\n    maxSize: column.maxWidth,\n    meta: {\n      ...column.meta,\n      align: column.align || \"start\",\n      fixed: column.fixed,\n      isDraggable: column.isDraggable,\n      originalHeader: headerValue,\n    },\n  };\n\n  return columnDef;\n}\n\n// Convert SortDescriptor to TanStack SortingState\nfunction convertToTanStackSorting(sort?: SortDescriptor): SortingState {\n  if (!sort || !sort.column) return [];\n\n  return [\n    {\n      id: String(sort.column),\n      desc: sort.direction === \"descending\",\n    },\n  ];\n}\n\n// Convert TanStack SortingState to SortDescriptor\nfunction convertFromTanStackSorting(\n  sorting: SortingState,\n): SortDescriptor | undefined {\n  if (sorting.length === 0) return undefined;\n\n  const firstSort = sorting[0];\n\n  return {\n    column: firstSort.id,\n    direction: firstSort.desc ? \"descending\" : \"ascending\",\n  };\n}\n\nexport function useIBaseTableCore<T = any>(\n  props: IBaseTableCoreProps<T>,\n): IBaseTableCoreReturn<T> {\n  const {\n    data,\n    columns,\n    rowKey = \"id\",\n    pagination = false,\n    manualPagination = false,\n    sorting,\n    manualSorting = false,\n    enableSorting = true,\n    rowSelection = false,\n    enableColumnResizing = true,\n    enableColumnPinning = true,\n    enableColumnVisibility = false,\n    enableColumnOrdering = false,\n    enableGrouping = false,\n    grouping,\n    onGroupingChange,\n    expanded,\n    onExpandedChange,\n    onRowSelectionChange,\n    onColumnOrderChange,\n    onChangeTable,\n  } = props;\n\n  // Get row key function\n  const getRowKey = useCallback(\n    (record: T, index: number): string => {\n      if (typeof rowKey === \"function\") {\n        return String(rowKey(record, index));\n      }\n      const key = (record as any)[rowKey];\n\n      return key !== undefined && key !== null ? String(key) : String(index);\n    },\n    [rowKey],\n  );\n\n  // Convert columns to TanStack format - memoize with stable reference\n  const tanStackColumns = useMemo<ColumnDef<T>[]>(() => {\n    return columns.map((col) => convertToTanStackColumn(col));\n  }, [columns]);\n\n  // Memoize column keys for columnOrderState initialization\n  const columnKeys = useMemo(() => columns.map((col) => col.key), [columns]);\n\n  // Memoize initial column pinning state\n  const initialColumnPinning = useMemo<ColumnPinningState>(() => {\n    const left: string[] = [];\n    const right: string[] = [];\n\n    columns.forEach((col) => {\n      if (col.fixed === \"left\") {\n        left.push(col.key);\n      } else if (col.fixed === \"right\") {\n        right.push(col.key);\n      }\n    });\n\n    return { left, right };\n  }, [columns]);\n\n  // Pagination state\n  const [paginationState, setPaginationState] = useState<PaginationState>(\n    () => {\n      if (pagination === false) {\n        return { pageIndex: 0, pageSize: PAGINATION_DEFAULT_PAGE_SIZE };\n      }\n\n      return {\n        pageIndex: (pagination?.page ?? 1) - 1, // TanStack uses 0-based index\n        pageSize: pagination?.pageSize ?? PAGINATION_DEFAULT_PAGE_SIZE,\n      };\n    },\n  );\n\n  // Sorting state\n  const [sortingState, setSortingState] = useState<SortingState>(() =>\n    convertToTanStackSorting(sorting),\n  );\n\n  // Row selection state\n  const [rowSelectionState, setRowSelectionState] = useState<RowSelectionState>(\n    () => {\n      if (rowSelection === false) return {};\n\n      const selectedKeys = rowSelection.selectedRowKeys || [];\n      const selectionMap: RowSelectionState = {};\n\n      selectedKeys.forEach((key) => {\n        selectionMap[String(key)] = true;\n      });\n\n      return selectionMap;\n    },\n  );\n\n  // Column pinning state (for frozen columns)\n  const [columnPinningState, setColumnPinningState] =\n    useState<ColumnPinningState>(() => initialColumnPinning);\n\n  // Column sizing state\n  const [columnSizingState, setColumnSizingState] = useState<ColumnSizingState>(\n    {},\n  );\n\n  // Column visibility state\n  const [columnVisibilityState, setColumnVisibilityState] =\n    useState<VisibilityState>({});\n\n  // Column ordering state (for drag & drop) - sync with column keys changes\n  const [columnOrderState, setColumnOrderState] = useState<ColumnOrderState>(\n    () => columnKeys,\n  );\n\n  // Sync column order when columns change\n  useEffect(() => {\n    setColumnOrderState((prev) => {\n      const currentKeys = new Set(prev);\n      const newKeys = new Set(columnKeys);\n\n      // Check if order changed\n      if (\n        prev.length !== columnKeys.length ||\n        !columnKeys.every((key) => currentKeys.has(key)) ||\n        !prev.every((key) => newKeys.has(key))\n      ) {\n        // Merge: keep existing order for existing columns, add new ones at end\n        const merged: string[] = [];\n        const existingSet = new Set(prev);\n\n        // Keep existing order\n        prev.forEach((key) => {\n          if (newKeys.has(key)) {\n            merged.push(key);\n            existingSet.delete(key);\n          }\n        });\n\n        // Add new columns at end\n        columnKeys.forEach((key) => {\n          if (\n            !existingSet.has(key) &&\n            newKeys.has(key) &&\n            !merged.includes(key)\n          ) {\n            merged.push(key);\n          }\n        });\n\n        return merged.length > 0 ? merged : columnKeys;\n      }\n\n      return prev;\n    });\n  }, [columnKeys]);\n\n  // Grouping state\n  const [groupingState, setGroupingState] = useState<GroupingState>(\n    () => grouping || [],\n  );\n\n  // Expanded state (for grouped rows)\n  const [expandedState, setExpandedState] = useState<ExpandedState>(\n    () => expanded || {},\n  );\n\n  // Sync external sorting changes - memoize conversion\n  const externalSortingState = useMemo(\n    () => (sorting !== undefined ? convertToTanStackSorting(sorting) : null),\n    [sorting],\n  );\n\n  useEffect(() => {\n    if (externalSortingState !== null) {\n      setSortingState((prev) => {\n        // Only update if different\n        if (\n          prev.length !== externalSortingState.length ||\n          (prev.length > 0 &&\n            (prev[0].id !== externalSortingState[0].id ||\n              prev[0].desc !== externalSortingState[0].desc))\n        ) {\n          // Also update currentSort to keep it in sync\n          const sortDescriptor =\n            convertFromTanStackSorting(externalSortingState);\n\n          setCurrentSort(sortDescriptor);\n\n          return externalSortingState;\n        }\n\n        return prev;\n      });\n    } else {\n      // Reset sort if external sorting becomes undefined/null\n      setCurrentSort(undefined);\n    }\n  }, [externalSortingState]);\n\n  // Sync external grouping changes - only update if different\n  useEffect(() => {\n    if (grouping !== undefined) {\n      setGroupingState((prev) => {\n        const prevStr = JSON.stringify(prev);\n        const newStr = JSON.stringify(grouping);\n\n        if (prevStr !== newStr) {\n          return grouping;\n        }\n\n        return prev;\n      });\n    }\n  }, [grouping]);\n\n  // Sync external expanded changes - only update if different\n  useEffect(() => {\n    if (expanded !== undefined) {\n      setExpandedState((prev) => {\n        const prevStr = JSON.stringify(prev);\n        const newStr = JSON.stringify(expanded);\n\n        if (prevStr !== newStr) {\n          return expanded;\n        }\n\n        return prev;\n      });\n    }\n  }, [expanded]);\n\n  // Track current sort for onChangeTable callback\n  const [currentSort, setCurrentSort] = useState<SortDescriptor | undefined>(\n    sorting,\n  );\n\n  // Memoize handlers to prevent recreation\n  const handlePaginationChange = useCallback(\n    (newPagination: PaginationState) => {\n      const page = newPagination.pageIndex + 1;\n      const pageSize = newPagination.pageSize;\n\n      if (onChangeTable) {\n        onChangeTable({\n          page: page,\n          pageSize: pageSize,\n          sort: currentSort ?? undefined,\n        });\n      }\n      setPaginationState({\n        pageIndex: newPagination.pageIndex,\n        pageSize: newPagination.pageSize,\n      });\n    },\n    [onChangeTable, currentSort],\n  );\n\n  const handleSortingChange = useCallback(\n    (updater: any) => {\n      console.log(\"handleSortingChange\", updater);\n      setSortingState((prev) => {\n        const newSorting =\n          typeof updater === \"function\" ? updater(prev) : updater;\n\n        const sortDescriptor = convertFromTanStackSorting(newSorting);\n\n        setCurrentSort(sortDescriptor);\n        if (onChangeTable) {\n          onChangeTable({\n            page: 0,\n            pageSize: paginationState.pageSize,\n            sort: sortDescriptor ?? undefined,\n          });\n        }\n\n        return newSorting;\n      });\n    },\n    [onChangeTable, pagination],\n  );\n\n  const handleRowSelectionChange = useCallback(\n    (updater: any) => {\n      setRowSelectionState((prev) => {\n        const newSelection =\n          typeof updater === \"function\" ? updater(prev) : updater;\n\n        if (onRowSelectionChange) {\n          const selectedKeys = Object.keys(newSelection).filter(\n            (key) => newSelection[key],\n          );\n          const selectedRows = data.filter((item, index) =>\n            selectedKeys.includes(getRowKey(item, index)),\n          );\n\n          onRowSelectionChange(selectedKeys, selectedRows);\n        }\n\n        return newSelection;\n      });\n    },\n    [data, getRowKey, onRowSelectionChange],\n  );\n\n  const handleColumnOrderChange = useCallback(\n    (updater: any) => {\n      setColumnOrderState((prev) => {\n        const newOrder =\n          typeof updater === \"function\" ? updater(prev) : updater;\n\n        if (onColumnOrderChange) {\n          onColumnOrderChange(newOrder);\n        }\n\n        return newOrder;\n      });\n    },\n    [onColumnOrderChange],\n  );\n\n  const handleGroupingChange = useCallback(\n    (updater: any) => {\n      setGroupingState((prev) => {\n        const newGrouping =\n          typeof updater === \"function\" ? updater(prev) : updater;\n\n        if (onGroupingChange) {\n          onGroupingChange(newGrouping);\n        }\n\n        return newGrouping;\n      });\n    },\n    [onGroupingChange],\n  );\n\n  const handleExpandedChange = useCallback(\n    (updater: any) => {\n      setExpandedState((prev) => {\n        const newExpanded =\n          typeof updater === \"function\" ? updater(prev) : updater;\n\n        if (onExpandedChange) {\n          onExpandedChange(newExpanded);\n        }\n\n        return newExpanded;\n      });\n    },\n    [onExpandedChange],\n  );\n\n  // Memoize state object to prevent unnecessary re-renders\n  const tableState = useMemo(\n    () => ({\n      rowSelection: rowSelectionState,\n      columnPinning: columnPinningState,\n      columnSizing: enableColumnResizing ? columnSizingState : {},\n      columnVisibility: enableColumnVisibility ? columnVisibilityState : {},\n      columnOrder: enableColumnOrdering ? columnOrderState : undefined,\n      grouping: enableGrouping ? groupingState : undefined,\n      expanded: enableGrouping ? expandedState : undefined,\n    }),\n    [\n      paginationState,\n      sortingState,\n      rowSelectionState,\n      columnPinningState,\n      enableColumnResizing,\n      columnSizingState,\n      enableColumnVisibility,\n      columnVisibilityState,\n      enableColumnOrdering,\n      columnOrderState,\n      enableGrouping,\n      groupingState,\n      expandedState,\n    ],\n  );\n\n  // Memoize pageCount calculation\n  const pageCount = useMemo(() => {\n    if (pagination && typeof pagination === \"object\" && pagination.total) {\n      return Math.ceil(pagination.total / paginationState.pageSize);\n    }\n\n    return undefined;\n  }, [pagination, paginationState.pageSize]);\n\n  // Create TanStack Table instance\n  const table = useReactTable({\n    data,\n    columns: tanStackColumns,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: manualPagination\n      ? undefined\n      : getPaginationRowModel(),\n    getSortedRowModel: manualSorting ? undefined : getSortedRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getGroupedRowModel: enableGrouping ? getGroupedRowModel() : undefined,\n    getExpandedRowModel: enableGrouping ? getExpandedRowModel() : undefined,\n\n    // State\n    state: tableState,\n\n    // Pagination\n    manualPagination,\n    pageCount,\n\n    // Sorting\n    manualSorting,\n    enableSorting,\n\n    // Selection\n    enableRowSelection: rowSelection !== false,\n    getRowId: getRowKey,\n\n    // Column features\n    enableColumnResizing,\n    enableColumnPinning,\n\n    // Grouping\n    enableGrouping,\n    manualExpanding: false, // TODO: support manual expanding if needed\n\n    // Handlers - use memoized callbacks\n    // Enable onPaginationChange for manual pagination to allow internal state updates\n    // onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    onRowSelectionChange: handleRowSelectionChange,\n    onColumnPinningChange: setColumnPinningState,\n    onColumnSizingChange: setColumnSizingState,\n    onColumnVisibilityChange: setColumnVisibilityState,\n    onColumnOrderChange: handleColumnOrderChange,\n    onGroupingChange: handleGroupingChange,\n    onExpandedChange: handleExpandedChange,\n  });\n\n  // Computed values - memoize to prevent recalculation\n  const rows = table.getRowModel().rows;\n  const headerGroups = useMemo(() => table.getHeaderGroups(), [table]);\n  const visibleColumns = useMemo(() => table.getVisibleLeafColumns(), [table]);\n\n  const selectedRowKeys = useMemo(() => {\n    return Object.keys(rowSelectionState).filter(\n      (key) => rowSelectionState[key],\n    );\n  }, [rowSelectionState]);\n\n  // Optimize selectedRows calculation with Map for O(1) lookup\n  const selectedRows = useMemo(() => {\n    if (selectedRowKeys.length === 0) return [];\n\n    const selectedKeySet = new Set(selectedRowKeys);\n    const result: T[] = [];\n\n    for (const row of rows) {\n      if (selectedKeySet.has(row.id)) {\n        result.push(row.original);\n      }\n    }\n\n    return result;\n  }, [rows, selectedRowKeys]);\n\n  // Handlers\n  const toggleRowSelection = useCallback((rowId: string, select?: boolean) => {\n    setRowSelectionState((prev) => {\n      const current = prev[rowId] ?? false;\n      const next = select !== undefined ? select : !current;\n\n      if (next === current) return prev;\n\n      return { ...prev, [rowId]: next };\n    });\n  }, []);\n\n  const toggleAllRowsSelection = useCallback(\n    (select?: boolean) => {\n      setRowSelectionState((prev) => {\n        const allSelected = rows.every((row) => prev[row.id]);\n        const next = select !== undefined ? select : !allSelected;\n\n        const newSelection: RowSelectionState = {};\n\n        rows.forEach((row) => {\n          newSelection[row.id] = next;\n        });\n\n        return newSelection;\n      });\n    },\n    [rows],\n  );\n\n  const resetRowSelection = useCallback(() => {\n    setRowSelectionState({});\n  }, []);\n\n  // Pagination info for UI (1-based)\n  const paginationInfo = useMemo(() => {\n    if (!pagination || typeof pagination !== \"object\") return undefined;\n\n    const currentPage = paginationState.pageIndex + 1;\n    const pageSize = paginationState.pageSize;\n    const total = pagination.total ?? 0;\n    const pages = Math.max(1, Math.ceil(total / pageSize));\n    const from = total === 0 ? 0 : paginationState.pageIndex * pageSize;\n    const to = total === 0 ? 0 : Math.min(total, from + pageSize);\n\n    return {\n      currentPage,\n      pageSize,\n      pages,\n      from,\n      to,\n      total,\n    };\n  }, [pagination, paginationState]);\n\n  // Sort descriptor for UI\n  const sortDescriptor = useMemo<SortDescriptor | undefined>(() => {\n    return convertFromTanStackSorting(sortingState);\n  }, [sortingState]);\n\n  // Handle page change (for pagination UI components)\n  const handlePageChange = useCallback(\n    (nextPage: number) => {\n      if (!pagination || typeof pagination !== \"object\") return;\n\n      const pages = paginationInfo?.pages ?? 1;\n      const adjustedPage = Math.min(Math.max(1, nextPage), pages);\n\n      handlePaginationChange({\n        pageIndex: adjustedPage - 1,\n        pageSize: paginationState.pageSize,\n      });\n    },\n    [\n      pagination,\n      paginationInfo,\n      paginationState.pageSize,\n      handlePaginationChange,\n    ],\n  );\n\n  // Handle page size change\n  const handlePageSizeChange = useCallback(\n    (nextPageSize: number) => {\n      if (!pagination || typeof pagination !== \"object\") return;\n\n      handlePaginationChange({\n        pageIndex: 0,\n        pageSize: nextPageSize,\n      });\n    },\n    [pagination, handlePaginationChange],\n  );\n\n  // Handle sort change (for UI components)\n  const handleSortChange = useCallback(\n    (sort: SortDescriptor) => {\n      handleSortingChange([\n        {\n          id: String(sort.column),\n          desc: sort.direction === \"descending\",\n        },\n      ]);\n    },\n    [handleSortingChange],\n  );\n\n  return {\n    table,\n    paginationState,\n    sortingState,\n    rowSelectionState,\n    columnPinningState,\n    columnSizingState,\n    columnVisibilityState,\n    columnOrderState,\n    groupingState,\n    expandedState,\n    rows,\n    headerGroups,\n    visibleColumns,\n    selectedRows,\n    selectedRowKeys,\n    paginationInfo,\n    getRowKey,\n    sortDescriptor,\n    setRowSelection: setRowSelectionState,\n    setColumnOrder: handleColumnOrderChange,\n    setGrouping: handleGroupingChange,\n    setExpanded: handleExpandedChange,\n    toggleRowSelection,\n    toggleAllRowsSelection,\n    resetRowSelection,\n    handlePageChange,\n    handlePageSizeChange,\n    handleSortChange,\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/IBaseTableInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/IBaseTableUI.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·Table,·TableBody,·TableCell,·TableColumn,·TableHeader,·TableRow·` with `⏎··Table,⏎··TableBody,⏎··TableCell,⏎··TableColumn,⏎··TableHeader,⏎··TableRow,⏎`","line":8,"column":9,"nodeType":null,"messageId":"replace","endLine":8,"endColumn":74,"fix":{"range":[243,308],"text":"\n  Table,\n  TableBody,\n  TableCell,\n  TableColumn,\n  TableHeader,\n  TableRow,\n"}},{"ruleId":"jsx-a11y/click-events-have-key-events","severity":1,"message":"Visible, non-interactive elements with click handlers must have at least one keyboard listener.","line":191,"column":19,"nodeType":"JSXOpeningElement","endLine":199,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { SortDescriptor, TableProps } from \"@heroui/table\";\nimport type { Column, HeaderGroup, Row } from \"@tanstack/react-table\";\nimport type { ReactNode } from \"react\";\n\nimport { Spinner } from \"@heroui/spinner\";\nimport { Table, TableBody, TableCell, TableColumn, TableHeader, TableRow } from \"@heroui/table\";\nimport { flexRender } from \"@tanstack/react-table\";\nimport clsx from \"clsx\";\nimport { ChevronDown, ChevronUp, ChevronsUpDown } from \"lucide-react\";\nimport { useCallback, useMemo } from \"react\";\n\nexport interface IBaseTableUIProps<T = any> {\n  // TanStack Table data\n  headerGroups: HeaderGroup<T>[];\n  rows: Row<T>[];\n  visibleColumns: Column<T, unknown>[];\n\n  // UI Props\n  loading?: boolean;\n  emptyContent?: ReactNode;\n  classNames?: {\n    wrapper?: string;\n    table?: string;\n    thead?: string;\n    tbody?: string;\n    tr?: string;\n    th?: string;\n    td?: string;\n  };\n  tableLayout?: \"auto\" | \"fixed\";\n  color?: TableProps[\"color\"];\n  isStriped?: boolean;\n  isCompact?: boolean;\n  isHeaderSticky?: boolean;\n\n  // Selection\n  selectionMode?: TableProps[\"selectionMode\"];\n  selectedKeys?: TableProps[\"selectedKeys\"];\n  onSelectionChange?: TableProps[\"onSelectionChange\"];\n\n  // Sorting\n  sortDescriptor?: SortDescriptor;\n  onSortChange?: (sort: SortDescriptor) => void;\n\n  // Column configuration\n  getRowKey: (record: T, index: number) => string;\n  renderCell?: (\n    column: Column<T, unknown>,\n    row: Row<T>,\n    value: any,\n  ) => ReactNode;\n  renderHeader?: (\n    header: HeaderGroup<T>,\n    column: Column<T, unknown>,\n  ) => ReactNode;\n}\n\n// Memoize sort icons to prevent recreation\nconst sortIcons = {\n  default: <ChevronsUpDown aria-hidden className=\"h-3.5 w-3.5 opacity-70\" />,\n  ascending: <ChevronUp aria-hidden className=\"h-3.5 w-3.5 opacity-90\" />,\n  descending: <ChevronDown aria-hidden className=\"h-3.5 w-3.5 opacity-90\" />,\n} as const;\n\nexport default function IBaseTableUI<T = any>({\n  headerGroups,\n  rows,\n  visibleColumns,\n  loading = false,\n  emptyContent = \"No data available\",\n  classNames = {},\n  tableLayout = \"auto\",\n  color = \"primary\",\n  isStriped = true,\n  isCompact = true,\n  isHeaderSticky = true,\n  selectionMode,\n  selectedKeys,\n  onSelectionChange,\n  sortDescriptor,\n  onSortChange,\n  getRowKey,\n  renderCell,\n  renderHeader,\n}: IBaseTableUIProps<T>) {\n  // Memoize sort icon getter\n  const getSortIcon = useCallback(\n    (columnId: string) => {\n      if (!sortDescriptor || sortDescriptor.column !== columnId) {\n        return sortIcons.default;\n      }\n\n      return sortDescriptor.direction === \"ascending\"\n        ? sortIcons.ascending\n        : sortIcons.descending;\n    },\n    [sortDescriptor],\n  );\n\n  // Memoize header click handler\n  const handleHeaderClick = useCallback(\n    (column: Column<T, unknown>) => {\n      if (!column.getCanSort() || !onSortChange) return;\n\n      const columnId = column.id;\n      const isSameColumn = sortDescriptor?.column === columnId;\n      const nextDirection =\n        !isSameColumn || sortDescriptor?.direction === \"descending\"\n          ? \"ascending\"\n          : \"descending\";\n\n      onSortChange({\n        column: columnId,\n        direction: nextDirection,\n      });\n    },\n    [sortDescriptor, onSortChange],\n  );\n\n  // Memoize classNames to prevent object recreation\n  const memoizedClassNames = useMemo(\n    () => ({\n      ...classNames,\n      tbody: clsx(\"overflow-x-auto\", classNames.tbody),\n      wrapper: clsx(\"rounded-none p-0\", classNames.wrapper),\n      th: clsx(\n        \"px-0 bg-primary-600 text-white hover:bg-primary-700/80\",\n        classNames.th,\n      ),\n      tr: clsx(\"hover:bg-primary-700/10\", classNames.tr),\n      td: clsx(\"rounded-none py-1 px-2\", classNames.td),\n    }),\n    [classNames],\n  );\n\n  // Create column lookup map for O(1) access - memoize to prevent recreation\n  const columnMap = useMemo(\n    () => new Map(visibleColumns.map((col) => [col.id, col])),\n    [visibleColumns],\n  );\n\n  return (\n    <Table\n      aria-label=\"Data table\"\n      classNames={memoizedClassNames}\n      color={color}\n      isCompact={isCompact}\n      isHeaderSticky={isHeaderSticky}\n      isStriped={isStriped}\n      layout={tableLayout}\n      selectedKeys={selectedKeys}\n      selectionMode={selectionMode}\n      onSelectionChange={onSelectionChange}\n    >\n      <TableHeader>\n        {headerGroups.flatMap((headerGroup) =>\n          headerGroup.headers.map((header) => {\n            const column = columnMap.get(header.id);\n            const meta = (column?.columnDef?.meta as Record<string, any>) || {};\n            const isSortable = header.column.getCanSort();\n            const isPinned = header.column.getIsPinned();\n            const pinStyle = isPinned\n              ? {\n                  position: \"sticky\" as const,\n                  [isPinned === \"left\" ? \"left\" : \"right\"]:\n                    header.column.getStart(isPinned),\n                  zIndex: 10,\n                }\n              : undefined;\n\n            return (\n              <TableColumn\n                key={header.id}\n                align={meta.align || \"start\"}\n                allowsSorting={false}\n                className={clsx(\n                  isPinned && \"frozen-column\",\n                  isPinned === \"left\" && \"frozen-left\",\n                  isPinned === \"right\" && \"frozen-right\",\n                )}\n                maxWidth={column?.columnDef.maxSize}\n                minWidth={column?.columnDef.minSize}\n                style={pinStyle}\n                width={column?.getSize()}\n              >\n                {renderHeader ? (\n                  renderHeader(headerGroup, column!)\n                ) : (\n                  <div\n                    className={clsx(\n                      \"inline-flex h-full w-full items-center\",\n                      isSortable && \"cursor-pointer select-none\",\n                    )}\n                    role={isSortable ? \"button\" : undefined}\n                    tabIndex={isSortable ? 0 : -1}\n                    onClick={() => handleHeaderClick(header.column)}\n                  >\n                    <span\n                      className={clsx(\n                        \"inline-flex w-full items-center px-2\",\n                        meta.align === \"end\"\n                          ? \"justify-end\"\n                          : meta.align === \"center\"\n                            ? \"justify-center\"\n                            : \"justify-start\",\n                      )}\n                    >\n                      {flexRender(\n                        header.column.columnDef.header,\n                        header.getContext(),\n                      )}\n                      {isSortable && (\n                        <span className=\"ml-2 inline-flex items-center justify-end\">\n                          {getSortIcon(header.id)}\n                        </span>\n                      )}\n                    </span>\n                  </div>\n                )}\n              </TableColumn>\n            );\n          }),\n        )}\n      </TableHeader>\n      <TableBody\n        emptyContent={emptyContent}\n        isLoading={loading}\n        items={useMemo(\n          () =>\n            rows.map((row) => ({\n              row,\n              original: row.original,\n              index: row.index,\n            })),\n          [rows],\n        )}\n        loadingContent={<Spinner label=\"Loading...\" />}\n      >\n        {({\n          row,\n          original,\n          index,\n        }: {\n          row: Row<T>;\n          original: T;\n          index: number;\n        }) => {\n          const rowKey = getRowKey(original, index);\n\n          return (\n            <TableRow key={rowKey}>\n              {row.getVisibleCells().map((cell) => {\n                const column = columnMap.get(cell.column.id);\n                const meta =\n                  (column?.columnDef?.meta as Record<string, any>) || {};\n                const isPinned = cell.column.getIsPinned();\n                const pinStyle = isPinned\n                  ? {\n                      position: \"sticky\" as const,\n                      [isPinned === \"left\" ? \"left\" : \"right\"]:\n                        cell.column.getStart(isPinned),\n                      zIndex: 10,\n                    }\n                  : undefined;\n\n                return (\n                  <TableCell\n                    key={cell.id}\n                    className={clsx(\n                      isPinned && \"frozen-column\",\n                      isPinned === \"left\" && \"frozen-left\",\n                      isPinned === \"right\" && \"frozen-right\",\n                    )}\n                    style={pinStyle}\n                  >\n                    <div\n                      className={clsx(\n                        \"flex\",\n                        `justify-${meta.align || \"start\"}`,\n                      )}\n                    >\n                      {renderCell\n                        ? (() => {\n                            const customRender = renderCell(\n                              column!,\n                              row,\n                              cell.getValue(),\n                            );\n\n                            return customRender !== null &&\n                              customRender !== undefined\n                              ? customRender\n                              : flexRender(\n                                  cell.column.columnDef.cell,\n                                  cell.getContext(),\n                                );\n                          })()\n                        : flexRender(\n                            cell.column.columnDef.cell,\n                            cell.getContext(),\n                          )}\n                    </div>\n                  </TableCell>\n                );\n              })}\n            </TableRow>\n          );\n        }}\n      </TableBody>\n    </Table>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/components/TablePrimitives.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/hooks/useColumns.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/hooks/useIBaseTablePagination.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTable/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTabs/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":27,"column":4,"nodeType":null,"messageId":"insert","endLine":27,"endColumn":4,"fix":{"range":[842,842],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Tab, Tabs as TabsPrimitive, TabsProps } from \"@heroui/tabs\";\nimport clsx from \"clsx\";\nimport React from \"react\";\n\nexport type IBaseTabsProps = TabsProps;\n\nexport const IBaseTabs = React.forwardRef<HTMLDivElement, TabsProps>(\n  (props, ref) => {\n    const { classNames, size = \"sm\", variant = \"bordered\", ...rest } = props;\n\n    return (\n      <TabsPrimitive\n        {...rest}\n        ref={ref}\n        classNames={{\n          base: clsx(\"w-full mb-0\", classNames?.base),\n          tabList: clsx(\"gap-0 overflow-x-auto mb-0\", classNames?.tabList),\n          tab: clsx(\"max-w-[80px]\", classNames?.tab),\n          tabContent: clsx(\"max-w-[120px]\", classNames?.tabContent),\n          panel: clsx(\"p-1\", classNames?.panel),\n          cursor: classNames?.cursor,\n        }}\n        size={size}\n        variant={variant}\n      />\n    );\n  }\n);\n\nIBaseTabs.displayName = \"IBaseTabs\";\n\nexport const IBaseTab = Tab;\n\nexport default IBaseTabs;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTextarea/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `HTMLTextAreaElement,·IBaseTextareaProps>(⏎··` with `⏎··HTMLTextAreaElement,⏎··IBaseTextareaProps⏎>(`","line":9,"column":47,"nodeType":null,"messageId":"replace","endLine":10,"endColumn":3,"fix":{"range":[287,331],"text":"\n  HTMLTextAreaElement,\n  IBaseTextareaProps\n>("}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `····` with `··`","line":11,"column":1,"nodeType":null,"messageId":"replace","endLine":11,"endColumn":5,"fix":{"range":[349,353],"text":"  "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":12,"column":3,"nodeType":null,"messageId":"delete","endLine":12,"endColumn":5,"fix":{"range":[405,407],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":13,"column":1,"nodeType":null,"messageId":"delete","endLine":13,"endColumn":3,"fix":{"range":[415,417],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":14,"column":5,"nodeType":null,"messageId":"delete","endLine":14,"endColumn":7,"fix":{"range":[437,439],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":15,"column":1,"nodeType":null,"messageId":"delete","endLine":15,"endColumn":3,"fix":{"range":[452,454],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":16,"column":5,"nodeType":null,"messageId":"delete","endLine":16,"endColumn":7,"fix":{"range":[490,492],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `······` with `····`","line":17,"column":1,"nodeType":null,"messageId":"replace","endLine":17,"endColumn":7,"fix":{"range":[505,511],"text":"    "}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `······` with `····`","line":18,"column":1,"nodeType":null,"messageId":"replace","endLine":18,"endColumn":7,"fix":{"range":[524,530],"text":"    "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":19,"column":1,"nodeType":null,"messageId":"delete","endLine":19,"endColumn":3,"fix":{"range":[538,540],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":20,"column":1,"nodeType":null,"messageId":"delete","endLine":20,"endColumn":3,"fix":{"range":[553,555],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":22,"column":3,"nodeType":null,"messageId":"delete","endLine":22,"endColumn":5,"fix":{"range":[605,607],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":23,"column":1,"nodeType":null,"messageId":"delete","endLine":23,"endColumn":3,"fix":{"range":[616,618],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `········` with `······`","line":24,"column":1,"nodeType":null,"messageId":"replace","endLine":24,"endColumn":9,"fix":{"range":[638,646],"text":"      "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":25,"column":1,"nodeType":null,"messageId":"delete","endLine":25,"endColumn":3,"fix":{"range":[656,658],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `··········` with `········`","line":26,"column":1,"nodeType":null,"messageId":"replace","endLine":26,"endColumn":11,"fix":{"range":[678,688],"text":"        "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":27,"column":1,"nodeType":null,"messageId":"delete","endLine":27,"endColumn":3,"fix":{"range":[715,717],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":28,"column":1,"nodeType":null,"messageId":"delete","endLine":28,"endColumn":3,"fix":{"range":[763,765],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":29,"column":11,"nodeType":null,"messageId":"delete","endLine":29,"endColumn":13,"fix":{"range":[802,804],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":30,"column":1,"nodeType":null,"messageId":"delete","endLine":30,"endColumn":3,"fix":{"range":[826,828],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `··········` with `········`","line":31,"column":1,"nodeType":null,"messageId":"replace","endLine":31,"endColumn":11,"fix":{"range":[874,884],"text":"        "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":32,"column":1,"nodeType":null,"messageId":"delete","endLine":32,"endColumn":3,"fix":{"range":[887,889],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":33,"column":7,"nodeType":null,"messageId":"delete","endLine":33,"endColumn":9,"fix":{"range":[957,959],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":34,"column":1,"nodeType":null,"messageId":"delete","endLine":34,"endColumn":3,"fix":{"range":[962,964],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":35,"column":1,"nodeType":null,"messageId":"delete","endLine":35,"endColumn":3,"fix":{"range":[1002,1004],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":36,"column":7,"nodeType":null,"messageId":"delete","endLine":36,"endColumn":9,"fix":{"range":[1034,1036],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":37,"column":7,"nodeType":null,"messageId":"delete","endLine":37,"endColumn":9,"fix":{"range":[1090,1092],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `········` with `······`","line":38,"column":1,"nodeType":null,"messageId":"replace","endLine":38,"endColumn":9,"fix":{"range":[1104,1112],"text":"      "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":39,"column":7,"nodeType":null,"messageId":"delete","endLine":39,"endColumn":9,"fix":{"range":[1137,1139],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `········` with `······`","line":40,"column":1,"nodeType":null,"messageId":"replace","endLine":40,"endColumn":9,"fix":{"range":[1149,1157],"text":"      "}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":41,"column":5,"nodeType":null,"messageId":"delete","endLine":41,"endColumn":7,"fix":{"range":[1185,1187],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `··`","line":42,"column":1,"nodeType":null,"messageId":"delete","endLine":42,"endColumn":3,"fix":{"range":[1190,1192],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `··},⏎` with `}`","line":43,"column":1,"nodeType":null,"messageId":"replace","endLine":44,"endColumn":1,"fix":{"range":[1197,1202],"text":"}"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":33,"source":"\"use client\";\n\nimport { Textarea as HeroUITextarea, TextAreaProps } from \"@heroui/input\";\nimport clsx from \"clsx\";\nimport { useTranslations } from \"next-intl\";\nimport React from \"react\";\n\nexport type IBaseTextareaProps = TextAreaProps & {};\nexport const IBaseTextarea = React.forwardRef<HTMLTextAreaElement, IBaseTextareaProps>(\n  (props, ref) => {\n    const t = useTranslations(\"components.textarea\");\n    const {\n      isDisabled,\n      size = \"sm\",\n      labelPlacement = \"outside\",\n      placeholder,\n      minRows = 3,\n      ...rest\n    } = props;\n    const defaultPlaceholder = t(\"placeholder\");\n\n    return (\n      <HeroUITextarea\n        ref={ref}\n        classNames={{\n          base: \"max-w opacity-100\",\n          label: \"text-small text-default-600\",\n          mainWrapper: clsx(\n            \"cursor-not-allowed\",\n            isDisabled ? \"bg-default-200\" : \"\",\n          ),\n          input: \"placeholder:text-default-400 italic text-sm\",\n        }}\n        labelPlacement={labelPlacement}\n        minRows={minRows}\n        placeholder={placeholder ?? defaultPlaceholder}\n        size={size}\n        variant=\"bordered\"\n        {...rest}\n        isDisabled={isDisabled}\n      />\n    );\n  },\n);\n\nIBaseTextarea.displayName = \"IBaseTextarea\";\n\nexport default IBaseTextarea;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseTooltip/index.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":25,"column":4,"nodeType":null,"messageId":"insert","endLine":25,"endColumn":4,"fix":{"range":[710,710],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Tooltip, TooltipProps } from \"@heroui/tooltip\";\nimport clsx from \"clsx\";\nimport React from \"react\";\n\nexport type IBaseTooltipProps = TooltipProps & {};\n\nexport const IBaseTooltip = React.forwardRef<HTMLDivElement, IBaseTooltipProps>(\n  (props, ref) => {\n    const { placement = \"top\", showArrow = true, classNames, ...rest } = props;\n\n    return (\n      <Tooltip\n        ref={ref}\n        classNames={{\n          base: clsx(\"bg-primary-400/80 backdrop-blur-sm\", classNames?.base),\n          content: clsx(\"text-white/90\", classNames?.content),\n          ...classNames,\n        }}\n        color=\"primary\"\n        placement={placement}\n        showArrow={showArrow}\n        {...rest}\n      />\n    );\n  }\n);\n\nIBaseTooltip.displayName = \"IBaseTooltip\";\n\nexport default IBaseTooltip;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageDrag/IBaseUploadImageDrag.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":57,"column":15,"nodeType":null,"messageId":"insert","endLine":57,"endColumn":15,"fix":{"range":[1794,1794],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":85,"column":45,"nodeType":null,"messageId":"insert","endLine":85,"endColumn":45,"fix":{"range":[2591,2591],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":88,"column":44,"nodeType":null,"messageId":"insert","endLine":88,"endColumn":44,"fix":{"range":[2695,2695],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":93,"column":73,"nodeType":null,"messageId":"insert","endLine":93,"endColumn":73,"fix":{"range":[2868,2868],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":105,"column":80,"nodeType":null,"messageId":"insert","endLine":105,"endColumn":80,"fix":{"range":[3246,3246],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":230,"column":73,"nodeType":null,"messageId":"insert","endLine":230,"endColumn":73,"fix":{"range":[6658,6658],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":239,"column":31,"nodeType":null,"messageId":"insert","endLine":239,"endColumn":31,"fix":{"range":[6862,6862],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":255,"column":41,"nodeType":null,"messageId":"insert","endLine":255,"endColumn":41,"fix":{"range":[7281,7281],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":263,"column":7,"nodeType":null,"messageId":"insert","endLine":263,"endColumn":7,"fix":{"range":[7458,7458],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":9,"source":"\"use client\";\n\nimport { Card, CardBody } from \"@heroui/card\";\nimport { addToast } from \"@heroui/toast\";\nimport { chunk } from \"lodash\";\nimport { Upload } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useRef, useState } from \"react\";\n\nimport { ImageUploadItem } from \"../../interface/ImageUpdload\";\n\nimport ImageUploadItemComponent from \"./IBaseUploadImageDragItem\";\nimport { getFileExtension, normalizeItems, validateFile } from \"./utils\";\n\nexport type IBaseUploadImageDragProps = {\n  accept?: string;\n  maxSize?: number; // in bytes, default 5MB\n  maxCount?: number; // maximum number of images\n  values?: ImageUploadItem[];\n  onChange?: (items: ImageUploadItem[]) => void;\n  uploadService?: (file: File) => Promise<{ id: string }>;\n  isDisabled?: boolean;\n  label?: string;\n};\n\nconst DEFAULT_ACCEPT = \"image/jpeg,image/jpg,image/png\";\nconst DEFAULT_MAX_SIZE = 10 * 1024 * 1024; // 10MB\nconst DEFAULT_MAX_COUNT = 10;\n\nexport default function IBaseUploadImageDrag({\n  accept = DEFAULT_ACCEPT,\n  maxSize = DEFAULT_MAX_SIZE,\n  maxCount = DEFAULT_MAX_COUNT,\n  values = [],\n  onChange,\n  uploadService,\n  isDisabled = false,\n  label,\n}: IBaseUploadImageDragProps) {\n  const t = useTranslations(\"components.uploadImage\");\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const [uploadingItems, setUploadingItems] = useState<Set<string>>(new Set());\n\n  // init items from values\n  const [items, setItems] = useState<ImageUploadItem[]>(() => {\n    if (!values || values.length === 0) return [];\n\n    return normalizeItems(values as ImageUploadItem[]);\n  });\n\n  // Update items when values change\n  const handleItemsChange = useCallback(\n    (newItems: ImageUploadItem[]) => {\n      setItems(newItems);\n      onChange?.(newItems);\n    },\n    [onChange]\n  );\n\n  const handleFileSelect = useCallback(\n    async (files: FileList | null) => {\n      if (!files || files.length === 0) return;\n\n      const fileArray = Array.from(files);\n      const remainingSlots = maxCount - items.length;\n\n      if (fileArray.length > remainingSlots) {\n        addToast({\n          title: t(\"tooManyFiles\"),\n          description: t(\"tooManyFilesDescription\", { count: remainingSlots }),\n          color: \"warning\",\n        });\n\n        return;\n      }\n\n      // Validate all files first\n      const validationResults = fileArray.map((file) => ({\n        file,\n        validation: validateFile(file, accept, maxSize),\n      }));\n\n      // Separate valid and invalid files\n      const invalidFiles = validationResults.filter(\n        (result) => !result.validation.valid\n      );\n      const validFiles = validationResults.filter(\n        (result) => result.validation.valid\n      );\n\n      if (invalidFiles.length > 0) {\n        const invalidNotAllowed = invalidFiles.find(\n          (result) => result.validation.type === \"FILE_TYPE_NOT_ALLOWED\"\n        );\n\n        if (invalidNotAllowed) {\n          addToast({\n            title: t(\"invalidFile\"),\n            description: invalidNotAllowed.validation.error,\n            color: \"danger\",\n          });\n        }\n        const invalidFileSizeExceeded = invalidFiles.find(\n          (result) =>\n            result.validation.type === \"FILE_SIZE_EXCEEDS_MAXIMUM_ALLOWED_SIZE\"\n        );\n\n        if (invalidFileSizeExceeded) {\n          addToast({\n            title: t(\"invalidFile\"),\n            description: invalidFileSizeExceeded.validation.error,\n            color: \"danger\",\n          });\n        }\n      }\n\n      if (validFiles.length === 0) {\n        return;\n      }\n\n      // Create items from valid files (keep reference to original file for upload)\n      const fileItemMap = new Map<string, File>();\n      const newItems: ImageUploadItem[] = validFiles.map(({ file }) => {\n        const extension = getFileExtension(file.name);\n        const uid = `${Date.now()}-${Math.random().toString(36).substring(7)}`;\n\n        fileItemMap.set(uid, file);\n\n        return {\n          uid,\n          name: file.name,\n          size: file.size,\n          extension,\n          blob: file,\n          status: \"idle\",\n        } as ImageUploadItem;\n      });\n\n      // If no upload service, add items immediately\n      if (!uploadService) {\n        handleItemsChange([...items, ...newItems]);\n\n        return;\n      }\n\n      // // Add all items with \"idle\" status first\n      // const allItems = [...items, ...newItems];\n      // handleItemsChange(allItems);\n\n      // Upload files in chunks of 5\n      const CHUNK_SIZE = 5;\n      const chunks = chunk(newItems, CHUNK_SIZE);\n\n      // Upload each chunk sequentially\n      for (const chunk of chunks) {\n        // Mark items as uploading\n        const chunkUids = chunk.map((item) => item.uid);\n\n        setUploadingItems((prev) => {\n          const next = new Set(prev);\n\n          chunkUids.forEach((uid) => next.add(uid));\n\n          return next;\n        });\n\n        // Update status to uploading for current items\n        setItems((currentItems) => {\n          const updated = currentItems.map((item) => {\n            if (chunkUids.includes(item.uid)) {\n              return { ...item, status: \"uploading\" as const };\n            }\n\n            return item;\n          });\n\n          handleItemsChange(updated);\n\n          return updated;\n        });\n\n        // Upload chunk in parallel\n        const uploadPromises = chunk.map(async (item) => {\n          const file = fileItemMap.get(item.uid);\n\n          if (!file) {\n            return {\n              uid: item.uid,\n              success: false,\n              error: \"File not found\",\n            };\n          }\n\n          try {\n            const result = await uploadService(file);\n\n            return {\n              uid: item.uid,\n              id: result.id,\n              success: true,\n            };\n          } catch (error) {\n            return {\n              uid: item.uid,\n              success: false,\n              error:\n                error instanceof Error\n                  ? error.message\n                  : \"Failed to upload image\",\n            };\n          }\n        });\n\n        const uploadResults = await Promise.all(uploadPromises);\n\n        // Update items based on upload results\n\n        const updatedItems = uploadResults.map((result) => {\n          return {\n            ...result,\n            status: result.success ? (\"done\" as const) : (\"error\" as const),\n          };\n        });\n\n        handleItemsChange([...items, ...updatedItems] as ImageUploadItem[]);\n        setItems([...items, ...updatedItems] as ImageUploadItem[]);\n        setUploadingItems(new Set());\n      }\n    },\n    [items, maxCount, accept, maxSize, uploadService, handleItemsChange]\n  );\n\n  const handleRemove = useCallback(\n    (uid: string) => {\n      const newItems = items.filter((item) => item.uid !== uid);\n\n      handleItemsChange(newItems);\n    },\n    [items, handleItemsChange]\n  );\n\n  const canAddMore = items.length < maxCount;\n  const isUploadDisabled = isDisabled || !canAddMore;\n\n  const handleDrop = useCallback(\n    (e: React.DragEvent<HTMLDivElement | HTMLButtonElement>) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (isUploadDisabled) return;\n\n      const files = e.dataTransfer.files;\n\n      handleFileSelect(files);\n    },\n    [isUploadDisabled, handleFileSelect]\n  );\n\n  const handleDragOver = useCallback(\n    (e: React.DragEvent<HTMLDivElement | HTMLButtonElement>) => {\n      e.preventDefault();\n      e.stopPropagation();\n    },\n    []\n  );\n\n  const handleClick = useCallback(() => {\n    if (!isUploadDisabled) {\n      fileInputRef.current?.click();\n    }\n  }, [isUploadDisabled]);\n\n  return (\n    <div className=\"flex flex-col gap-2\">\n      {label && (\n        <label className=\"text-sm font-medium text-foreground\">{label}</label>\n      )}\n\n      <button\n        className={`border-2 border-dashed rounded-lg p-4 transition-colors text-left ${\n          isUploadDisabled\n            ? \"border-default-200 bg-default-50 cursor-not-allowed\"\n            : \"border-default-300 hover:border-primary-400 cursor-pointer bg-default-50\"\n        }`}\n        type=\"button\"\n        onClick={handleClick}\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n      >\n        <input\n          ref={fileInputRef}\n          multiple\n          accept={accept}\n          className=\"hidden\"\n          disabled={isUploadDisabled}\n          type=\"file\"\n          onChange={(e) => handleFileSelect(e.target.files)}\n        />\n\n        <div className=\"flex flex-col items-center justify-center gap-2 py-4 pointer-events-none\">\n          <Upload\n            className={`${isUploadDisabled ? \"text-default-300\" : \"text-default-400\"}`}\n            size={32}\n          />\n          <p\n            className={`text-sm text-center ${isUploadDisabled ? \"text-default-400\" : \"text-default-500\"}`}\n          >\n            {canAddMore\n              ? t(\"clickOrDrag\")\n              : t(\"maxReached\", { count: maxCount })}\n          </p>\n          {canAddMore && (\n            <p className=\"text-xs text-default-400 text-center\">\n              {t(\"accepted\", {\n                types: accept.replace(/image\\//g, \"\").replace(/,/g, \", \"),\n              })}{\" \"}\n              {t(\"maxSize\", { size: (maxSize / (1024 * 1024)).toFixed(0) })}\n            </p>\n          )}\n        </div>\n      </button>\n\n      {items.length > 0 && (\n        <div className=\"flex flex-wrap gap-3 mt-2\">\n          {items.map((item) => (\n            <Card key={item.uid}>\n              <CardBody className=\"p-2\">\n                <ImageUploadItemComponent\n                  isDisabled={isDisabled}\n                  isUploading={uploadingItems.has(item.uid)}\n                  item={item}\n                  onRemove={() => handleRemove(item.uid)}\n                />\n              </CardBody>\n            </Card>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageDrag/IBaseUploadImageDragItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageDrag/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageDrag/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageTiny/IBaseUploadImageTiny.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":65,"column":15,"nodeType":null,"messageId":"insert","endLine":65,"endColumn":15,"fix":{"range":[1893,1893],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":93,"column":45,"nodeType":null,"messageId":"insert","endLine":93,"endColumn":45,"fix":{"range":[2690,2690],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":96,"column":44,"nodeType":null,"messageId":"insert","endLine":96,"endColumn":44,"fix":{"range":[2794,2794],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":101,"column":73,"nodeType":null,"messageId":"insert","endLine":101,"endColumn":73,"fix":{"range":[2967,2967],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":113,"column":80,"nodeType":null,"messageId":"insert","endLine":113,"endColumn":80,"fix":{"range":[3345,3345],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":233,"column":73,"nodeType":null,"messageId":"insert","endLine":233,"endColumn":73,"fix":{"range":[6615,6615],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":242,"column":31,"nodeType":null,"messageId":"insert","endLine":242,"endColumn":31,"fix":{"range":[6819,6819],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":258,"column":41,"nodeType":null,"messageId":"insert","endLine":258,"endColumn":41,"fix":{"range":[7238,7238],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":266,"column":7,"nodeType":null,"messageId":"insert","endLine":266,"endColumn":7,"fix":{"range":[7415,7415],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":9,"source":"\"use client\";\n\nimport { Card, CardBody } from \"@heroui/card\";\nimport { addToast } from \"@heroui/toast\";\nimport { chunk } from \"lodash\";\nimport { Upload } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useRef, useState } from \"react\";\n\nimport { ImageUploadItem } from \"../../interface/ImageUpdload\";\nimport {\n  getFileExtension,\n  normalizeItems,\n  validateFile,\n} from \"../IBaseUploadImageDrag/utils\";\n\nimport IBaseUploadImageTinyItem from \"./IBaseUploadImageTinyItem\";\n\nexport type IBaseUploadImageTinyProps = {\n  accept?: string;\n  maxSize?: number; // in bytes, default 10MB\n  maxCount?: number; // maximum number of images\n  values?: ImageUploadItem[];\n  onChange?: (items: ImageUploadItem[]) => void;\n  uploadService?: (file: File) => Promise<{ id: string }>;\n  isDisabled?: boolean;\n  label?: string;\n  required?: boolean;\n  error?: string;\n};\n\nconst DEFAULT_ACCEPT = \"image/jpeg,image/jpg,image/png\";\nconst DEFAULT_MAX_SIZE = 10 * 1024 * 1024; // 10MB\nconst DEFAULT_MAX_COUNT = 10;\n\nexport default function IBaseUploadImageTiny({\n  accept = DEFAULT_ACCEPT,\n  maxSize = DEFAULT_MAX_SIZE,\n  maxCount = DEFAULT_MAX_COUNT,\n  values = [],\n  onChange,\n  uploadService,\n  isDisabled = false,\n  label,\n  required = false,\n  error,\n}: IBaseUploadImageTinyProps) {\n  const t = useTranslations(\"components.uploadImage\");\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const [uploadingItems, setUploadingItems] = useState<Set<string>>(new Set());\n\n  // init items from values\n  const [items, setItems] = useState<ImageUploadItem[]>(() => {\n    if (!values || values.length === 0) return [];\n\n    return normalizeItems(values as ImageUploadItem[]);\n  });\n\n  // Update items when values change\n  const handleItemsChange = useCallback(\n    (newItems: ImageUploadItem[]) => {\n      setItems(newItems);\n      onChange?.(newItems);\n    },\n    [onChange]\n  );\n\n  const handleFileSelect = useCallback(\n    async (files: FileList | null) => {\n      if (!files || files.length === 0) return;\n\n      const fileArray = Array.from(files);\n      const remainingSlots = maxCount - items.length;\n\n      if (fileArray.length > remainingSlots) {\n        addToast({\n          title: t(\"tooManyFiles\"),\n          description: t(\"tooManyFilesDescription\", { count: remainingSlots }),\n          color: \"warning\",\n        });\n\n        return;\n      }\n\n      // Validate all files first\n      const validationResults = fileArray.map((file) => ({\n        file,\n        validation: validateFile(file, accept, maxSize),\n      }));\n\n      // Separate valid and invalid files\n      const invalidFiles = validationResults.filter(\n        (result) => !result.validation.valid\n      );\n      const validFiles = validationResults.filter(\n        (result) => result.validation.valid\n      );\n\n      if (invalidFiles.length > 0) {\n        const invalidNotAllowed = invalidFiles.find(\n          (result) => result.validation.type === \"FILE_TYPE_NOT_ALLOWED\"\n        );\n\n        if (invalidNotAllowed) {\n          addToast({\n            title: t(\"invalidFile\"),\n            description: invalidNotAllowed.validation.error,\n            color: \"danger\",\n          });\n        }\n        const invalidFileSizeExceeded = invalidFiles.find(\n          (result) =>\n            result.validation.type === \"FILE_SIZE_EXCEEDS_MAXIMUM_ALLOWED_SIZE\"\n        );\n\n        if (invalidFileSizeExceeded) {\n          addToast({\n            title: t(\"invalidFile\"),\n            description: invalidFileSizeExceeded.validation.error,\n            color: \"danger\",\n          });\n        }\n      }\n\n      if (validFiles.length === 0) {\n        return;\n      }\n\n      // Create items from valid files (keep reference to original file for upload)\n      const fileItemMap = new Map<string, File>();\n      const newItems: ImageUploadItem[] = validFiles.map(({ file }) => {\n        const extension = getFileExtension(file.name);\n        const uid = `${Date.now()}-${Math.random().toString(36).substring(7)}`;\n\n        fileItemMap.set(uid, file);\n\n        return {\n          uid,\n          name: file.name,\n          size: file.size,\n          extension,\n          blob: file,\n          status: \"idle\",\n        } as ImageUploadItem;\n      });\n\n      // If no upload service, add items immediately\n      if (!uploadService) {\n        handleItemsChange([...items, ...newItems]);\n\n        return;\n      }\n\n      // Upload files in chunks of 5\n      const CHUNK_SIZE = 5;\n      const chunks = chunk(newItems, CHUNK_SIZE);\n\n      // Upload each chunk sequentially\n      for (const chunk of chunks) {\n        // Mark items as uploading\n        const chunkUids = chunk.map((item) => item.uid);\n\n        setUploadingItems((prev) => {\n          const next = new Set(prev);\n\n          chunkUids.forEach((uid) => next.add(uid));\n\n          return next;\n        });\n\n        // Update status to uploading for current items\n        setItems((currentItems) => {\n          const updated = currentItems.map((item) => {\n            if (chunkUids.includes(item.uid)) {\n              return { ...item, status: \"uploading\" as const };\n            }\n\n            return item;\n          });\n\n          handleItemsChange(updated);\n\n          return updated;\n        });\n\n        // Upload chunk in parallel\n        const uploadPromises = chunk.map(async (item) => {\n          const file = fileItemMap.get(item.uid);\n\n          if (!file) {\n            return {\n              uid: item.uid,\n              success: false,\n              error: \"File not found\",\n            };\n          }\n\n          try {\n            const result = await uploadService(file);\n\n            return {\n              uid: item.uid,\n              id: result.id,\n              success: true,\n            };\n          } catch (error) {\n            return {\n              uid: item.uid,\n              success: false,\n              error:\n                error instanceof Error\n                  ? error.message\n                  : \"Failed to upload image\",\n            };\n          }\n        });\n\n        const uploadResults = await Promise.all(uploadPromises);\n\n        // Update items based on upload results\n        const updatedItems = uploadResults.map((result) => {\n          return {\n            ...result,\n            status: result.success ? (\"done\" as const) : (\"error\" as const),\n          };\n        });\n\n        handleItemsChange([...items, ...updatedItems] as ImageUploadItem[]);\n        setItems([...items, ...updatedItems] as ImageUploadItem[]);\n        setUploadingItems(new Set());\n      }\n    },\n    [items, maxCount, accept, maxSize, uploadService, handleItemsChange]\n  );\n\n  const handleRemove = useCallback(\n    (uid: string) => {\n      const newItems = items.filter((item) => item.uid !== uid);\n\n      handleItemsChange(newItems);\n    },\n    [items, handleItemsChange]\n  );\n\n  const canAddMore = items.length < maxCount;\n  const isUploadDisabled = isDisabled || !canAddMore;\n\n  const handleDrop = useCallback(\n    (e: React.DragEvent<HTMLDivElement | HTMLButtonElement>) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (isUploadDisabled) return;\n\n      const files = e.dataTransfer.files;\n\n      handleFileSelect(files);\n    },\n    [isUploadDisabled, handleFileSelect]\n  );\n\n  const handleDragOver = useCallback(\n    (e: React.DragEvent<HTMLDivElement | HTMLButtonElement>) => {\n      e.preventDefault();\n      e.stopPropagation();\n    },\n    []\n  );\n\n  const handleClick = useCallback(() => {\n    if (!isUploadDisabled) {\n      fileInputRef.current?.click();\n    }\n  }, [isUploadDisabled]);\n\n  return (\n    <div className=\"flex flex-col gap-2\">\n      {label && (\n        <label className=\"text-sm font-medium text-foreground\">\n          {label}\n          {required && <span className=\"text-danger ml-1\">*</span>}\n        </label>\n      )}\n      <div className=\"flex flex-wrap gap-2 mt-2\">\n        {items.map((item) => (\n          <Card key={item.uid}>\n            <CardBody className=\"p-1\">\n              <IBaseUploadImageTinyItem\n                isDisabled={isDisabled}\n                isUploading={uploadingItems.has(item.uid)}\n                item={item}\n                onRemove={() => handleRemove(item.uid)}\n              />\n            </CardBody>\n          </Card>\n        ))}\n\n        {canAddMore && (\n          <button\n            className={`border-2 border-dashed rounded-lg p-2 transition-colors text-left ${\n              isUploadDisabled\n                ? \"border-default-200 bg-default-50 cursor-not-allowed\"\n                : \"border-default-300 hover:border-primary-400 cursor-pointer bg-default-50\"\n            }`}\n            type=\"button\"\n            onClick={handleClick}\n            onDragOver={handleDragOver}\n            onDrop={handleDrop}\n          >\n            <input\n              ref={fileInputRef}\n              multiple\n              accept={accept}\n              className=\"hidden\"\n              disabled={isUploadDisabled}\n              type=\"file\"\n              onChange={(e) => handleFileSelect(e.target.files)}\n            />\n\n            <div className=\"flex flex-col items-center justify-center gap-1 py-2 pointer-events-none\">\n              <Upload\n                className={`${isUploadDisabled ? \"text-default-300\" : \"text-default-400\"}`}\n                size={16}\n              />\n              <p\n                className={`text-xs text-center ${isUploadDisabled ? \"text-default-400\" : \"text-default-500\"}`}\n              >\n                {t(\"uploadImages\")}\n              </p>\n              <p className=\"text-[10px] text-default-400 text-center\">\n                {t(\"accepted\", {\n                  types: accept.replace(/image\\//g, \"\").replace(/,/g, \", \"),\n                })}{\" \"}\n                {t(\"maxSize\", { size: (maxSize / (1024 * 1024)).toFixed(0) })}\n              </p>\n            </div>\n          </button>\n        )}\n      </div>\n      {error && <p className=\"text-xs text-danger mt-1\">{error}</p>}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageTiny/IBaseUploadImageTinyItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/IBaseUploadImageTiny/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/LinkAs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/LoadingBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/LoadingOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/MarkdownContent/MarkdownContent.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":19,"column":81,"nodeType":null,"messageId":"insert","endLine":19,"endColumn":81,"fix":{"range":[471,471],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":23,"column":73,"nodeType":null,"messageId":"insert","endLine":23,"endColumn":73,"fix":{"range":[598,598],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":27,"column":73,"nodeType":null,"messageId":"insert","endLine":27,"endColumn":73,"fix":{"range":[724,724],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":33,"column":67,"nodeType":null,"messageId":"insert","endLine":33,"endColumn":67,"fix":{"range":[860,860],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":40,"column":41,"nodeType":null,"messageId":"insert","endLine":40,"endColumn":41,"fix":{"range":[1068,1068],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":46,"column":55,"nodeType":null,"messageId":"insert","endLine":46,"endColumn":55,"fix":{"range":[1250,1250],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":52,"column":75,"nodeType":null,"messageId":"insert","endLine":52,"endColumn":75,"fix":{"range":[1397,1397],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"\"use client\";\n\nexport interface MarkdownContentProps {\n  content: string;\n  className?: string;\n}\n\nexport default function MarkdownContent({\n  content,\n  className = \"\",\n}: MarkdownContentProps) {\n  // Simple markdown to HTML converter\n  const renderMarkdown = (md: string): string => {\n    let html = md;\n\n    // Headers - smaller font sizes\n    html = html.replace(\n      /^### (.*$)/gim,\n      \"<h3 class='text-base font-semibold mt-3 mb-1.5 text-default-800'>$1</h3>\"\n    );\n    html = html.replace(\n      /^## (.*$)/gim,\n      \"<h2 class='text-lg font-bold mt-4 mb-2 text-default-800'>$1</h2>\"\n    );\n    html = html.replace(\n      /^# (.*$)/gim,\n      \"<h1 class='text-xl font-bold mt-4 mb-2 text-default-900'>$1</h1>\"\n    );\n\n    // Bold\n    html = html.replace(\n      /\\*\\*(.*?)\\*\\*/g,\n      \"<strong class='font-semibold text-default-800'>$1</strong>\"\n    );\n\n    // Lists - smaller spacing\n    html = html.replace(/^- (.*$)/gim, \"<li class='ml-4 text-sm'>$1</li>\");\n    html = html.replace(\n      /^(\\d+)\\. (.*$)/gim,\n      \"<li class='ml-4 text-sm'>$2</li>\"\n    );\n\n    // Wrap consecutive list items in ul - reduced spacing\n    html = html.replace(\n      /(<li[^>]*>.*?<\\/li>\\n?)+/g,\n      \"<ul class='list-disc mb-2 space-y-0.5'>$&</ul>\"\n    );\n\n    // Code blocks\n    html = html.replace(\n      /`([^`]+)`/g,\n      \"<code class='bg-default-100 px-1 py-0.5 rounded text-xs'>$1</code>\"\n    );\n\n    // Horizontal rules - smaller margin\n    html = html.replace(/^---$/gim, \"<hr class='my-2 border-default-200' />\");\n\n    // Paragraphs - smaller font and spacing\n    html = html\n      .split(\"\\n\\n\")\n      .map((para) => {\n        if (para.trim() && !para.match(/^<[h|u|o|l|h]/)) {\n          return `<p class='mb-2 text-sm text-default-700 leading-relaxed'>${para.trim()}</p>`;\n        }\n\n        return para;\n      })\n      .join(\"\\n\");\n\n    // Tables - smaller spacing\n    html = html.replace(/\\|(.+)\\|/g, (match, content) => {\n      const cells = content.split(\"|\").map((cell: string) => cell.trim());\n\n      if (cells.length > 1) {\n        return `<div class='grid grid-cols-${cells.length} gap-1.5 py-1.5 border-b border-default-200 text-sm'>${cells.map((cell: string) => `<div class='font-medium text-default-800'>${cell}</div>`).join(\"\")}</div>`;\n      }\n\n      return match;\n    });\n\n    return html;\n  };\n\n  return (\n    <div\n      dangerouslySetInnerHTML={{\n        __html: renderMarkdown(content),\n      }}\n      className={`max-w-none ${className}`}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/MarkdownContent/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/NavigationLoader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/Pagination/Pagination.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":87,"fix":{"range":[86,86],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":87,"fix":{"range":[0,203],"text":"import type { Key, SVGProps } from \"react\";\n\nimport clsx from \"clsx\";\nimport { useCallback, useMemo } from \"react\";\nimport { IBaseButton, IBaseDropdown, IBasePagination } from \"@base/client/components\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·IBaseButton,·IBaseDropdown,·IBasePagination·` with `⏎··IBaseButton,⏎··IBaseDropdown,⏎··IBasePagination,⏎`","line":1,"column":9,"nodeType":null,"messageId":"replace","endLine":1,"endColumn":54,"fix":{"range":[8,53],"text":"\n  IBaseButton,\n  IBaseDropdown,\n  IBasePagination,\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":5,"column":46,"nodeType":null,"messageId":"delete","endLine":6,"endColumn":1,"fix":{"range":[202,203],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":70,"column":23,"nodeType":null,"messageId":"insert","endLine":70,"endColumn":23,"fix":{"range":[1776,1776],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":84,"column":105,"nodeType":null,"messageId":"insert","endLine":84,"endColumn":105,"fix":{"range":[2190,2190],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":88,"column":121,"nodeType":null,"messageId":"insert","endLine":88,"endColumn":121,"fix":{"range":[2378,2378],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":92,"column":121,"nodeType":null,"messageId":"insert","endLine":92,"endColumn":121,"fix":{"range":[2566,2566],"text":","}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":103,"column":9,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":103,"endColumn":14,"fix":{"range":[2790,3335],"text":"items={options.map((item) => ({\n          key: String(item),\n          textValue: String(item),\n          children: String(item),\n        }))}\n        menu={{\n          \"aria-label\": \"Page size selection\",\n          className: \"min-w-[60px]\",\n          selectedKeys,\n          selectionMode: \"single\",\n          onSelectionChange: (keys) => {\n            const [selectedKey] = Array.from(keys);\n\n            if (selectedKey != null) {\n              handlePageSizeChange(selectedKey);\n            }\n          },\n        }}\n        placement=\"top\""}},{"ruleId":"react/jsx-sort-props","severity":1,"message":"Props should be sorted alphabetically","line":108,"column":9,"nodeType":"JSXIdentifier","messageId":"sortPropsByAlpha","endLine":108,"endColumn":13,"fix":{"range":[2790,3335],"text":"items={options.map((item) => ({\n          key: String(item),\n          textValue: String(item),\n          children: String(item),\n        }))}\n        menu={{\n          \"aria-label\": \"Page size selection\",\n          className: \"min-w-[60px]\",\n          selectedKeys,\n          selectionMode: \"single\",\n          onSelectionChange: (keys) => {\n            const [selectedKey] = Array.from(keys);\n\n            if (selectedKey != null) {\n              handlePageSizeChange(selectedKey);\n            }\n          },\n        }}\n        placement=\"top\""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":10,"source":"import { IBaseButton, IBaseDropdown, IBasePagination } from \"@base/client/components\";\nimport type { Key, SVGProps } from \"react\";\n\nimport clsx from \"clsx\";\nimport { useCallback, useMemo } from \"react\";\n\n\nimport { PAGINATION_PAGE_SIZE_OPTIONS } from \"./paginationConsts\";\n\nexport const ChevronIcon = (props: SVGProps<SVGSVGElement>) => {\n  return (\n    <svg\n      aria-hidden=\"true\"\n      fill=\"none\"\n      focusable=\"false\"\n      height=\"1em\"\n      role=\"presentation\"\n      viewBox=\"0 0 24 24\"\n      width=\"1em\"\n      {...props}\n    >\n      <path\n        d=\"M15.5 19l-7-7 7-7\"\n        stroke=\"currentColor\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        strokeWidth=\"1.5\"\n      />\n    </svg>\n  );\n};\n\nexport default function PaginationComponent({\n  pages,\n  page,\n  pageSize,\n  pageSizeOptions,\n  onChange,\n  onPageSizeChange,\n}: {\n  pages: number;\n  page: number;\n  pageSize: number;\n  pageSizeOptions?: number[];\n  onChange: (page: number) => void;\n  onPageSizeChange: (pageSize: number) => void;\n}) {\n  const options = useMemo(() => {\n    const baseOptions =\n      Array.isArray(pageSizeOptions) && pageSizeOptions.length > 0\n        ? pageSizeOptions\n        : PAGINATION_PAGE_SIZE_OPTIONS;\n\n    return baseOptions.filter((option) => option > 0).sort((a, b) => a - b);\n  }, [pageSizeOptions]);\n\n  const paginationItemBase =\n    \"flex h-6 w-8 items-center justify-center rounded-full text-small font-medium transition-colors cursor-pointer\";\n\n  const selectedKeys = useMemo(() => new Set([String(pageSize)]), [pageSize]);\n\n  const handlePageSizeChange = useCallback(\n    (key: Key) => {\n      const selectedValue = Number(key);\n\n      if (!Number.isNaN(selectedValue)) {\n        onPageSizeChange(selectedValue);\n      }\n    },\n    [onPageSizeChange]\n  );\n\n  return (\n    <div className=\"flex items-center gap-4\">\n      <IBasePagination\n        disableAnimation\n        disableCursorAnimation\n        isCompact\n        showControls\n        classNames={{\n          base: \"items-center p-0 overflow-hidden\",\n          item: clsx(\n            paginationItemBase,\n            \"bg-transparent text-primary data-[hover=true]:bg-primary-50 data-[hover=true]:text-primary\"\n          ),\n          next: clsx(\n            paginationItemBase,\n            \"border border-transparent text-default-500 data-[hover=true]:border-primary data-[hover=true]:text-primary\"\n          ),\n          prev: clsx(\n            paginationItemBase,\n            \"border border-transparent text-default-500 data-[hover=true]:border-primary data-[hover=true]:text-primary\"\n          ),\n          cursor: clsx(paginationItemBase, \"bg-primary-500 text-white\"),\n        }}\n        page={page}\n        size=\"sm\"\n        total={pages}\n        onChange={onChange}\n      />\n      <IBaseDropdown\n        placement=\"top\"\n        items={options.map((item) => ({\n          key: String(item),\n          textValue: String(item),\n          children: String(item),\n        }))}\n        menu={{\n          \"aria-label\": \"Page size selection\",\n          className: \"min-w-[60px]\",\n          selectedKeys,\n          selectionMode: \"single\",\n          onSelectionChange: (keys) => {\n            const [selectedKey] = Array.from(keys);\n\n            if (selectedKey != null) {\n              handlePageSizeChange(selectedKey);\n            }\n          },\n        }}\n      >\n        <IBaseButton\n          className=\"text-small font-medium px-2 h-6\"\n          endContent={<ChevronIcon className=\"text-small rotate-90\" />}\n          size=\"sm\"\n          // variant=\"\"\n        >\n          {pageSize}\n        </IBaseButton>\n      </IBaseDropdown>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/Pagination/paginationConsts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/ViewListDataTable.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":30,"column":35,"nodeType":null,"messageId":"insert","endLine":30,"endColumn":35,"fix":{"range":[1196,1196],"text":","}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isFavoriteHidden' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":58,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fetchError' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":67,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":22},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":87,"column":40,"nodeType":null,"messageId":"insert","endLine":87,"endColumn":40,"fix":{"range":[2694,2694],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":145,"column":32,"nodeType":null,"messageId":"insert","endLine":145,"endColumn":32,"fix":{"range":[4204,4204],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport type { LinkProps } from \"@heroui/link\";\nimport type { FilterOption } from \"./components/FilterMenu\";\nimport type { GroupOption } from \"./components/GroupByMenu\";\n\nimport { Divider } from \"@heroui/divider\";\nimport { useCallback, useMemo } from \"react\";\n\nimport { IBaseButton, IBaseCard, IBaseCardBody } from \"@base/client/components\";\n\nimport { useLocalizedText } from \"../../hooks/useLocalizedText\";\nimport { IBaseTable } from \"../IBaseTable\";\nimport { IBaseTablePagination } from \"../IBaseTable/IBaseTableInterface\";\nimport LinkAs from \"../LinkAs\";\nimport { PAGINATION_DEFAULT_PAGE_SIZE } from \"../Pagination/paginationConsts\";\n\nimport ColumnVisibilityMenu from \"./components/ColumnVisibilityMenu\";\nimport FilterMenu from \"./components/FilterMenu\";\nimport GroupByMenu from \"./components/GroupByMenu\";\nimport SearchBar from \"./components/SearchBar\";\nimport { useViewListDataTableQueries } from \"./useViewListDataTableQueries\";\nimport { useViewListDataTableStore } from \"./useViewListDataTableStore\";\nimport {\n  ActionElm,\n  ViewListDataTableProps,\n} from \"./ViewListDataTableInterface\";\n\nexport default function ViewListDataTable<T = any>(\n  props: ViewListDataTableProps<T>\n) {\n  const {\n    columns,\n    model,\n    title,\n    search,\n    filter,\n    groupBy,\n    favorite,\n    columnVisibility,\n    isDummyData = true,\n    actionsLeft,\n    actionsRight,\n    pagination: _pagination = {\n      page: 1,\n      pageSize: PAGINATION_DEFAULT_PAGE_SIZE,\n    },\n    ...dataTableProps\n  } = props;\n  // Use the store hook - each instance gets its own store\n  const store = useViewListDataTableStore({\n    columns,\n  });\n  const getLocalizedText = useLocalizedText();\n  const isFilterHidden = filter?.hidden === true;\n  const isSearchHidden = search?.hidden === true;\n  const isGroupByHidden = groupBy?.hidden === true;\n  const isFavoriteHidden = favorite?.hidden === true;\n  const isColumnVisibilityHidden = columnVisibility?.hidden === true;\n  // Fetch data using react-query\n  const {\n    data: dataSource,\n    isDataDummy,\n    total,\n    isLoading,\n    isFetching,\n    error: fetchError,\n    refresh,\n    onChangeTable,\n  } = useViewListDataTableQueries<T>({\n    model,\n    isDummyData,\n    pagination: _pagination as IBaseTablePagination,\n    // enabled: !propDataSource, // Only fetch if dataSource is not provided as prop\n  });\n\n  const filterOptions = useMemo<FilterOption<T>[]>(() => {\n    return [];\n  }, []);\n  const groupByOptions = useMemo<GroupOption[]>(() => {\n    return [];\n  }, []);\n\n  // Prepare columns list with only visible columns\n  const displayColumns = useMemo(() => {\n    const cols = columns.filter((col: any) =>\n      store.visibleColumns.has(col.key)\n    );\n\n    if (isDataDummy) {\n      return cols.map((col: any) => ({\n        ...col,\n        render: () => null,\n      }));\n    }\n\n    return cols;\n  }, [columns, store.visibleColumns, isDataDummy]);\n\n  const renderActions = useCallback(\n    (acts: ActionElm[]) => {\n      return acts?.map((action) => {\n        const size = action.size ?? \"sm\";\n        const variant = action.variant ?? \"solid\";\n        const color = action.color ?? \"default\";\n\n        switch (action.type) {\n          case \"button\":\n            return (\n              <IBaseButton\n                key={action.key}\n                isIconOnly\n                color={color}\n                size={size}\n                variant={variant}\n                {...(action.props as any)}\n              >\n                {action.title}\n              </IBaseButton>\n            );\n          case \"link\":\n            const linkProps = action.props as Omit<LinkProps, \"as\"> & {\n              hrefAs?: any;\n            };\n\n            return (\n              <IBaseButton\n                key={action.key}\n                as={LinkAs as any}\n                color={color}\n                href={linkProps.href as string}\n                size={size}\n                variant={variant}\n                {...(linkProps as any)}\n                // {...(linkProps as any)}\n              >\n                {action.title}\n              </IBaseButton>\n            );\n          default:\n            return null;\n        }\n      });\n    },\n    [actionsLeft, actionsRight]\n  );\n\n  // Render\n  return (\n    <IBaseCard>\n      {/* Actions Bar */}\n      {title && (\n        <div className=\"flex gap-2 flex-wrap flex-col px-3 py-2\">\n          <h4 className=\"text-medium font-medium\">{getLocalizedText(title)}</h4>\n          <Divider className=\"my-0\" />\n        </div>\n      )}\n\n      <IBaseCardBody className={`${title ? \"pt-0\" : \"\"}`}>\n        <div className=\"flex gap-2 items-center mb-4 flex-wrap\">\n          <div className=\"flex gap-2 flex-1 justify-start\">\n            {renderActions(actionsLeft ?? [])}\n          </div>\n\n          <div className=\"flex gap-2 flex-1 justify-end\">\n            {!isSearchHidden && (\n              <SearchBar\n                placeholder={search?.placeholder}\n                value={store.search}\n                onChange={store.setSearch}\n              />\n            )}\n            {!isFilterHidden && (\n              <FilterMenu\n                activeFilters={store.activeFilters}\n                filterOptions={filterOptions}\n                onToggleFilter={store.toggleFilter}\n              />\n            )}\n            {!isGroupByHidden && (\n              <GroupByMenu\n                currentGroupBy={store.groupBy}\n                groupByOptions={groupByOptions}\n                onSelectGroupBy={store.setGroupBy}\n              />\n            )}\n            {renderActions(actionsRight ?? [])}\n\n            {!isColumnVisibilityHidden && (\n              <ColumnVisibilityMenu\n                columns={columns}\n                visibleColumns={store.visibleColumns}\n                onToggleColumn={store.toggleColumn}\n              />\n            )}\n          </div>\n        </div>\n\n        {/* IBaseTablePrimitive */}\n        <IBaseTable\n          {...dataTableProps}\n          columns={displayColumns}\n          dataSource={dataSource}\n          loading={isLoading || isFetching || dataTableProps.loading}\n          pagination={_pagination}\n          total={total}\n          onChangeTable={onChangeTable}\n          onRefresh={refresh}\n        />\n      </IBaseCardBody>\n    </IBaseCard>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/ViewListDataTableInterface.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":60,"fix":{"range":[59,59],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":60,"fix":{"range":[0,276],"text":"import type { IBaseTableProps } from \"../IBaseTable/IBaseTableInterface\";\n\nimport { LinkProps } from \"@heroui/link\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { ReactNode } from \"react\";\nimport { IBaseButtonProps } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":42,"fix":{"range":[176,176],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":64,"fix":{"range":[240,240],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/Locale` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":64,"fix":{"range":[177,276],"text":"import { ReactNode } from \"react\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import { IBaseButtonProps } from \"@base/client/components\";\nimport type { IBaseTableProps } from \"../IBaseTable/IBaseTableInterface\";\n\nimport { LinkProps } from \"@heroui/link\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { ReactNode } from \"react\";\n\nimport { FilterOption } from \"./components/FilterMenu\";\nimport { GroupOption } from \"./components/GroupByMenu\";\n\nexport type ActionElm = {\n  key: string;\n  title: ReactNode;\n  type: \"button\" | \"link\";\n  color?: IBaseButtonProps[\"color\"];\n  variant?: IBaseButtonProps[\"variant\"];\n  size?: IBaseButtonProps[\"size\"];\n  props?:\n    | Omit<IBaseButtonProps, \"color\" | \"variant\" | \"size\">\n    | (Omit<LinkProps, \"as\"> & { hrefAs?: any });\n};\nexport type ViewListDataTableProps<T = any> = Omit<\n  IBaseTableProps<T>,\n  \"dataSource\"\n> & {\n  title?: LocaleDataType<string> | string;\n  model: string; // @module.model format (e.g., \"product.variant\")\n  // Optional: Override fetched data\n  dataSource?: T[];\n  // Optional: Override fetched filter options\n  filterOptions?: FilterOption<T>[];\n  // Optional: Override fetched group by options\n  groupByOptions?: GroupOption[];\n  // Optional: Override fetched favorite filter\n\n  // others actions\n  actionsLeft?: ActionElm[];\n  actionsRight?: ActionElm[];\n  search?: {\n    hidden?: boolean;\n    placeholder?: string;\n  };\n  filter?: {\n    hidden?: boolean;\n  };\n  groupBy?: {\n    hidden?: boolean;\n  };\n  favorite?: {\n    hidden?: boolean;\n  };\n  columnVisibility?: {\n    hidden?: boolean;\n  };\n  isDummyData?: boolean;\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/components/ColumnVisibilityMenu.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":43,"column":19,"nodeType":null,"messageId":"insert","endLine":43,"endColumn":19,"fix":{"range":[1275,1275],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":88,"column":24,"nodeType":null,"messageId":"insert","endLine":88,"endColumn":24,"fix":{"range":[2256,2256],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { Table } from \"lucide-react\";\nimport MiniSearch from \"minisearch\";\nimport { useMemo, useState } from \"react\";\n\nimport {\n  IBaseButton,\n  IBaseCheckbox,\n  IBaseDropdown,\n  IBaseInputSearch,\n} from \"@base/client/components\";\n\nimport { IBaseTableColumnDefinition } from \"../../IBaseTable/IBaseTableInterface\";\n\ninterface ColumnVisibilityMenuProps<T = any> {\n  columns: IBaseTableColumnDefinition<T>[];\n  visibleColumns: Set<string>;\n  onToggleColumn: (key: string) => void;\n}\n\nexport default function ColumnVisibilityMenu<T = any>({\n  columns,\n  visibleColumns,\n  onToggleColumn,\n}: ColumnVisibilityMenuProps<T>) {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n\n  const { miniSearch, columnMap } = useMemo(() => {\n    const toLabel = (column: IBaseTableColumnDefinition<T>) => {\n      const source = column.label ?? column.title ?? column.key;\n\n      if (typeof source === \"string\") return source;\n      if (typeof source === \"number\" || typeof source === \"boolean\") {\n        return String(source);\n      }\n      if (Array.isArray(source)) {\n        return source\n          .map((item) =>\n            typeof item === \"string\" || typeof item === \"number\"\n              ? String(item)\n              : \"\"\n          )\n          .filter(Boolean)\n          .join(\" \");\n      }\n\n      return column.key.toString();\n    };\n\n    const docs = columns.map((column) => ({\n      id: column.key.toString(),\n      label: toLabel(column),\n    }));\n\n    const ms = new MiniSearch({\n      fields: [\"label\"],\n      storeFields: [\"id\", \"label\"],\n    });\n\n    ms.addAll(docs);\n\n    const map = new Map<string, IBaseTableColumnDefinition<T>>();\n\n    columns.forEach((column) => {\n      map.set(column.key.toString(), column);\n    });\n\n    return { miniSearch: ms, columnMap: map };\n  }, [columns]);\n\n  const filteredColumns = useMemo(() => {\n    const term = searchTerm.trim();\n\n    if (!term) return columns;\n\n    const results = miniSearch.search(term, {\n      prefix: true,\n      fuzzy: 0.2,\n    });\n\n    if (results.length === 0) return [];\n\n    return results\n      .map((result) => columnMap.get(result.id))\n      .filter((column): column is IBaseTableColumnDefinition<T> =>\n        Boolean(column)\n      );\n  }, [columns, columnMap, miniSearch, searchTerm]);\n\n  const dropdownItems = useMemo(() => {\n    return [\n      {\n        key: \"__search__\",\n        hideSelectedIcon: true,\n        isReadOnly: true,\n        className:\n          \"sticky top-0 z-10 pointer-events-auto data-[hover=true]:bg-transparent bg-content1\",\n        textValue: \"Search columns\",\n        children: (\n          <IBaseInputSearch\n            // Avoid autoFocus for better accessibility; focus can be managed by parent if needed\n            placeholder=\"Search columns...\"\n            showClearButton={false}\n            value={searchTerm}\n            onValueChange={setSearchTerm}\n          />\n        ),\n      },\n      ...filteredColumns.map((col) => ({\n        key: String(col.key),\n        textValue:\n          typeof col.label === \"string\"\n            ? col.label\n            : String(col.label ?? col.title ?? col.key),\n        onPress: () => onToggleColumn(String(col.key)),\n        children: (\n          <IBaseCheckbox\n            isReadOnly\n            className=\"pointer-events-none\"\n            isSelected={visibleColumns.has(String(col.key))}\n          >\n            {col.label ?? col.title ?? col.key}\n          </IBaseCheckbox>\n        ),\n      })),\n    ];\n  }, [filteredColumns, onToggleColumn, searchTerm, visibleColumns]);\n\n  return (\n    <IBaseDropdown\n      closeOnSelect={false}\n      isOpen={isOpen}\n      items={dropdownItems}\n      menu={{\n        \"aria-label\": \"Column visibility\",\n        className: \"min-w-[220px] text-[12px] max-h-[500px] overflow-y-auto\",\n        itemClasses: {\n          base: \"py-1 px-2\",\n          title: \"text-[12px]\",\n        },\n      }}\n      shouldCloseOnInteractOutside={() => true}\n      onOpenChange={(open) => {\n        setIsOpen(open);\n        if (!open) {\n          setSearchTerm(\"\");\n        }\n      }}\n    >\n      <IBaseButton\n        isIconOnly\n        size=\"sm\"\n        startContent={<Table size={16} />}\n        title=\"Column visibility\"\n        variant=\"bordered\"\n      />\n    </IBaseDropdown>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/components/FavoriteFilter.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`lucide-react` import should occur before import of `@base/client/components`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":37,"fix":{"range":[14,107],"text":"import { Star } from \"lucide-react\";\nimport { IBaseButton } from \"@base/client/components\";\n\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\nimport { IBaseButton } from \"@base/client/components\";\n\nimport { Star } from \"lucide-react\";\n\ninterface FavoriteFilterProps {\n  isActive: boolean;\n  onToggle: () => void;\n}\n\nexport default function FavoriteFilter({\n  isActive,\n  onToggle,\n}: FavoriteFilterProps) {\n  return (\n    <IBaseButton\n      aria-label=\"Show favorites\"\n      color={isActive ? \"warning\" : \"default\"}\n      title=\"Show favorites\"\n      variant={isActive ? \"solid\" : \"bordered\"}\n      onPress={onToggle}\n    >\n      <Star className={isActive ? \"fill-current\" : \"\"} />\n    </IBaseButton>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/components/FilterMenu.tsx","messages":[{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·IBaseButton,·IBaseCheckbox,·IBaseDropdown·` with `⏎··IBaseButton,⏎··IBaseCheckbox,⏎··IBaseDropdown,⏎`","line":2,"column":9,"nodeType":null,"messageId":"replace","endLine":2,"endColumn":52,"fix":{"range":[22,65],"text":"\n  IBaseButton,\n  IBaseCheckbox,\n  IBaseDropdown,\n"}},{"ruleId":"import/order","severity":1,"message":"`lucide-react` import should occur before import of `@base/client/components`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":39,"fix":{"range":[14,139],"text":"import { Filter } from \"lucide-react\";\nimport { IBaseButton, IBaseCheckbox, IBaseDropdown } from \"@base/client/components\";\n\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":4,"column":39,"nodeType":null,"messageId":"delete","endLine":5,"endColumn":1,"fix":{"range":[138,139],"text":""}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\nimport { IBaseButton, IBaseCheckbox, IBaseDropdown } from \"@base/client/components\";\n\nimport { Filter } from \"lucide-react\";\n\n\nexport interface FilterOption<T = any> {\n  label: string;\n  filterFn: (row: T) => boolean;\n}\n\ninterface FilterMenuProps<T = any> {\n  filterOptions?: FilterOption<T>[];\n  activeFilters: Set<string>;\n  onToggleFilter: (label: string) => void;\n}\n\nexport default function FilterMenu<T = any>({\n  filterOptions,\n  activeFilters,\n  onToggleFilter,\n}: FilterMenuProps<T>) {\n  if (!filterOptions || filterOptions.length === 0) {\n    return null;\n  }\n\n  return (\n    <IBaseDropdown\n      items={filterOptions.map((option) => ({\n        key: option.label,\n        textValue: option.label,\n        children: (\n          <IBaseCheckbox\n            isSelected={activeFilters.has(option.label)}\n            onValueChange={() => onToggleFilter(option.label)}\n          >\n            {option.label}\n          </IBaseCheckbox>\n        ),\n      }))}\n      menu={{\n        \"aria-label\": \"Filter options\",\n        className: \"min-w-[150px]\",\n      }}\n    >\n      <IBaseButton\n        size=\"sm\"\n        startContent={<Filter size={16} />}\n        title=\"Filter\"\n        variant=\"bordered\"\n      />\n    </IBaseDropdown>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/components/GroupByMenu.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":70,"fix":{"range":[14,156],"text":"\nimport { Group } from \"lucide-react\";\nimport { useMemo } from \"react\";\nimport { IBaseButton, IBaseDropdown } from \"@base/client/components\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `⏎`","line":7,"column":1,"nodeType":null,"messageId":"delete","endLine":8,"endColumn":1,"fix":{"range":[157,158],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":30,"column":21,"nodeType":null,"messageId":"insert","endLine":30,"endColumn":21,"fix":{"range":[683,683],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\nimport { IBaseButton, IBaseDropdown } from \"@base/client/components\";\n\nimport { Group } from \"lucide-react\";\nimport { useMemo } from \"react\";\n\n\nexport interface GroupOption {\n  key: string;\n  label: string;\n}\n\ninterface GroupByMenuProps {\n  groupByOptions: GroupOption[];\n  currentGroupBy: string | null;\n  onSelectGroupBy: (key: string | null) => void;\n}\n\nexport default function GroupByMenu({\n  groupByOptions,\n  currentGroupBy,\n  onSelectGroupBy,\n}: GroupByMenuProps) {\n  if (!groupByOptions || groupByOptions.length === 0) {\n    return null;\n  }\n\n  const menuItems = useMemo(\n    () => [{ key: \"__none__\", label: \"(None)\" }, ...groupByOptions],\n    [groupByOptions]\n  );\n\n  return (\n    <IBaseDropdown\n      items={menuItems.map((item) => ({\n        key: item.key,\n        textValue: item.label,\n        children: item.label,\n      }))}\n      menu={{\n        \"aria-label\": \"Group by options\",\n        selectedKeys: currentGroupBy ? [currentGroupBy] : [\"__none__\"],\n        selectionMode: \"single\",\n        onSelectionChange: (keys) => {\n          const selectedKey = Array.from(keys)[0] as string | undefined;\n\n          if (!selectedKey || selectedKey === \"__none__\") {\n            onSelectGroupBy(null);\n\n            return;\n          }\n          onSelectGroupBy(selectedKey);\n        },\n      }}\n    >\n      <IBaseButton\n        size=\"sm\"\n        startContent={<Group size={16} />}\n        title=\"Group by\"\n        variant=\"bordered\"\n      />\n    </IBaseDropdown>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/components/SearchBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/useViewListDataTableQueries.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^_.*?$/u.","line":12,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/ViewListDataTable/useViewListDataTableStore.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^_.*?$/u.","line":8,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/icons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/components/primitives.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/contexts/global-settings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/contexts/i18n.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":58,"fix":{"range":[143,143],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/stores/messages-store`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":52,"fix":{"range":[15,196],"text":"import { NextIntlClientProvider } from \"next-intl\";\nimport { useMessagesStore } from \"@base/client/stores/messages-store\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/stores/messages-store`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":44,"fix":{"range":[15,240],"text":"import { useEffect, useMemo } from \"react\";\nimport { useMessagesStore } from \"@base/client/stores/messages-store\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { NextIntlClientProvider } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useMessagesStore } from \"@base/client/stores/messages-store\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { NextIntlClientProvider } from \"next-intl\";\nimport { useEffect, useMemo } from \"react\";\n\nexport default function ModuleI18nProvider({\n  locale,\n  initialMessages,\n  children,\n}: {\n  locale: string;\n  initialMessages: {\n    common: Record<string, any>;\n    [moduleName: string]: Record<string, any>;\n  };\n  children: React.ReactNode;\n}) {\n  const { setCommonMessages, setModuleMessages, messages } = useMessagesStore();\n\n  // Initialize store with server-fetched messages\n  useEffect(() => {\n    const { common, ...moduleMessages } = initialMessages;\n\n    setCommonMessages(common);\n\n    // Set each module's messages\n    Object.entries(moduleMessages).forEach(([moduleName, msg]) => {\n      setModuleMessages(moduleName, msg);\n    });\n  }, [initialMessages, setCommonMessages, setModuleMessages]);\n\n  // Get combined messages from store (subscribe to changes)\n  const combinedMessages = useMemo(() => {\n    const init = Object.values(initialMessages).reduce(\n      (acc, msg) => ({ ...acc, ...msg }),\n      {},\n    );\n\n    // Combine all messages: common first, then modules (later modules override earlier ones)\n    return Object.values(messages).reduce(\n      (acc, moduleMsg) => ({ ...acc, ...moduleMsg }),\n      init,\n    );\n  }, [messages, initialMessages]);\n\n  return (\n    <NextIntlClientProvider\n      locale={locale}\n      messages={combinedMessages}\n      timeZone={SYSTEM_TIMEZONE}\n    >\n      {children}\n    </NextIntlClientProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/contexts/workspace.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/hooks/debug/useWhyDidUpdate.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":18,"suggestions":[{"fix":{"range":[969,1016],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/hooks/useCreateUpdate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/hooks/useLocalizedText.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":26,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useLocale } from \"next-intl\";\n\nimport { DEFAULT_LANG, LocalizeText } from \"../interface/LocalizeText\";\n\nconst getLocalizedValue = (\n  text: LocalizeText | string | undefined | null,\n  locale: string,\n) => {\n  if (!text) return \"\";\n  if (typeof text === \"string\") return text;\n\n  if (text[locale as keyof typeof text]) {\n    return text[locale as keyof typeof text] ?? \"\";\n  }\n\n  return text.en || text.vi || \"\";\n};\n\nexport const useLocalizedText = (locale?: string) => {\n  let detectedLocale = locale ?? DEFAULT_LANG;\n\n  try {\n    const contextLocale = useLocale();\n\n    detectedLocale = locale ?? contextLocale ?? DEFAULT_LANG;\n  } catch (error) {\n    detectedLocale = locale ?? DEFAULT_LANG;\n  }\n\n  return (text: LocalizeText | string | undefined | null) =>\n    getLocalizedValue(text, detectedLocale);\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/hooks/usePrefetchModuleMessages.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":71,"fix":{"range":[85,85],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/stores/messages-store`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":35,"fix":{"range":[15,121],"text":"import { useEffect } from \"react\";\nimport { useMessagesStore } from \"@base/client/stores/messages-store\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":22,"suggestions":[{"fix":{"range":[1272,1376],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":20,"suggestions":[{"fix":{"range":[1626,1685],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { useMessagesStore } from \"@base/client/stores/messages-store\";\nimport { useEffect } from \"react\";\n\n/**\n * Hook to prefetch messages for all modules except current one\n */\nexport function usePrefetchModuleMessages(\n  allModuleNames: string[],\n  currentModule: string | null,\n  locale: string,\n) {\n  const { setModuleMessages, setLoadingModule, isLoadingModule } =\n    useMessagesStore();\n\n  useEffect(() => {\n    // Get modules that need to be loaded (exclude current module)\n    const state = useMessagesStore.getState();\n    const modulesToLoad = allModuleNames.filter(\n      (moduleName) =>\n        moduleName !== currentModule &&\n        !isLoadingModule(moduleName) &&\n        !state.messages[moduleName],\n    );\n\n    if (modulesToLoad.length === 0) return;\n\n    // Prefetch all module messages in parallel\n    const prefetchPromises = modulesToLoad.map(async (moduleName) => {\n      setLoadingModule(moduleName, true);\n\n      try {\n        const moduleMessages = await import(\n          `@mdl/${moduleName}/client/messages/${locale}.json`\n        )\n          .then((module) => module.default)\n          .catch(() => ({}));\n\n        // Store module messages\n        setModuleMessages(moduleName, moduleMessages);\n      } catch (error) {\n        console.error(\n          `Error loading messages for module ${moduleName}:`,\n          error,\n        );\n        // Set empty object on error\n        setModuleMessages(moduleName, {});\n      } finally {\n        setLoadingModule(moduleName, false);\n      }\n    });\n\n    // Execute all prefetches\n    Promise.all(prefetchPromises).catch((error) => {\n      console.error(\"Error prefetching module messages:\", error);\n    });\n  }, [\n    allModuleNames,\n    currentModule,\n    locale,\n    setModuleMessages,\n    setLoadingModule,\n    isLoadingModule,\n  ]);\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/hooks/usePreventBackspaceNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/interface/Address.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/interface/ImageUpdload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/interface/LocalizeText.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/interface/WorkspaceMenuInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/interface/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/WorkspaceLayout.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":70,"fix":{"range":[134,134],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":40,"fix":{"range":[174,174],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/headers` import should occur before import of `@base/server/loaders/menu-loader`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":40,"fix":{"range":[0,175],"text":"import { headers } from \"next/headers\";\nimport { loadAllMenus } from \"@base/server/loaders/menu-loader\";\nimport { getModuleNames } from \"@base/server/utils/get-module-names\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { loadAllMenus } from \"@base/server/loaders/menu-loader\";\nimport { getModuleNames } from \"@base/server/utils/get-module-names\";\nimport { headers } from \"next/headers\";\nimport ModuleI18nProvider from \"@base/client/contexts/i18n\";\nimport WorkspaceLayoutClient from \"@base/client/layouts/workspace/WorkspaceLayoutClient\";\n\nimport { MenuWorkspaceElement } from \"../../interface/WorkspaceMenuInterface\";\n\n// i18n is provided at module level layouts to avoid loading all messages here\n\nexport default async function WorkspaceLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const hdrs = await headers();\n  const workspaceModule = hdrs.get(\"x-workspace-module\");\n  const locale = hdrs.get(\"x-locale\") ?? \"en\";\n\n  // Fetch menus\n  const menuItems = loadAllMenus() as MenuWorkspaceElement[];\n\n  // Fetch common messages and current module messages\n  const [commonMessages, currentModuleMessages] = await Promise.all([\n    import(`@base/client/messages/${locale}.json`)\n      .then((module) => module.default)\n      .catch(() => ({})),\n    workspaceModule\n      ? import(`@mdl/${workspaceModule}/client/messages/${locale}.json`)\n          .then((module) => module.default)\n          .catch(() => ({}))\n      : Promise.resolve({}),\n  ]);\n\n  // Get all module names\n  const allModuleNames = getModuleNames();\n\n  // Initial messages structure for zustand\n  const initialMessages = {\n    common: commonMessages,\n    ...(workspaceModule ? { [workspaceModule]: currentModuleMessages } : {}),\n  };\n\n  return (\n    <ModuleI18nProvider initialMessages={initialMessages} locale={locale}>\n      <WorkspaceLayoutClient\n        allModuleNames={allModuleNames}\n        currentModule={workspaceModule}\n        locale={locale}\n        menuItems={menuItems}\n      >\n        {children}\n      </WorkspaceLayoutClient>\n    </ModuleI18nProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/WorkspaceLayoutClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":86,"fix":{"range":[259,259],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/contexts/workspace`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":47,"fix":{"range":[15,307],"text":"import { usePathname } from \"next/navigation\";\nimport { WorkspaceProvider } from \"@base/client/contexts/workspace\";\nimport { usePrefetchModuleMessages } from \"@base/client/hooks/usePrefetchModuleMessages\";\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[351,351],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/contexts/workspace`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,352],"text":"import { useEffect, useState } from \"react\";\nimport { WorkspaceProvider } from \"@base/client/contexts/workspace\";\nimport { usePrefetchModuleMessages } from \"@base/client/hooks/usePrefetchModuleMessages\";\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\nimport { usePathname } from \"next/navigation\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SerializedNavigationItem' is defined but never used. Allowed unused vars must match /^_.*?$/u.","line":12,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pathname' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":35,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { WorkspaceProvider } from \"@base/client/contexts/workspace\";\nimport { usePrefetchModuleMessages } from \"@base/client/hooks/usePrefetchModuleMessages\";\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\nimport { usePathname } from \"next/navigation\";\nimport { useEffect, useState } from \"react\";\nimport Content from \"@base/client/layouts/workspace/components/Content\";\nimport MenuPanel from \"@base/client/layouts/workspace/components/Menu\";\nimport Nav from \"@base/client/layouts/workspace/components/Nav\";\n\ninterface SerializedNavigationItem {\n  name: string;\n  href: string;\n  icon: string;\n  badge?: string | null;\n}\n\ninterface WorkspaceLayoutClientProps {\n  children: React.ReactNode;\n  menuItems: MenuWorkspaceElement[];\n  allModuleNames: string[];\n  currentModule: string | null;\n  locale: string;\n}\n\nexport default function WorkspaceLayoutClient({\n  children,\n  menuItems,\n  allModuleNames,\n  currentModule,\n  locale,\n}: WorkspaceLayoutClientProps) {\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const pathname = usePathname();\n\n  // Prefetch messages for all other modules\n  usePrefetchModuleMessages(allModuleNames, currentModule, locale);\n\n  useEffect(() => {\n    const stored = window.localStorage.getItem(\"workspace_sidebar_pinned\");\n\n    setSidebarOpen(stored === \"false\" ? false : true);\n  }, []);\n\n  const handleToggleSidebar = () => {\n    setSidebarOpen((prev) => {\n      const next = !prev;\n\n      if (typeof window !== \"undefined\") {\n        window.localStorage.setItem(\"workspace_sidebar_pinned\", String(next));\n      }\n\n      return next;\n    });\n  };\n\n  return (\n    <WorkspaceProvider initialBreadcrumbs={[]}>\n      <div\n        className=\"w-full h-screen flex flex-col flex-1 overflow-hidden bg-slate-50\"\n        id=\"workspace-layout\"\n      >\n        {/* Top header */}\n        <Nav />\n        <div className=\"flex min-h-0 flex-1\">\n          <MenuPanel\n            isOpen={sidebarOpen}\n            menuItems={menuItems}\n            // Desktop menu: không auto đóng, giữ nguyên trạng thái pin/unpin\n            onClose={() => {}}\n            onToggleSidebar={handleToggleSidebar}\n          />\n\n          {/* Mobile sidebar overlay */}\n\n          <div className=\"w-full min-h-0 flex flex-1 h-full overflow-auto scroll-overlay\">\n            <div className=\"min-w-3xl flex flex-col flex-1\">\n              {/* Breadcrumb */}\n              {/* <div className=\"p-2\">\n                <Breadcrumb items={initialCrumbs} />\n              </div> */}\n\n              {/* Page content */}\n              <div className=\"flex-1 p-2\">\n                <Content>{children}</Content>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </WorkspaceProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/components/Breadcrumb.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":66,"fix":{"range":[161,161],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`lucide-react` import should occur before import of `@base/client/components`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,207],"text":"import { ChevronRight } from \"lucide-react\";\nimport { IBaseBreadcrumbItem, IBaseBreadcrumbs } from \"@base/client/components\";\nimport { useBreadcrumbs } from \"@base/client/contexts/workspace\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·items·}:·{·items?:·IBaseBreadcrumbItem[]·` with `⏎··items,⏎}:·{⏎··items?:·IBaseBreadcrumbItem[];⏎`","line":13,"column":37,"nodeType":null,"messageId":"replace","endLine":13,"endColumn":79,"fix":{"range":[386,428],"text":"\n  items,\n}: {\n  items?: IBaseBreadcrumbItem[];\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { IBaseBreadcrumbItem, IBaseBreadcrumbs } from \"@base/client/components\";\nimport { useBreadcrumbs } from \"@base/client/contexts/workspace\";\nimport { ChevronRight } from \"lucide-react\";\n\nexport type IBaseBreadcrumbItem = {\n  label: string;\n  href: string;\n  icon?: React.ComponentType<{ size?: number; className?: string }>;\n};\n\nexport default function Breadcrumb({ items }: { items?: IBaseBreadcrumbItem[] }) {\n  const ctx = useBreadcrumbs();\n  const data = items ?? ctx.breadcrumbs;\n\n  return (\n    <IBaseBreadcrumbs\n      itemClasses={{\n        base: \"gap-1 \",\n        separator: \"text-default-400\",\n        item: \"text-xs font-normal text-default-500 hover:text-default-700\",\n      }}\n      separator={<ChevronRight className=\"text-gray-400 mx-0\" size={12} />}\n    >\n      {data.map((item) => (\n        <IBaseBreadcrumbItem\n          key={item.href}\n          className={`${item.href ? \"hover:red\" : \"\"} ${data[data.length - 1] !== item ? \"italic\" : \"\"}`}\n          href={item.href}\n          startContent={\n            item.icon ? <item.icon className=\"mr-1\" size={16} /> : undefined\n          }\n        >\n          {item.label}\n        </IBaseBreadcrumbItem>\n      ))}\n    </IBaseBreadcrumbs>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/components/Content.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/components/Menu.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be no empty line within import group","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":89,"fix":{"range":[103,104],"text":""}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":89,"fix":{"range":[14,565],"text":"\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\nimport clsx from \"clsx\";\nimport { BarChart3, Boxes, Building2, ChevronDown, ChevronRight, Circle, ClipboardList, NewspaperIcon, Package, Pin, PinOff, Settings, ShoppingCart, TrendingUp, User, type LucideIcon } from \"lucide-react\";\nimport IBaseLink from \"next/link\";\nimport { usePathname } from \"next/navigation\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { IBaseDivider, IBaseScrollShadow, IBaseTooltip } from \"@base/client/components\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·IBaseDivider,·IBaseScrollShadow,·IBaseTooltip·` with `⏎··IBaseDivider,⏎··IBaseScrollShadow,⏎··IBaseTooltip,⏎`","line":2,"column":9,"nodeType":null,"messageId":"replace","endLine":2,"endColumn":56,"fix":{"range":[22,69],"text":"\n  IBaseDivider,\n  IBaseScrollShadow,\n  IBaseTooltip,\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":86,"fix":{"range":[189,189],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/interface/WorkspaceMenuInterface` import should occur after import of `react`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":86,"fix":{"range":[104,565],"text":"import clsx from \"clsx\";\nimport { BarChart3, Boxes, Building2, ChevronDown, ChevronRight, Circle, ClipboardList, NewspaperIcon, Package, Pin, PinOff, Settings, ShoppingCart, TrendingUp, User, type LucideIcon } from \"lucide-react\";\nimport IBaseLink from \"next/link\";\nimport { usePathname } from \"next/navigation\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·BarChart3,·Boxes,·Building2,·ChevronDown,·ChevronRight,·Circle,·ClipboardList,·NewspaperIcon,·Package,·Pin,·PinOff,·Settings,·ShoppingCart,·TrendingUp,·User,·type·LucideIcon·` with `⏎··BarChart3,⏎··Boxes,⏎··Building2,⏎··ChevronDown,⏎··ChevronRight,⏎··Circle,⏎··ClipboardList,⏎··NewspaperIcon,⏎··Package,⏎··Pin,⏎··PinOff,⏎··Settings,⏎··ShoppingCart,⏎··TrendingUp,⏎··User,⏎··type·LucideIcon,⏎`","line":6,"column":9,"nodeType":null,"messageId":"replace","endLine":6,"endColumn":184,"fix":{"range":[223,398],"text":"\n  BarChart3,\n  Boxes,\n  Building2,\n  ChevronDown,\n  ChevronRight,\n  Circle,\n  ClipboardList,\n  NewspaperIcon,\n  Package,\n  Pin,\n  PinOff,\n  Settings,\n  ShoppingCart,\n  TrendingUp,\n  User,\n  type LucideIcon,\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'findKeyByPath' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":122,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":6,"source":"\"use client\";\nimport { IBaseDivider, IBaseScrollShadow, IBaseTooltip } from \"@base/client/components\";\n\nimport { MenuWorkspaceElement } from \"@base/client/interface/WorkspaceMenuInterface\";\nimport clsx from \"clsx\";\nimport { BarChart3, Boxes, Building2, ChevronDown, ChevronRight, Circle, ClipboardList, NewspaperIcon, Package, Pin, PinOff, Settings, ShoppingCart, TrendingUp, User, type LucideIcon } from \"lucide-react\";\nimport IBaseLink from \"next/link\";\nimport { usePathname } from \"next/navigation\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\n\nconst KEY_WORKSPACE_LAST_MENU_PATH = \"last_menu_key\";\n\nconst ICON_MAP: Record<string, LucideIcon> = {\n  Package,\n  TrendingUp,\n  ClipboardList,\n  ShoppingCart,\n  Boxes,\n  BarChart3,\n  Building2,\n  Settings,\n  User,\n  NewspaperIcon,\n};\n\ninterface MenuProps {\n  menuItems: MenuWorkspaceElement[];\n  isOpen: boolean;\n  onClose: () => void;\n  onToggleSidebar?: () => void;\n}\n\nexport default function Menu({\n  isOpen,\n  onClose,\n  menuItems = [],\n  onToggleSidebar,\n}: MenuProps) {\n  // Split menu items by type\n  const mainMenus = menuItems.filter((item) => item.type === \"main\");\n  const moduleMenus = menuItems.filter((item) => item.type === \"mdl\");\n  const pathname = usePathname();\n  const [expandedItems, setExpandedItems] = useState<string[]>([]);\n  const [isHoverOpen, setIsHoverOpen] = useState(false);\n  const [activeKey, setActiveKey] = useState<string | null>(null);\n  const activeItemRef = useRef<HTMLButtonElement>(null);\n\n  const effectiveOpen = isOpen || isHoverOpen;\n\n  // Memoize the flattened menu list for efficiency\n  const flattenedMenus = useMemo(() => {\n    return menuItems\n      .flatMap((item) => {\n        if (item.children && item.children.length > 0) {\n          const children = item.children.flat();\n\n          return [item, ...children];\n        }\n\n        return [item];\n      })\n      .sort((a: any, b: any) => {\n        const lenA = (a.path || \"\").length;\n        const lenB = (b.path || \"\").length;\n\n        return lenB - lenA; // long to short\n      });\n  }, [menuItems]);\n\n  const toggleExpanded = (itemName: string) => {\n    setExpandedItems((prev) =>\n      prev.includes(itemName)\n        ? prev.filter((name) => name !== itemName)\n        : [...prev, itemName],\n    );\n  };\n\n  const normalizePath = (value: string) => {\n    if (!value) return \"/\";\n\n    const withLeading = value.startsWith(\"/\") ? value : `/${value}`;\n    const trimmed = withLeading.replace(/\\/+$/, \"\");\n\n    return trimmed || \"/\";\n  };\n\n  // Tìm tất cả các item cha cần expand theo một đường dẫn bất kỳ\n  const findParentItemsToExpandByPath = (\n    items: MenuWorkspaceElement[],\n    path: string,\n  ): string[] => {\n    const parentsToExpand: string[] = [];\n\n    const checkItem = (item: MenuWorkspaceElement): boolean => {\n      if (item.path && path) {\n        const normalized = normalizePath(path);\n        const itemPath = normalizePath(item.path);\n\n        if (normalized === itemPath || normalized.startsWith(`${itemPath}/`)) {\n          return true;\n        }\n      }\n\n      if (item.children) {\n        const hasActiveChild = item.children.some((child) => checkItem(child));\n\n        if (hasActiveChild) {\n          parentsToExpand.push(item.name);\n        }\n\n        return hasActiveChild;\n      }\n\n      return false;\n    };\n\n    items.forEach((item) => checkItem(item));\n\n    return parentsToExpand;\n  };\n\n  const findKeyByPath = (\n    items: MenuWorkspaceElement[],\n    path: string,\n  ): string | null => {\n    const normalized = normalizePath(path);\n    let foundKey: string | null = null;\n\n    const checkItem = (item: MenuWorkspaceElement): boolean => {\n      if (item.path) {\n        const itemPath = normalizePath(item.path);\n\n        if (normalized === itemPath || normalized.startsWith(`${itemPath}/`)) {\n          foundKey = item.key;\n\n          return true;\n        }\n      }\n\n      if (item.children) {\n        return item.children.some((child) => checkItem(child));\n      }\n\n      return false;\n    };\n\n    items.forEach((item) => checkItem(item));\n\n    return foundKey;\n  };\n\n  const hasActiveChildByKey = (\n    item: MenuWorkspaceElement,\n    key: string | null,\n  ): boolean => {\n    if (!key || !item.children) return false;\n\n    return item.children.some(\n      (child) => child.key === key || hasActiveChildByKey(child, key),\n    );\n  };\n\n  // Tự expand menu và highlight item đang active (ưu tiên theo pathname)\n  useEffect(() => {\n    const parentsToExpand: string[] = findParentItemsToExpandByPath(\n      flattenedMenus,\n      pathname,\n    );\n\n    const normalizedPathName = normalizePath(pathname);\n    const keyToSet: string | null =\n      flattenedMenus.find(\n        (item) => normalizePath(item.path || \"\") === normalizedPathName,\n      )?.key || null;\n\n    setActiveKey(keyToSet);\n\n    if (parentsToExpand.length > 0) {\n      setExpandedItems((prev) =>\n        Array.from(new Set([...prev, ...parentsToExpand])),\n      );\n    }\n  }, [pathname, menuItems]);\n\n  const renderIcon = (iconName: string | undefined, isHighlighted: boolean) => {\n    const IconComponent = (iconName && ICON_MAP[iconName]) || Circle;\n\n    return (\n      <span\n        className={clsx(\n          \"inline-flex h-7 w-7 items-center justify-center rounded-lg border text-[11px] flex-shrink-0\",\n          isHighlighted\n            ? \"bg-blue-600 border-blue-600 text-white shadow-sm\"\n            : \"bg-slate-50 border-slate-200 text-slate-500 group-hover:bg-blue-50 group-hover:border-blue-200 group-hover:text-blue-500\",\n        )}\n      >\n        <IconComponent className=\"h-4 w-4\" />\n      </span>\n    );\n  };\n\n  // Render menu item (workspace hoặc module)\n  const renderMenuItem = (item: MenuWorkspaceElement) => {\n    const hasChildren = item.children && item.children.length > 0;\n    const isExpanded = expandedItems.includes(item.name);\n    const itemPath = item.path;\n    const isItemActive = activeKey === item.key;\n    const hasActiveChildren =\n      hasChildren && hasActiveChildByKey(item, activeKey);\n    const isHighlighted = isItemActive || hasActiveChildren;\n\n    const content = (\n      <button\n        ref={isItemActive ? activeItemRef : null}\n        aria-current={isItemActive ? \"page\" : undefined}\n        aria-expanded={hasChildren ? isExpanded : undefined}\n        className={clsx(\n          \"group flex w-full items-center justify-between px-2 py-1 rounded-xl cursor-pointer transition-all duration-200 text-left\",\n          \"border border-transparent\",\n          isHighlighted\n            ? \"bg-blue-50 text-blue-700 border-blue-100 shadow-[0_0_0_1px_rgba(59,130,246,0.15)]\"\n            : \"text-slate-700 hover:bg-slate-50 hover:text-blue-600\",\n        )}\n        type=\"button\"\n        onClick={() => {\n          if (hasChildren) {\n            toggleExpanded(item.name);\n          }\n        }}\n      >\n        <div className=\"flex items-center flex-1 gap-2\">\n          {renderIcon(item.icon, Boolean(isHighlighted))}\n          <span\n            className={clsx(\n              \"text-xs font-semibold tracking-wide uppercase\",\n              \"whitespace-nowrap overflow-hidden text-ellipsis\",\n              \"transition-all duration-300\",\n              effectiveOpen\n                ? \"opacity-100 translate-x-0 max-w-[160px]\"\n                : \"opacity-0 -translate-x-1 max-w-0\",\n            )}\n          >\n            {item.name}\n          </span>\n        </div>\n\n        {hasChildren && (\n          <div\n            className={clsx(\n              \"transition-all duration-200\",\n              effectiveOpen ? \"opacity-100\" : \"opacity-0 hidden\",\n            )}\n          >\n            {isExpanded ? (\n              <ChevronDown className=\"text-slate-400\" size={14} />\n            ) : (\n              <ChevronRight className=\"text-slate-400\" size={14} />\n            )}\n          </div>\n        )}\n      </button>\n    );\n\n    return (\n      <div key={item.name} className=\"mb-1\">\n        {hasChildren ? (\n          <>\n            {effectiveOpen ? (\n              content\n            ) : (\n              <IBaseTooltip content={item.name} placement=\"right\">\n                {content}\n              </IBaseTooltip>\n            )}\n          </>\n        ) : (\n          <IBaseLink\n            className=\"block\"\n            href={itemPath || \"#\"}\n            onClick={() => {\n              if (typeof window !== \"undefined\" && item.key) {\n                window.localStorage.setItem(\n                  KEY_WORKSPACE_LAST_MENU_PATH,\n                  item.key,\n                );\n              }\n\n              setActiveKey(item.key);\n\n              onClose();\n            }}\n          >\n            {effectiveOpen ? (\n              content\n            ) : (\n              <IBaseTooltip content={item.name} placement=\"right\">\n                {content}\n              </IBaseTooltip>\n            )}\n          </IBaseLink>\n        )}\n\n        {hasChildren && isExpanded && (\n          <div\n            className={clsx(\n              \"mt-1 ml-3 space-y-1 border-l border-slate-100 pl-3\",\n              \"transition-all duration-200\",\n              effectiveOpen\n                ? \"opacity-100\"\n                : \"opacity-0 max-h-0 overflow-hidden\",\n            )}\n          >\n            {item.children?.map((child) => {\n              const childPath = child.path;\n              const childAs = child.as;\n              const isChildActive = activeKey === child.key;\n\n              return (\n                <IBaseLink\n                  key={child.name}\n                  as={childAs || childPath}\n                  className={clsx(\n                    \"flex items-center justify-between rounded-lg px-2 py-1.5 text-xs transition-all duration-150\",\n                    isChildActive\n                      ? \"bg-blue-100 text-blue-700 font-medium\"\n                      : \"text-slate-600 hover:bg-slate-50 hover:text-blue-600\",\n                  )}\n                  href={childPath || \"#\"}\n                  onClick={() => {\n                    if (typeof window !== \"undefined\" && child.key) {\n                      window.localStorage.setItem(\n                        KEY_WORKSPACE_LAST_MENU_PATH,\n                        child.key,\n                      );\n                    }\n\n                    setActiveKey(child.key);\n\n                    onClose();\n                  }}\n                >\n                  <div className=\"flex items-center gap-2\">\n                    <span\n                      className={clsx(\n                        \"transition-all duration-300 whitespace-nowrap overflow-hidden text-ellipsis\",\n                        effectiveOpen\n                          ? \"opacity-100 translate-x-0 max-w-[160px]\"\n                          : \"opacity-0 -translate-x-1 max-w-0\",\n                      )}\n                    >\n                      {child.name}\n                    </span>\n                  </div>\n\n                  {child.badge && effectiveOpen && (\n                    <span className=\"rounded-full bg-blue-50 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-blue-600\">\n                      {child.badge}\n                    </span>\n                  )}\n                </IBaseLink>\n              );\n            })}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  return (\n    <>\n      {/* Desktop sidebar */}\n      <aside\n        aria-label=\"Workspace navigation\"\n        className={clsx(\n          \"hidden lg:flex lg:flex-col flex-shrink-0 transition-all duration-300 ease-in-out\",\n          \"bg-white/90 backdrop-blur border-r border-slate-100 shadow-sm\",\n          effectiveOpen ? \"w-64\" : \"w-[4.25rem]\",\n        )}\n        onMouseEnter={() => {\n          if (!isOpen) {\n            setIsHoverOpen(true);\n          }\n        }}\n        onMouseLeave={() => {\n          if (!isOpen) {\n            setIsHoverOpen(false);\n          }\n        }}\n      >\n        <IBaseScrollShadow className=\"flex-1 px-2 pb-4 pt-2\">\n          {/* Header + toggle */}\n          <div\n            className={clsx(\n              \"mb-2 flex items-center gap-2 rounded-xl px-2 py-1.5\",\n              \"bg-slate-50/80 border border-slate-100\",\n              effectiveOpen ? \"justify-between\" : \"justify-center\",\n            )}\n          >\n            <div\n              className={clsx(\n                \"flex-auto text-[11px] font-semibold uppercase tracking-[0.16em] text-slate-500\",\n                \"transition-all duration-300 whitespace-nowrap overflow-hidden\",\n                effectiveOpen\n                  ? \"opacity-100 translate-x-0 max-w-[160px]\"\n                  : \"opacity-0 -translate-x-1 max-w-0\",\n              )}\n            >\n              Main\n            </div>\n\n            <button\n              aria-label={isOpen ? \"Bỏ ghim menu\" : \"Ghim menu\"}\n              className=\"cursor-pointer inline-flex h-7 w-7 items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-500 hover:bg-slate-50 hover:text-slate-700 transition-all\"\n              type=\"button\"\n              onClick={onToggleSidebar}\n            >\n              {isOpen ? (\n                <Pin className=\"h-4 w-4\" />\n              ) : (\n                <PinOff className=\"h-4 w-4 text-warning-500\" />\n              )}\n            </button>\n          </div>\n\n          <div className=\"space-y-1\">{mainMenus.map(renderMenuItem)}</div>\n\n          {moduleMenus.length > 0 && (\n            <>\n              <IBaseDivider className=\"my-3 bg-slate-100\" />\n              <div className=\"space-y-1\">{moduleMenus.map(renderMenuItem)}</div>\n            </>\n          )}\n        </IBaseScrollShadow>\n      </aside>\n    </>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/layouts/workspace/components/Nav.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":80,"fix":{"range":[14,465],"text":"\nimport type { IBaseDropdownItem } from \"@base/client/components\";\n\nimport {\n  IBaseNavbar,\n  IBaseDropdown,\n  IBaseNavbarBrand,\n  IBaseNavbarContent,\n  IBaseNavbarItem,\n} from \"@base/client/components\";\nimport { Bell, LogOut, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\nimport { IBaseAvatar, IBaseBadge, IBaseButton } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":34,"fix":{"range":[297,297],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":34,"fix":{"range":[162,465],"text":"import { Bell, LogOut, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\nimport {\n  IBaseNavbar,\n  IBaseDropdown,\n  IBaseNavbarBrand,\n  IBaseNavbarContent,\n  IBaseNavbarItem,\n} from \"@base/client/components\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":44,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":44,"endColumn":22,"suggestions":[{"fix":{"range":[1274,1305],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":49,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":49,"endColumn":20,"suggestions":[{"fix":{"range":[1424,1462],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\nimport { IBaseAvatar, IBaseBadge, IBaseButton } from \"@base/client/components\";\n\nimport type { IBaseDropdownItem } from \"@base/client/components\";\n\nimport {\n  IBaseNavbar,\n  IBaseDropdown,\n  IBaseNavbarBrand,\n  IBaseNavbarContent,\n  IBaseNavbarItem,\n} from \"@base/client/components\";\nimport { Bell, LogOut, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\n\nimport { siteConfig } from \"@/config/site\";\n\nconst DEFAULT_AVATAR = \"/favicon/favicon-32x32.png\";\n\nexport default function Nav() {\n  const router = useRouter();\n  const [avatarError, setAvatarError] = useState(false);\n  const [isLoggingOut, setIsLoggingOut] = useState(false);\n\n  // TODO: Get user data from session/context\n  const userAvatar = \"https://i.pravatar.cc/150?u=a042581f4e29026024d\";\n  const displayAvatar = avatarError ? DEFAULT_AVATAR : userAvatar;\n\n  const handleLogout = async () => {\n    try {\n      setIsLoggingOut(true);\n      const response = await fetch(\"/api/base/auth/logout\", {\n        method: \"POST\",\n        credentials: \"include\",\n      });\n\n      if (response.ok) {\n        // Redirect to login page\n        router.push(\"/login\");\n        router.refresh();\n      } else {\n        console.error(\"Logout failed\");\n        // Still redirect even if logout API fails\n        router.push(\"/login\");\n      }\n    } catch (error) {\n      console.error(\"Logout error:\", error);\n      // Still redirect on error\n      router.push(\"/login\");\n    } finally {\n      setIsLoggingOut(false);\n    }\n  };\n\n  return (\n    <IBaseNavbar\n      shouldHideOnScroll\n      className=\"border-b border-gray-200 bg-white\"\n      classNames={{\n        wrapper: \"px-4\",\n      }}\n      height=\"48px\"\n      maxWidth=\"full\"\n    >\n      <IBaseNavbarBrand as=\"li\" className=\"gap-3 max-w-fit\">\n        <div className=\"flex items-center\">\n          <IBaseImage\n            priority\n            alt={siteConfig.name}\n            className=\"mr-3 rounded-lg bg-white\"\n            height={32}\n            src=\"/favicon/logo.png\"\n            width={32}\n          />\n          <h1 className=\"text-xl font-bold text-orange-600\">\n            {siteConfig.name}\n          </h1>\n        </div>\n      </IBaseNavbarBrand>\n\n      <IBaseNavbarContent className=\"hidden md:flex\" justify=\"end\">\n        {/* <IBaseNavbarItem className=\"hidden sm:flex\">\n          <IBaseButton isIconOnly size=\"sm\" variant=\"light\">\n            <Sun size={20} />\n          </IBaseButton>\n        </IBaseNavbarItem> */}\n        <IBaseNavbarItem>\n          <IBaseBadge\n            color=\"danger\"\n            content=\"\"\n            isInvisible={false}\n            placement=\"top-right\"\n            shape=\"circle\"\n          >\n            <IBaseButton isIconOnly size=\"sm\" variant=\"light\">\n              <Bell size={20} />\n            </IBaseButton>\n          </IBaseBadge>\n        </IBaseNavbarItem>\n        <IBaseNavbarItem>\n          <IBaseDropdown\n            items={[\n              {\n                key: \"logout\",\n                color: \"danger\",\n                isDisabled: isLoggingOut,\n                startContent: <LogOut size={16} />,\n                textValue: \"Logout\",\n                onPress: handleLogout,\n                children: isLoggingOut ? \"Logging out...\" : \"Logout\",\n              } satisfies IBaseDropdownItem,\n            ]}\n            menu={{\n              \"aria-label\": \"User menu\",\n              variant: \"flat\",\n            }}\n            placement=\"bottom-end\"\n          >\n            <IBaseAvatar\n              className=\"cursor-pointer transition-transform hover:scale-105\"\n              fallback={\n                <User className=\"text-default-500\" size={16} strokeWidth={2} />\n              }\n              size=\"sm\"\n              src={displayAvatar}\n              onError={() => setAvatarError(true)}\n            />\n          </IBaseDropdown>\n        </IBaseNavbarItem>\n      </IBaseNavbarContent>\n    </IBaseNavbar>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Admin/ModelsViewList/ModelsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[116,116],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `next-intl`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,443],"text":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport MiniSearch from \"minisearch\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  IBaseTable,\n  IBaseTableColumnDefinition,\n} from \"@base/client/components/IBaseTable\";\nimport { useTranslations } from \"next-intl\";\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseInput,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":67,"fix":{"range":[299,299],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":45,"fix":{"range":[397,397],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components/IBaseTable` import should occur after import of `next-intl`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":45,"fix":{"range":[300,443],"text":"import { useTranslations } from \"next-intl\";\nimport {\n  IBaseTable,\n  IBaseTableColumnDefinition,\n} from \"@base/client/components/IBaseTable\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseInput,\n} from \"@base/client/components\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport MiniSearch from \"minisearch\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  IBaseTable,\n  IBaseTableColumnDefinition,\n} from \"@base/client/components/IBaseTable\";\nimport { useTranslations } from \"next-intl\";\n\nimport adminModelService, {\n  type ModelRow,\n  type ReloadModelRequest,\n  type ReloadModelResponse,\n} from \"./services/AdminModelService\";\n\nconst MODEL_LIST_QUERY_KEY = [\"admin\", \"models\", \"list\"] as const;\n\nexport default function ModelsListPage() {\n  const t = useTranslations(\"admin.models\");\n  const actionsT = useTranslations(\"common.actions\");\n  const queryClient = useQueryClient();\n  const [actionError, setActionError] = useState<string | null>(null);\n  const [searchTerm, setSearchTerm] = useState<string>(\"\");\n  const [toast, setToast] = useState<{\n    message: string;\n    type: \"error\" | \"success\";\n  } | null>(null);\n\n  const showToast = useCallback(\n    (message: string, type: \"error\" | \"success\" = \"error\") => {\n      setToast({ message, type });\n    },\n    [],\n  );\n\n  useEffect(() => {\n    if (!toast) return;\n\n    const timer = setTimeout(() => {\n      setToast(null);\n    }, 4000);\n\n    return () => clearTimeout(timer);\n  }, [toast]);\n\n  const modelListQuery = useQuery<ModelRow[], Error>({\n    queryKey: MODEL_LIST_QUERY_KEY,\n    queryFn: async () => {\n      const response = await adminModelService.getModelList();\n\n      return response.data;\n    },\n  });\n\n  const reloadModelMutation = useMutation<\n    ReloadModelResponse,\n    Error,\n    ReloadModelRequest\n  >({\n    mutationFn: (payload: ReloadModelRequest) =>\n      adminModelService.reloadModel(payload),\n    onSuccess: (data, variables) => {\n      if (!data.success) {\n        const errorMessage =\n          data.message || t(\"toast.reloadError\", { key: variables.key });\n\n        setActionError(errorMessage);\n        showToast(errorMessage, \"error\");\n\n        return;\n      }\n\n      const successMessage =\n        data.message || t(\"toast.reloadSuccess\", { key: variables.key });\n\n      setActionError(null);\n      showToast(successMessage, \"success\");\n      queryClient.invalidateQueries({ queryKey: MODEL_LIST_QUERY_KEY });\n    },\n    onError: (error, variables) => {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : t(\"toast.reloadError\", { key: variables?.key ?? \"-\" });\n\n      setActionError(errorMessage);\n      showToast(errorMessage, \"error\");\n    },\n  });\n\n  const handleReload = useCallback(\n    (key: string) => {\n      setActionError(null);\n      reloadModelMutation.mutate({ key });\n    },\n    [reloadModelMutation],\n  );\n\n  const handleRefresh = useCallback(() => {\n    setActionError(null);\n    modelListQuery.refetch();\n  }, [modelListQuery]);\n\n  const models = modelListQuery.data ?? [];\n  const currentReloadKey = reloadModelMutation.variables?.key;\n  const loading = modelListQuery.isLoading || modelListQuery.isFetching;\n  const queryErrorMessage =\n    modelListQuery.error instanceof Error ? t(\"toast.loadError\") : null;\n\n  useEffect(() => {\n    if (queryErrorMessage) {\n      showToast(queryErrorMessage, \"error\");\n    }\n  }, [queryErrorMessage, showToast]);\n\n  const miniSearch = useMemo(() => {\n    const search = new MiniSearch<ModelRow>({\n      fields: [\"key\", \"module\", \"path\"],\n      storeFields: [\"key\", \"module\", \"path\"],\n      idField: \"key\",\n    });\n\n    if (models.length) {\n      search.addAll(models);\n    }\n\n    return search;\n  }, [models]);\n\n  const filteredModels = useMemo<ModelRow[]>(() => {\n    if (!searchTerm.trim()) {\n      return models;\n    }\n\n    const results = miniSearch.search(searchTerm, {\n      prefix: true,\n      fuzzy: 0.2,\n    });\n\n    if (!results.length) {\n      return [];\n    }\n\n    return results.map(({ key, module, path }) => ({ key, module, path }));\n  }, [miniSearch, models, searchTerm]);\n\n  const columns = useMemo<IBaseTableColumnDefinition<ModelRow>[]>(\n    () => [\n      { key: \"key\", label: t(\"table.columns.key\") },\n      { key: \"module\", label: t(\"table.columns.module\") },\n      { key: \"path\", label: t(\"table.columns.path\") },\n      {\n        key: \"action\",\n        label: actionsT(\"action\"),\n        align: \"end\",\n        render: (_, record) => (\n          <IBaseButton\n            color=\"primary\"\n            isDisabled={\n              loading ||\n              (reloadModelMutation.isPending && currentReloadKey === record.key)\n            }\n            isLoading={\n              reloadModelMutation.isPending && currentReloadKey === record.key\n            }\n            size=\"sm\"\n            onPress={() => handleReload(record.key)}\n          >\n            {actionsT(\"reload\")}\n          </IBaseButton>\n        ),\n      },\n    ],\n    [\n      actionsT,\n      currentReloadKey,\n      handleReload,\n      loading,\n      reloadModelMutation.isPending,\n      t,\n    ],\n  );\n\n  const emptyStateMessage =\n    actionError ||\n    queryErrorMessage ||\n    (searchTerm.trim() && filteredModels.length === 0\n      ? t(\"table.empty.search\")\n      : t(\"table.empty.default\"));\n\n  return (\n    <IBaseCard>\n      <IBaseCardBody className=\"flex flex-col gap-4\">\n        <div className=\"flex flex-col gap-4\">\n          <div className=\"flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between\">\n            <IBaseInput\n              isClearable\n              classNames={{\n                input: \"text-sm\",\n              }}\n              labelPlacement=\"outside\"\n              placeholder={t(\"filters.searchPlaceholder\")}\n              size=\"sm\"\n              value={searchTerm}\n              onClear={() => setSearchTerm(\"\")}\n              onValueChange={setSearchTerm}\n            />\n          </div>\n          <IBaseTable\n            columns={columns}\n            dataSource={filteredModels}\n            emptyContent={emptyStateMessage}\n            loading={loading}\n            pagination={false}\n            rowKey=\"key\"\n            total={filteredModels.length}\n            onRefresh={handleRefresh}\n          />\n        </div>\n        {toast && (\n          <div className=\"fixed right-4 top-4 z-50 flex max-w-sm flex-col gap-2\">\n            <div\n              className={`rounded-medium px-4 py-3 text-sm shadow-large ${toast.type === \"error\" ? \"bg-danger-100 text-danger\" : \"bg-success-100 text-success\"}`}\n            >\n              {toast.message}\n            </div>\n          </div>\n        )}\n      </IBaseCardBody>\n    </IBaseCard>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Admin/ModelsViewList/services/AdminModelService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Auth/Login.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[15,326],"text":"import { Eye, EyeOff } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseCheckbox,\n  IBaseInput,\n  IBaseLink,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":58,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseCheckbox,\n  IBaseInput,\n  IBaseLink,\n} from \"@base/client/components\";\nimport { Eye, EyeOff } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\n\nexport default function LoginPage() {\n  const router = useRouter();\n  const [username, setUsername] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [rememberMe, setRememberMe] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isPasswordVisible, setIsPasswordVisible] = useState(false);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n    setIsLoading(true);\n\n    try {\n      const trimmedUsername = username.trim();\n      const trimmedPassword = password.trim();\n\n      const response = await fetch(\"/api/base/auth/login\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          username: trimmedUsername,\n          password: trimmedPassword,\n          rememberMe,\n        }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        setError(data.message || \"Login failed\");\n\n        return;\n      }\n\n      // Redirect to news page\n      router.push(\"/workspace/news\");\n      router.refresh();\n    } catch (err) {\n      setError(\"An error occurred. Please try again.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8\">\n      <IBaseCard className=\"w-full max-w-md\">\n        <IBaseCardHeader className=\"flex flex-col gap-1 px-6 pt-6\">\n          <div className=\"flex flex-col items-center gap-3 mb-2\">\n            <div className=\"flex items-center gap-3\">\n              <IBaseImage\n                alt=\"BAVADU Logo\"\n                className=\"object-contain\"\n                height={48}\n                src=\"/favicon/logo.png\"\n                width={48}\n              />\n              <h2 className=\"text-3xl font-bold text-orange-500\">BAVADU</h2>\n            </div>\n          </div>\n          <h1 className=\"text-2xl font-bold\">Sign in to your account</h1>\n          <p className=\"text-sm text-gray-500\">\n            Enter your credentials to access your account\n          </p>\n        </IBaseCardHeader>\n        <IBaseCardBody className=\"px-6 pb-6\">\n          <form className=\"flex flex-col gap-4\" onSubmit={handleSubmit}>\n            {error && (\n              <div className=\"rounded-md bg-red-50 p-4 text-sm text-red-800\">\n                {error}\n              </div>\n            )}\n\n            <IBaseInput\n              required\n              autoComplete=\"username\"\n              label=\"Username\"\n              placeholder=\"Enter your username\"\n              value={username}\n              variant=\"bordered\"\n              onChange={(e) => setUsername(e.target.value)}\n            />\n\n            <IBaseInput\n              required\n              autoComplete=\"current-password\"\n              endContent={\n                <button\n                  aria-label={\n                    isPasswordVisible ? \"Hide password\" : \"Show password\"\n                  }\n                  className=\"focus:outline-none\"\n                  type=\"button\"\n                  onClick={() => setIsPasswordVisible(!isPasswordVisible)}\n                >\n                  {isPasswordVisible ? (\n                    <EyeOff\n                      className=\"text-default-400 pointer-events-none\"\n                      size={20}\n                    />\n                  ) : (\n                    <Eye\n                      className=\"text-default-400 pointer-events-none\"\n                      size={20}\n                    />\n                  )}\n                </button>\n              }\n              label=\"Password\"\n              placeholder=\"Enter your password\"\n              type={isPasswordVisible ? \"text\" : \"password\"}\n              value={password}\n              variant=\"bordered\"\n              onChange={(e) => setPassword(e.target.value)}\n            />\n\n            <div className=\"flex items-center justify-between\">\n              <IBaseCheckbox\n                isSelected={rememberMe}\n                size=\"sm\"\n                onValueChange={setRememberMe}\n              >\n                <span className=\"text-sm\">Remember me</span>\n              </IBaseCheckbox>\n              <IBaseLink\n                className=\"text-sm text-primary-600 hover:text-primary-500\"\n                href=\"/reset-password\"\n              >\n                Forgot password?\n              </IBaseLink>\n            </div>\n\n            <IBaseButton\n              className=\"w-full\"\n              color=\"primary\"\n              isLoading={isLoading}\n              size=\"lg\"\n              type=\"submit\"\n            >\n              Sign in\n            </IBaseButton>\n          </form>\n        </IBaseCardBody>\n      </IBaseCard>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Auth/ResetPassword.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[148,148],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[15,183],"text":"import { useState } from \"react\";\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseLink,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":38,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":17},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":52,"column":17,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[1498,1580],"text":"\n              We&apos;ve sent a password reset link to your email address\n            "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[1498,1580],"text":"\n              We&lsquo;ve sent a password reset link to your email address\n            "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[1498,1580],"text":"\n              We&#39;ve sent a password reset link to your email address\n            "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[1498,1580],"text":"\n              We&rsquo;ve sent a password reset link to your email address\n            "},"desc":"Replace with `&rsquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":77,"column":44,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[2499,2608],"text":"\n            Enter your email address and we&apos;ll send you a link to reset your\n            password\n          "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[2499,2608],"text":"\n            Enter your email address and we&lsquo;ll send you a link to reset your\n            password\n          "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[2499,2608],"text":"\n            Enter your email address and we&#39;ll send you a link to reset your\n            password\n          "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[2499,2608],"text":"\n            Enter your email address and we&rsquo;ll send you a link to reset your\n            password\n          "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseLink,\n} from \"@base/client/components\";\nimport { useState } from \"react\";\n\nexport default function ResetPasswordPage() {\n  const [email, setEmail] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSubmitted, setIsSubmitted] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n    setIsLoading(true);\n\n    try {\n      // TODO: Implement reset password API call\n      // const response = await fetch(\"/api/base/auth/reset-password\", {\n      //   method: \"POST\",\n      //   headers: {\n      //     \"Content-Type\": \"application/json\",\n      //   },\n      //   body: JSON.stringify({ email }),\n      // });\n\n      // Simulate API call\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      setIsSubmitted(true);\n    } catch (err) {\n      setError(\"An error occurred. Please try again.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (isSubmitted) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8\">\n        <IBaseCard className=\"w-full max-w-md\">\n          <IBaseCardHeader className=\"flex flex-col gap-1 px-6 pt-6\">\n            <h1 className=\"text-2xl font-bold\">Check your email</h1>\n            <p className=\"text-sm text-gray-500\">\n              We've sent a password reset link to your email address\n            </p>\n          </IBaseCardHeader>\n          <IBaseCardBody className=\"px-6 pb-6\">\n            <div className=\"flex flex-col gap-4\">\n              <p className=\"text-sm text-gray-600\">\n                If an account exists with the email <strong>{email}</strong>,\n                you will receive a password reset link shortly.\n              </p>\n              <IBaseLink className=\"text-sm text-primary-600\" href=\"/login\">\n                Back to login\n              </IBaseLink>\n            </div>\n          </IBaseCardBody>\n        </IBaseCard>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8\">\n      <IBaseCard className=\"w-full max-w-md\">\n        <IBaseCardHeader className=\"flex flex-col gap-1 px-6 pt-6\">\n          <h1 className=\"text-2xl font-bold\">Reset your password</h1>\n          <p className=\"text-sm text-gray-500\">\n            Enter your email address and we'll send you a link to reset your\n            password\n          </p>\n        </IBaseCardHeader>\n        <IBaseCardBody className=\"px-6 pb-6\">\n          <form className=\"flex flex-col gap-4\" onSubmit={handleSubmit}>\n            {error && (\n              <div className=\"rounded-md bg-red-50 p-4 text-sm text-red-800\">\n                {error}\n              </div>\n            )}\n\n            <IBaseInput\n              required\n              autoComplete=\"email\"\n              label=\"Email\"\n              placeholder=\"Enter your email\"\n              type=\"email\"\n              value={email}\n              variant=\"bordered\"\n              onChange={(e) => setEmail(e.target.value)}\n            />\n\n            <IBaseButton\n              className=\"w-full\"\n              color=\"primary\"\n              isLoading={isLoading}\n              size=\"lg\"\n              type=\"submit\"\n            >\n              Send reset link\n            </IBaseButton>\n\n            <div className=\"text-center\">\n              <IBaseLink\n                className=\"text-sm text-primary-600 hover:text-primary-500\"\n                href=\"/login\"\n              >\n                Back to login\n              </IBaseLink>\n            </div>\n          </form>\n        </IBaseCardBody>\n      </IBaseCard>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/News/NewsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[15,457],"text":"import newsService from \"@base/client/services/NewsService\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { Calendar, ChevronDown, Eye, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useMemo } from \"react\";\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseSpinner,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/NewsService` import should occur after import of `react`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":61,"fix":{"range":[138,457],"text":"import { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { Calendar, ChevronDown, Eye, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useMemo } from \"react\";\nimport newsService from \"@base/client/services/NewsService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":65,"fix":{"range":[263,263],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/utils/date/formatDate` import should occur after import of `react`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":65,"fix":{"range":[199,457],"text":"import { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { Calendar, ChevronDown, Eye, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useMemo } from \"react\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pagination' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":44,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":19},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":186,"column":16,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[6298,6361],"text":"\n            You&apos;ve reached the end of the news list\n          "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[6298,6361],"text":"\n            You&lsquo;ve reached the end of the news list\n          "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[6298,6361],"text":"\n            You&#39;ve reached the end of the news list\n          "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[6298,6361],"text":"\n            You&rsquo;ve reached the end of the news list\n          "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseSpinner,\n} from \"@base/client/components\";\nimport newsService from \"@base/client/services/NewsService\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { useInfiniteQuery } from \"@tanstack/react-query\";\nimport { Calendar, ChevronDown, Eye, User } from \"lucide-react\";\nimport IBaseImage from \"next/image\";\nimport { useMemo } from \"react\";\n\nconst ITEMS_PER_PAGE = 12;\n\nexport default function NewsListPage() {\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n    isLoading,\n    error,\n  } = useInfiniteQuery({\n    queryKey: [\"news\"],\n    queryFn: ({ pageParam = 0 }) =>\n      newsService.getList(ITEMS_PER_PAGE, pageParam),\n    getNextPageParam: (lastPage) => {\n      if (!lastPage.pagination?.hasMore) return undefined;\n\n      return (lastPage.pagination?.offset || 0) + ITEMS_PER_PAGE;\n    },\n    initialPageParam: 0,\n  });\n\n  // Flatten all pages into a single array\n  const news = useMemo(() => {\n    return data?.pages.flatMap((page) => page.data || []) || [];\n  }, [data]);\n\n  const pagination = data?.pages[data.pages.length - 1]?.pagination;\n\n  if (isLoading) {\n    return (\n      <div className=\"flex min-h-[60vh] items-center justify-center\">\n        <IBaseSpinner color=\"primary\" size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"container mx-auto px-4 py-8\">\n        <IBaseCard className=\"border-danger-200 bg-danger-50\">\n          <IBaseCardBody>\n            <p className=\"text-center text-danger-600\">\n              Failed to load news. Please try again later.\n            </p>\n          </IBaseCardBody>\n        </IBaseCard>\n      </div>\n    );\n  }\n\n  if (!news || news.length === 0) {\n    return (\n      <div className=\"container mx-auto px-4 py-8\">\n        <IBaseCard className=\"border-gray-200\">\n          <IBaseCardBody className=\"py-12\">\n            <div className=\"text-center\">\n              <p className=\"text-gray-500\">No news available yet.</p>\n              <p className=\"mt-2 text-sm text-gray-400\">\n                Check back later for updates\n              </p>\n            </div>\n          </IBaseCardBody>\n        </IBaseCard>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"container mx-auto px-4 py-8\">\n      {/* Header */}\n\n      {/* News Grid */}\n      <div className=\"grid gap-6 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\n        {news.map((item) => (\n          <IBaseCard\n            key={item.id}\n            isPressable\n            className=\"group cursor-pointer border border-gray-200 transition-all hover:border-primary-300 hover:shadow-lg\"\n          >\n            {item.imageUrl && (\n              <div className=\"relative h-48 w-full overflow-hidden rounded-t-lg\">\n                <IBaseImage\n                  fill\n                  alt={item.title}\n                  className=\"object-cover transition-transform duration-300 group-hover:scale-105\"\n                  src={item.imageUrl}\n                />\n                <div className=\"absolute inset-0 bg-gradient-to-t from-black/20 to-transparent\" />\n              </div>\n            )}\n            <IBaseCardHeader className=\"flex flex-col items-start gap-2 px-4 pt-4\">\n              <h2 className=\"line-clamp-2 text-lg font-semibold text-gray-900 group-hover:text-primary-600 transition-colors\">\n                {item.title}\n              </h2>\n              {item.summary && (\n                <p className=\"line-clamp-2 text-sm text-gray-600\">\n                  {item.summary}\n                </p>\n              )}\n            </IBaseCardHeader>\n            <IBaseCardBody className=\"px-4 pb-4\">\n              <div className=\"flex flex-wrap items-center gap-3 text-xs text-gray-500\">\n                <div className=\"flex items-center gap-1.5\">\n                  <Calendar className=\"text-gray-400\" size={14} />\n                  <span>\n                    {item.publishedAt\n                      ? formatDate(item.publishedAt)\n                      : formatDate(item.createdAt)}\n                  </span>\n                </div>\n                <div className=\"flex items-center gap-1.5\">\n                  <Eye className=\"text-gray-400\" size={14} />\n                  <span>{item.viewCount || \"0\"}</span>\n                </div>\n                {item.authorName && (\n                  <div className=\"flex items-center gap-1.5\">\n                    <User className=\"text-gray-400\" size={14} />\n                    <span className=\"truncate max-w-[100px]\">\n                      {item.authorName}\n                    </span>\n                  </div>\n                )}\n              </div>\n              {item.tags && item.tags.length > 0 && (\n                <div className=\"mt-3 flex flex-wrap gap-2\">\n                  {item.tags.slice(0, 3).map((tag, index) => (\n                    <span\n                      key={index}\n                      className=\"rounded-full bg-primary-50 px-2.5 py-1 text-xs font-medium text-primary-700 transition-colors hover:bg-primary-100\"\n                    >\n                      {tag}\n                    </span>\n                  ))}\n                  {item.tags.length > 3 && (\n                    <span className=\"rounded-full bg-gray-100 px-2.5 py-1 text-xs font-medium text-gray-600\">\n                      +{item.tags.length - 3}\n                    </span>\n                  )}\n                </div>\n              )}\n            </IBaseCardBody>\n          </IBaseCard>\n        ))}\n      </div>\n\n      {/* Load More IBaseButton */}\n      {hasNextPage && (\n        <div className=\"mt-8 flex justify-center\">\n          <IBaseButton\n            className=\"min-w-[140px]\"\n            color=\"primary\"\n            endContent={\n              !isFetchingNextPage ? <ChevronDown size={18} /> : undefined\n            }\n            isLoading={isFetchingNextPage}\n            size=\"lg\"\n            variant=\"flat\"\n            onPress={() => fetchNextPage()}\n          >\n            {isFetchingNextPage ? \"Loading...\" : \"Load More\"}\n          </IBaseButton>\n        </div>\n      )}\n\n      {/* End of list message */}\n      {!hasNextPage && news.length > 0 && (\n        <div className=\"mt-8 text-center\">\n          <p className=\"text-sm text-gray-500\">\n            You've reached the end of the news list\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Settings/Roles/RoleCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":66,"fix":{"range":[89,585],"text":"import {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\nimport roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\nimport { IBaseButton, IBaseCard } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":34,"fix":{"range":[155,585],"text":"import roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\nimport {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":61,"fix":{"range":[368,368],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/RoleService` import should occur after import of `react`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":61,"fix":{"range":[308,585],"text":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\nimport roleService from \"@base/client/services/RoleService\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·key={permission.id}·textValue={permission.key}` with `⏎····················key={permission.id}⏎····················textValue={permission.key}⏎··················`","line":178,"column":35,"nodeType":null,"messageId":"replace","endLine":178,"endColumn":82,"fix":{"range":[5643,5690],"text":"\n                    key={permission.id}\n                    textValue={permission.key}\n                  "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport { IBaseButton, IBaseCard } from \"@base/client/components\";\nimport {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\nimport roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\n\nconst PERMISSIONS_QUERY_KEY = [\"settings\", \"permissions\", \"list\"] as const;\nconst ROLES_LIST_QUERY_KEY = [\"settings\", \"roles\", \"list\"] as const;\n\nexport default function RoleCreatePage() {\n  const t = useTranslations(\"settings.roles\");\n  const actionsT = useTranslations(\"common.actions\");\n  const errorsT = useTranslations(\"common.errors\");\n  const queryClient = useQueryClient();\n  const router = useRouter();\n\n  const [code, setCode] = useState(\"\");\n  const [name, setName] = useState<LocalizeText>({\n    en: undefined,\n    vi: undefined,\n  });\n  const [description, setDescription] = useState(\"\");\n  const [selectedPermissionIds, setSelectedPermissionIds] = useState<string[]>(\n    [],\n  );\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [toast, setToast] = useState<{\n    message: string;\n    type: \"error\" | \"success\";\n  } | null>(null);\n\n  const permissionsQuery = useQuery({\n    queryKey: PERMISSIONS_QUERY_KEY,\n    queryFn: async () => {\n      const response = await roleService.getPermissionList();\n\n      return response.data;\n    },\n  });\n\n  const createRoleMutation = useMutation({\n    mutationFn: (payload: {\n      code: string;\n      name: LocalizeText;\n      description?: string;\n      permissionIds?: string[];\n    }) => roleService.createRole(payload),\n    onSuccess: () => {\n      setToast({ message: t(\"toast.createSuccess\"), type: \"success\" });\n      queryClient.invalidateQueries({ queryKey: ROLES_LIST_QUERY_KEY });\n      setTimeout(() => {\n        router.push(\"/settings/roles\");\n      }, 1500);\n    },\n    onError: (error) => {\n      const errorMessage =\n        error instanceof Error ? error.message : t(\"toast.createError\");\n\n      setToast({ message: errorMessage, type: \"error\" });\n    },\n  });\n\n  const validate = useCallback(() => {\n    const newErrors: Record<string, string> = {};\n\n    if (!code.trim()) {\n      newErrors.code = errorsT(\"required\");\n    } else if (!/^[a-z0-9_]+$/.test(code)) {\n      newErrors.code = t(\"form.codeInvalid\");\n    }\n\n    if (!name || (!name.en && !name.vi)) {\n      newErrors.name = errorsT(\"required\");\n    }\n\n    setErrors(newErrors);\n\n    return Object.keys(newErrors).length === 0;\n  }, [code, name, errorsT, t]);\n\n  const handleSubmit = useCallback(() => {\n    if (!validate()) {\n      return;\n    }\n\n    createRoleMutation.mutate({\n      code: code.trim(),\n      name,\n      description: description.trim() || undefined,\n      permissionIds:\n        selectedPermissionIds.length > 0 ? selectedPermissionIds : undefined,\n    });\n  }, [\n    code,\n    name,\n    description,\n    selectedPermissionIds,\n    validate,\n    createRoleMutation,\n  ]);\n\n  const permissions = permissionsQuery.data ?? [];\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <IBaseCard>\n        <IBaseCardHeader className=\"flex items-center justify-between\">\n          <h2 className=\"text-xl font-semibold\">{t(\"create.title\")}</h2>\n          <div className=\"flex gap-2\">\n            <IBaseButton\n              variant=\"light\"\n              onPress={() => router.push(\"/settings/roles\")}\n            >\n              {actionsT(\"cancel\")}\n            </IBaseButton>\n            <IBaseButton\n              color=\"primary\"\n              isLoading={createRoleMutation.isPending}\n              onPress={handleSubmit}\n            >\n              {actionsT(\"save\")}\n            </IBaseButton>\n          </div>\n        </IBaseCardHeader>\n        <IBaseCardBody className=\"flex flex-col gap-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <IBaseInput\n              isRequired\n              description={t(\"form.codeDescription\")}\n              errorMessage={errors.code}\n              isInvalid={!!errors.code}\n              label={t(\"form.code\")}\n              value={code}\n              onValueChange={setCode}\n            />\n            <IBaseInputMultipleLang\n              isRequired\n              errorMessage={errors.name}\n              isInvalid={!!errors.name}\n              label={t(\"form.name\")}\n              value={name}\n              onValueChange={setName as (value: LocalizeText) => void}\n            />\n            <div className=\"md:col-span-2\">\n              <IBaseInput\n                description={t(\"form.descriptionDescription\")}\n                label={t(\"form.description\")}\n                value={description}\n                onValueChange={setDescription}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseSelect\n                description={t(\"form.permissionsDescription\")}\n                isLoading={permissionsQuery.isLoading}\n                label={t(\"form.defaultPermissions\")}\n                placeholder={t(\"form.selectPermissions\")}\n                selectedKeys={selectedPermissionIds}\n                selectionMode=\"multiple\"\n                onSelectionChange={(keys) => {\n                  setSelectedPermissionIds(Array.from(keys) as string[]);\n                }}\n              >\n                {permissions.map((permission) => (\n                  <IBaseSelectItem key={permission.id} textValue={permission.key}>\n                    {permission.key} - {permission.module}.{permission.resource}\n                    .{permission.action}\n                  </IBaseSelectItem>\n                ))}\n              </IBaseSelect>\n            </div>\n          </div>\n        </IBaseCardBody>\n      </IBaseCard>\n      {toast && (\n        <div className=\"fixed right-4 top-4 z-50 flex max-w-sm flex-col gap-2\">\n          <div\n            className={`rounded-medium px-4 py-3 text-sm shadow-large ${\n              toast.type === \"error\"\n                ? \"bg-danger-100 text-danger\"\n                : \"bg-success-100 text-success\"\n            }`}\n          >\n            {toast.message}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Settings/Roles/RoleEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":66,"fix":{"range":[89,607],"text":"import {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\nimport roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { IBaseButton, IBaseCard } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":34,"fix":{"range":[155,607],"text":"import roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":61,"fix":{"range":[368,368],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/RoleService` import should occur after import of `react`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":61,"fix":{"range":[308,607],"text":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport roleService from \"@base/client/services/RoleService\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Replace `·key={permission.id}·textValue={permission.key}` with `⏎····················key={permission.id}⏎····················textValue={permission.key}⏎··················`","line":240,"column":35,"nodeType":null,"messageId":"replace","endLine":240,"endColumn":82,"fix":{"range":[6984,7031],"text":"\n                    key={permission.id}\n                    textValue={permission.key}\n                  "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport { IBaseButton, IBaseCard } from \"@base/client/components\";\nimport {\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSelect,\n  IBaseSelectItem,\n} from \"@base/client/components\";\nimport roleService from \"@base/client/services/RoleService\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nconst PERMISSIONS_QUERY_KEY = [\"settings\", \"permissions\", \"list\"] as const;\nconst ROLE_QUERY_KEY = (id: string) =>\n  [\"settings\", \"roles\", \"get\", id] as const;\nconst ROLES_LIST_QUERY_KEY = [\"settings\", \"roles\", \"list\"] as const;\n\nexport default function RoleEditPage() {\n  const t = useTranslations(\"settings.roles\");\n  const actionsT = useTranslations(\"common.actions\");\n  const errorsT = useTranslations(\"common.errors\");\n  const queryClient = useQueryClient();\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n\n  const [code, setCode] = useState(\"\");\n  const [name, setName] = useState<LocalizeText>({\n    en: undefined,\n    vi: undefined,\n  });\n  const [description, setDescription] = useState(\"\");\n  const [selectedPermissionIds, setSelectedPermissionIds] = useState<string[]>(\n    [],\n  );\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [toast, setToast] = useState<{\n    message: string;\n    type: \"error\" | \"success\";\n  } | null>(null);\n\n  const roleQuery = useQuery({\n    queryKey: ROLE_QUERY_KEY(id),\n    queryFn: async () => {\n      const response = await roleService.getRole(id);\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const permissionsQuery = useQuery({\n    queryKey: PERMISSIONS_QUERY_KEY,\n    queryFn: async () => {\n      const response = await roleService.getPermissionList();\n\n      return response.data;\n    },\n  });\n\n  useEffect(() => {\n    if (roleQuery.data) {\n      const role = roleQuery.data;\n\n      setCode(role.code);\n      setName(role.name);\n      setDescription(role.description || \"\");\n      setSelectedPermissionIds(\n        role.permissions ? role.permissions.map((p) => p.id) : [],\n      );\n    }\n  }, [roleQuery.data]);\n\n  const updateRoleMutation = useMutation({\n    mutationFn: (payload: {\n      id: string;\n      code: string;\n      name: LocalizeText;\n      description?: string;\n      permissionIds?: string[];\n    }) => roleService.updateRole(payload),\n    onSuccess: () => {\n      setToast({ message: t(\"toast.updateSuccess\"), type: \"success\" });\n      queryClient.invalidateQueries({ queryKey: ROLES_LIST_QUERY_KEY });\n      queryClient.invalidateQueries({ queryKey: ROLE_QUERY_KEY(id) });\n      setTimeout(() => {\n        router.push(\"/settings/roles\");\n      }, 1500);\n    },\n    onError: (error) => {\n      const errorMessage =\n        error instanceof Error ? error.message : t(\"toast.updateError\");\n\n      setToast({ message: errorMessage, type: \"error\" });\n    },\n  });\n\n  const validate = useCallback(() => {\n    const newErrors: Record<string, string> = {};\n\n    if (!code.trim()) {\n      newErrors.code = errorsT(\"required\");\n    } else if (!/^[a-z0-9_]+$/.test(code)) {\n      newErrors.code = t(\"form.codeInvalid\");\n    }\n\n    if (!name || (!name.en && !name.vi)) {\n      newErrors.name = errorsT(\"required\");\n    }\n\n    setErrors(newErrors);\n\n    return Object.keys(newErrors).length === 0;\n  }, [code, name, errorsT, t]);\n\n  const handleSubmit = useCallback(() => {\n    if (!validate()) {\n      return;\n    }\n\n    updateRoleMutation.mutate({\n      id,\n      code: code.trim(),\n      name,\n      description: description.trim() || undefined,\n      permissionIds:\n        selectedPermissionIds.length > 0 ? selectedPermissionIds : undefined,\n    });\n  }, [\n    id,\n    code,\n    name,\n    description,\n    selectedPermissionIds,\n    validate,\n    updateRoleMutation,\n  ]);\n\n  const role = roleQuery.data;\n  const permissions = permissionsQuery.data ?? [];\n\n  if (roleQuery.isLoading) {\n    return (\n      <IBaseCard>\n        <IBaseCardBody>\n          <p>{t(\"loading\")}</p>\n        </IBaseCardBody>\n      </IBaseCard>\n    );\n  }\n\n  if (!role) {\n    return (\n      <IBaseCard>\n        <IBaseCardBody>\n          <p>{t(\"notFound\")}</p>\n        </IBaseCardBody>\n      </IBaseCard>\n    );\n  }\n\n  if (role.isSystem) {\n    return (\n      <IBaseCard>\n        <IBaseCardBody>\n          <p>{t(\"cannotEditSystemRole\")}</p>\n        </IBaseCardBody>\n      </IBaseCard>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <IBaseCard>\n        <IBaseCardHeader className=\"flex items-center justify-between\">\n          <h2 className=\"text-xl font-semibold\">{t(\"edit.title\")}</h2>\n          <div className=\"flex gap-2\">\n            <IBaseButton\n              variant=\"light\"\n              onPress={() => router.push(\"/settings/roles\")}\n            >\n              {actionsT(\"cancel\")}\n            </IBaseButton>\n            <IBaseButton\n              color=\"primary\"\n              isLoading={updateRoleMutation.isPending}\n              onPress={handleSubmit}\n            >\n              {actionsT(\"save\")}\n            </IBaseButton>\n          </div>\n        </IBaseCardHeader>\n        <IBaseCardBody className=\"flex flex-col gap-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <IBaseInput\n              isRequired\n              description={t(\"form.codeDescription\")}\n              errorMessage={errors.code}\n              isInvalid={!!errors.code}\n              label={t(\"form.code\")}\n              value={code}\n              onValueChange={setCode}\n            />\n            <IBaseInputMultipleLang\n              isRequired\n              errorMessage={errors.name}\n              isInvalid={!!errors.name}\n              label={t(\"form.name\")}\n              value={name}\n              onValueChange={setName as (value: LocalizeText) => void}\n            />\n            <div className=\"md:col-span-2\">\n              <IBaseInput\n                description={t(\"form.descriptionDescription\")}\n                label={t(\"form.description\")}\n                value={description}\n                onValueChange={setDescription}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseSelect\n                description={t(\"form.permissionsDescription\")}\n                isLoading={permissionsQuery.isLoading}\n                label={t(\"form.defaultPermissions\")}\n                placeholder={t(\"form.selectPermissions\")}\n                selectedKeys={selectedPermissionIds}\n                selectionMode=\"multiple\"\n                onSelectionChange={(keys) => {\n                  setSelectedPermissionIds(Array.from(keys) as string[]);\n                }}\n              >\n                {permissions.map((permission) => (\n                  <IBaseSelectItem key={permission.id} textValue={permission.key}>\n                    {permission.key} - {permission.module}.{permission.resource}\n                    .{permission.action}\n                  </IBaseSelectItem>\n                ))}\n              </IBaseSelect>\n            </div>\n          </div>\n        </IBaseCardBody>\n      </IBaseCard>\n      {toast && (\n        <div className=\"fixed right-4 top-4 z-50 flex max-w-sm flex-col gap-2\">\n          <div\n            className={`rounded-medium px-4 py-3 text-sm shadow-large ${\n              toast.type === \"error\"\n                ? \"bg-danger-100 text-danger\"\n                : \"bg-success-100 text-success\"\n            }`}\n          >\n            {toast.message}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Settings/Roles/RoleViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[134,134],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `next-intl`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[15,286],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useTranslations } from \"next-intl\";\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseChip,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[285,285],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport {\n  IBaseButton,\n  IBaseCard,\n  IBaseCardBody,\n  IBaseCardHeader,\n  IBaseChip,\n} from \"@base/client/components\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useTranslations } from \"next-intl\";\nimport roleService from \"@base/client/services/RoleService\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nconst ROLE_QUERY_KEY = (id: string) =>\n  [\"settings\", \"roles\", \"get\", id] as const;\n\nexport default function RoleViewPage() {\n  const t = useTranslations(\"settings.roles\");\n  const actionsT = useTranslations(\"common.actions\");\n  const router = useRouter();\n  const params = useParams();\n  const getText = useLocalizedText();\n  const id = params.id as string;\n\n  const roleQuery = useQuery({\n    queryKey: ROLE_QUERY_KEY(id),\n    queryFn: async () => {\n      const response = await roleService.getRole(id);\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const role = roleQuery.data;\n  const loading = roleQuery.isLoading;\n\n  if (loading) {\n    return (\n      <IBaseCard>\n        <IBaseCardBody>\n          <p>{t(\"loading\")}</p>\n        </IBaseCardBody>\n      </IBaseCard>\n    );\n  }\n\n  if (!role) {\n    return (\n      <IBaseCard>\n        <IBaseCardBody>\n          <p>{t(\"notFound\")}</p>\n        </IBaseCardBody>\n      </IBaseCard>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <IBaseCard>\n        <IBaseCardHeader className=\"flex items-center justify-between\">\n          <h2 className=\"text-xl font-semibold\">{getText(role.name)}</h2>\n          <div className=\"flex gap-2\">\n            <IBaseButton\n              variant=\"light\"\n              onPress={() => router.push(\"/settings/roles\")}\n            >\n              {actionsT(\"cancel\")}\n            </IBaseButton>\n            {!role.isSystem && (\n              <IBaseButton\n                color=\"primary\"\n                onPress={() => router.push(`/settings/roles/edit/${role.id}`)}\n              >\n                {actionsT(\"edit\")}\n              </IBaseButton>\n            )}\n          </div>\n        </IBaseCardHeader>\n        <IBaseCardBody className=\"flex flex-col gap-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div>\n              <label className=\"text-sm font-medium text-foreground-500\">\n                {t(\"form.code\")}\n              </label>\n              <p className=\"mt-1\">{role.code}</p>\n            </div>\n            <div>\n              <label className=\"text-sm font-medium text-foreground-500\">\n                {t(\"form.name\")}\n              </label>\n              <p className=\"mt-1\">{getText(role.name)}</p>\n            </div>\n            <div className=\"md:col-span-2\">\n              <label className=\"text-sm font-medium text-foreground-500\">\n                {t(\"form.description\")}\n              </label>\n              <p className=\"mt-1\">{role.description || \"-\"}</p>\n            </div>\n            <div>\n              <label className=\"text-sm font-medium text-foreground-500\">\n                {t(\"form.type\")}\n              </label>\n              <p className=\"mt-1\">\n                {role.isSystem ? t(\"form.systemRole\") : t(\"form.customRole\")}\n              </p>\n            </div>\n            <div>\n              <label className=\"text-sm font-medium text-foreground-500\">\n                {t(\"form.status\")}\n              </label>\n              <p className=\"mt-1\">\n                <IBaseChip\n                  color={role.isActive ? \"success\" : \"default\"}\n                  size=\"sm\"\n                  variant=\"flat\"\n                >\n                  {role.isActive ? t(\"form.active\") : t(\"form.inactive\")}\n                </IBaseChip>\n              </p>\n            </div>\n          </div>\n          <div>\n            <label className=\"text-sm font-medium text-foreground-500 mb-2 block\">\n              {t(\"form.defaultPermissions\")}\n            </label>\n            {role.permissions && role.permissions.length > 0 ? (\n              <div className=\"flex flex-wrap gap-2\">\n                {role.permissions.map((permission) => (\n                  <IBaseChip key={permission.id} size=\"sm\" variant=\"flat\">\n                    {getText(permission.name)} ({permission.key})\n                  </IBaseChip>\n                ))}\n              </div>\n            ) : (\n              <p className=\"text-foreground-400\">{t(\"form.noPermissions\")}</p>\n            )}\n          </div>\n        </IBaseCardBody>\n      </IBaseCard>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/Settings/Roles/RolesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":76,"fix":{"range":[628,628],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":69,"fix":{"range":[15,698],"text":"import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { IBaseButton, IBaseChip } from \"@base/client/components\";\nimport {\n  I_BASE_TABLE_COLUMN_KEY_ACTION,\n  IBaseTableColumnDefinition,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport roleService, { type Role } from \"@base/client/services/RoleService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":45,"fix":{"range":[15,743],"text":"import { useTranslations } from \"next-intl\";\nimport { IBaseButton, IBaseChip } from \"@base/client/components\";\nimport {\n  I_BASE_TABLE_COLUMN_KEY_ACTION,\n  IBaseTableColumnDefinition,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport roleService, { type Role } from \"@base/client/services/RoleService\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":56,"fix":{"range":[15,799],"text":"import { useCallback, useMemo, useState } from \"react\";\nimport { IBaseButton, IBaseChip } from \"@base/client/components\";\nimport {\n  I_BASE_TABLE_COLUMN_KEY_ACTION,\n  IBaseTableColumnDefinition,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport roleService, { type Role } from \"@base/client/services/RoleService\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { IBaseButton, IBaseChip } from \"@base/client/components\";\nimport {\n  I_BASE_TABLE_COLUMN_KEY_ACTION,\n  IBaseTableColumnDefinition,\n  IBaseModal,\n  IBaseModalBody,\n  IBaseModalContent,\n  IBaseModalFooter,\n  IBaseModalHeader,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport roleService, { type Role } from \"@base/client/services/RoleService\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo, useState } from \"react\";\n\nconst ROLES_LIST_QUERY_KEY = [\"settings\", \"roles\", \"list\"] as const;\nconst BASE_PATH = \"/settings/roles\";\n\ntype RoleRow = Role & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function RolesListPage() {\n  const tIBaseTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"settings.roles\");\n  const actionsT = useTranslations(\"common.actions\");\n  const queryClient = useQueryClient();\n  const getText = useLocalizedText();\n  const [deleteConfirm, setDeleteConfirm] = useState<Role | null>(null);\n\n  const deleteRoleMutation = useMutation({\n    mutationFn: (id: string) => roleService.deleteRole(id),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ROLES_LIST_QUERY_KEY });\n      setDeleteConfirm(null);\n    },\n  });\n\n  const handleDelete = useCallback((role: Role) => {\n    setDeleteConfirm(role);\n  }, []);\n\n  const handleCloseModal = useCallback(() => {\n    setDeleteConfirm(null);\n  }, []);\n\n  const handleConfirmDelete = useCallback(() => {\n    if (deleteConfirm) {\n      deleteRoleMutation.mutate(deleteConfirm.id);\n    }\n  }, [deleteConfirm, deleteRoleMutation]);\n\n  const getActionMenuItems = useCallback(\n    (row: RoleRow) => {\n      const baseActions: Array<\n        | { key: string; label: string; href: string }\n        | {\n            key: string;\n            label: string;\n            onPress: () => void;\n            disabled?: boolean;\n          }\n      > = [\n        {\n          key: \"view\",\n          label: actionsT(\"view\"),\n          href: `${BASE_PATH}/view/${row.id}`,\n        },\n      ];\n\n      if (!row.isSystem) {\n        baseActions.push(\n          {\n            key: \"edit\",\n            label: actionsT(\"edit\"),\n            href: `${BASE_PATH}/edit/${row.id}`,\n          },\n          {\n            key: \"delete\",\n            label: actionsT(\"delete\"),\n            onPress: () => handleDelete(row),\n            disabled: deleteRoleMutation.isPending,\n          },\n        );\n      }\n\n      return baseActions;\n    },\n    [actionsT, handleDelete, deleteRoleMutation.isPending],\n  );\n\n  const columns = useMemo<IBaseTableColumnDefinition<RoleRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"table.columns.code\"),\n        render: (value, row) =>\n          row?.id ? (\n            <LinkAs href={`${BASE_PATH}/view/${row.id}`}>\n              {value as string}\n            </LinkAs>\n          ) : (\n            value\n          ),\n      },\n      {\n        key: \"name\",\n        label: t(\"table.columns.name\"),\n        render: (value) => getText(value as any),\n      },\n      {\n        key: \"description\",\n        label: t(\"table.columns.description\"),\n        render: (value) => (value ? String(value) : \"-\"),\n      },\n      {\n        key: \"isSystem\",\n        label: t(\"table.columns.type\"),\n        render: (value) => (\n          <IBaseChip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value\n              ? t(\"table.columns.systemRole\")\n              : t(\"table.columns.customRole\")}\n          </IBaseChip>\n        ),\n      },\n      {\n        key: \"isActive\",\n        label: t(\"table.columns.status\"),\n        render: (value) => (\n          <IBaseChip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value ? t(\"table.columns.active\") : t(\"table.columns.inactive\")}\n          </IBaseChip>\n        ),\n      },\n      {\n        key: I_BASE_TABLE_COLUMN_KEY_ACTION,\n        label: tIBaseTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) =>\n          row?.id ? <ActionMenu actions={getActionMenuItems(row)} /> : null,\n      },\n    ],\n    [t, tIBaseTable, getText, getActionMenuItems],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<RoleRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"actions.addRole\"),\n            type: \"link\",\n            color: \"primary\",\n            props: { href: `${BASE_PATH}/create` },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"role.list\"\n      />\n      <IBaseModal isOpen={!!deleteConfirm} onClose={handleCloseModal}>\n        <IBaseModalContent>\n          {(onClose) => (\n            <>\n              <IBaseModalHeader>{t(\"deleteConfirm.title\")}</IBaseModalHeader>\n              <IBaseModalBody>\n                <p>{t(\"deleteConfirm.message\")}</p>\n              </IBaseModalBody>\n              <IBaseModalFooter>\n                <IBaseButton\n                  isDisabled={deleteRoleMutation.isPending}\n                  variant=\"light\"\n                  onPress={onClose}\n                >\n                  {actionsT(\"cancel\")}\n                </IBaseButton>\n                <IBaseButton\n                  color=\"danger\"\n                  isLoading={deleteRoleMutation.isPending}\n                  onPress={handleConfirmDelete}\n                >\n                  {actionsT(\"delete\")}\n                </IBaseButton>\n              </IBaseModalFooter>\n            </>\n          )}\n        </IBaseModalContent>\n      </IBaseModal>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/pages/WorkspaceMainPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/ClientHttpService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/CurrencyService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/DropdownOptionsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/GuidelineService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/JsonRpcClientService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/LocationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/MediaService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":22,"suggestions":[{"fix":{"range":[2506,2553],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ImageUploadItem } from \"../interface/ImageUpdload\";\n\nimport ClientHttpService from \"./ClientHttpService\";\n\nexport interface UploadResponse {\n  data: {\n    id: string;\n    filename: string;\n    originalName: string;\n    path: string;\n    url: string;\n    size: number;\n    mimeType: string;\n    type: \"image\" | \"file\";\n  };\n  message: string;\n  status: number;\n}\n\nclass MediaService extends ClientHttpService {\n  constructor() {\n    super(\"/api/base\");\n  }\n\n  /**\n   * Upload a file\n   */\n  async uploadFile(file: File): Promise<UploadResponse> {\n    const formData = new FormData();\n\n    formData.append(\"file\", file);\n\n    // Get CSRF token for POST request\n    const { getHeadersWithCsrf } = await import(\"../utils/csrf\");\n    const headers = await getHeadersWithCsrf();\n\n    const response = await fetch(\"/api/base/media/upload\", {\n      method: \"POST\",\n      body: formData,\n      credentials: \"include\",\n      headers: {\n        // Don't set Content-Type for FormData, browser will set it with boundary\n        ...Object.fromEntries(\n          Object.entries(headers).filter(\n            ([key]) => key.toLowerCase() !== \"content-type\",\n          ),\n        ),\n      },\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n\n      throw new Error(\n        errorData.message ||\n          errorData.error ||\n          `Upload failed: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Upload multiple files\n   */\n  async uploadFiles(files: File[]): Promise<UploadResponse[]> {\n    return Promise.all(files.map((file) => this.uploadFile(file)));\n  }\n\n  /**\n   * Upload image items that have blob but not yet uploaded\n   */\n  async uploadImageItems(items: ImageUploadItem[]): Promise<ImageUploadItem[]> {\n    const itemsToUpload = items.filter(\n      (item) => item.blob && item.status !== \"done\",\n    );\n\n    if (itemsToUpload.length === 0) {\n      return items;\n    }\n\n    const uploadPromises = itemsToUpload.map(async (item) => {\n      if (!item.blob) return item;\n\n      try {\n        const file = new File([item.blob], item.name, {\n          type: `image/${item.extension.replace(\".\", \"\")}`,\n        });\n        const result = await this.uploadFile(file);\n\n        return {\n          ...item,\n          id: result.data.id,\n          url: result.data.url,\n          status: \"done\" as const,\n          blob: undefined, // Remove blob after upload\n        };\n      } catch (error) {\n        console.error(\"Error uploading image:\", error);\n\n        return {\n          ...item,\n          status: \"error\" as const,\n        };\n      }\n    });\n\n    const uploadedItems = await Promise.all(uploadPromises);\n\n    // Replace items in original array\n    return items.map((item) => {\n      const uploaded = uploadedItems.find((u) => u.uid === item.uid);\n\n      return uploaded || item;\n    });\n  }\n}\n\nexport default new MediaService();\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/NewsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/PaymentMethodService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/PaymentTermService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/RoleService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/ShippingMethodService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/ShippingTermService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/TaxRateService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/ViewListDataTableService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":31,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":31,"endColumn":20,"suggestions":[{"fix":{"range":[783,804],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ListParamsResponse } from \"@base/shared/interface/ListInterface\";\n\nimport JsonRpcClientService from \"./JsonRpcClientService\";\n\ntype IBaseTableParams = {\n  model: string;\n  params: any;\n};\n\nclass ViewListDataTableService extends JsonRpcClientService {\n  getBaseModelIdForList = (modelId: string): string => {\n    if (modelId.endsWith(\".list\")) {\n      return modelId;\n    }\n\n    return `${modelId}.list`;\n  };\n  getData = async (req: IBaseTableParams) => {\n    try {\n      const baseModelId = this.getBaseModelIdForList(req.model);\n      const response = await this.call<ListParamsResponse<any>>(\n        `${baseModelId}.getData`,\n        req.params,\n      );\n\n      return {\n        data: response?.data,\n        total: response?.total,\n      };\n    } catch (error) {\n      console.error(error);\n\n      return { data: [], total: 0 };\n    }\n  };\n\n  getFilter = async (req: IBaseTableParams) => {\n    const baseModelId = this.getBaseModelIdForList(req.model);\n\n    return this.call<{ success: boolean; data: any[] }>(\n      `${baseModelId}.getFilter`,\n      req.params,\n    );\n  };\n\n  getFavoriteFilter = async (req: IBaseTableParams) => {\n    const baseModelId = this.getBaseModelIdForList(req.model);\n\n    return this.call<{ success: boolean; data: any[] }>(\n      `${baseModelId}.getFavoriteFilter`,\n      req.params,\n    );\n  };\n\n  getGroupBy = async (req: IBaseTableParams) => {\n    const baseModelId = this.getBaseModelIdForList(req.model);\n\n    return this.call<{ success: boolean; data: any[] }>(\n      `${baseModelId}.getGroupBy`,\n      req.params,\n    );\n  };\n\n  updateFavoriteFilter = async (req: IBaseTableParams) => {\n    const baseModelId = this.getBaseModelIdForList(req.model);\n\n    return this.call<{ success: boolean; data: any[] }>(\n      `${baseModelId}.updateFavoriteFilter`,\n      req.params,\n    );\n  };\n}\n\nexport default ViewListDataTableService;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/stores/create-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/stores/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/stores/messages-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/stores/root-store.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":119,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":119,"endColumn":14,"suggestions":[{"fix":{"range":[3002,3046],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":14,"suggestions":[{"fix":{"range":[3049,3111],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":121,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":121,"endColumn":14,"suggestions":[{"fix":{"range":[3114,3180],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":122,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":122,"endColumn":14,"suggestions":[{"fix":{"range":[3183,3231],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { create } from \"zustand\";\nimport { devtools, persist } from \"zustand/middleware\";\n\n// Root store state - contains a Map of all dynamic stores\nexport interface RootStoreState {\n  stores: Map<string, any>;\n  setStoreValue: <T>(key: string, value: T) => void;\n  getStoreValue: <T>(key: string) => T | undefined;\n  clearStoreValue: (key: string) => void;\n  hasStore: (key: string) => boolean;\n}\n\n// Check if in development mode\n// For Next.js, check NODE_ENV and also check window location in client-side\nconst isDev =\n  process.env.NODE_ENV === \"development\" ||\n  (typeof window !== \"undefined\" &&\n    (window.location.hostname === \"localhost\" ||\n      window.location.hostname === \"127.0.0.1\"));\n\n// Store creator function\nconst storeCreator = (set: any, get: any) => ({\n  stores: new Map<string, any>(),\n\n  setStoreValue: <T>(key: string, value: T) => {\n    set(\n      (state: RootStoreState) => {\n        const currentStores = ensureMap(state.stores);\n        const newStores = new Map(currentStores);\n\n        newStores.set(key, value);\n\n        return { stores: newStores };\n      },\n      false,\n      `setStoreValue:${key}`,\n    );\n  },\n\n  getStoreValue: <T>(key: string) => {\n    const stores = ensureMap(get().stores);\n\n    return stores.get(key) as T | undefined;\n  },\n\n  clearStoreValue: (key: string) => {\n    set(\n      (state: RootStoreState) => {\n        const currentStores = ensureMap(state.stores);\n        const newStores = new Map(currentStores);\n\n        newStores.delete(key);\n\n        return { stores: newStores };\n      },\n      false,\n      `clearStoreValue:${key}`,\n    );\n  },\n\n  hasStore: (key: string) => {\n    const stores = ensureMap(get().stores);\n\n    return stores.has(key);\n  },\n});\n\n// Helper function to convert object/array to Map\nconst ensureMap = (stores: any): Map<string, any> => {\n  if (stores instanceof Map) {\n    return stores;\n  }\n  if (Array.isArray(stores)) {\n    return new Map(stores);\n  }\n  if (stores && typeof stores === \"object\") {\n    return new Map(Object.entries(stores));\n  }\n\n  return new Map();\n};\n\n// Create root store with Map\n// Only add devtools in development mode\nconst persistedStore = persist(storeCreator, {\n  name: \"root-store\",\n  partialize: (state) => ({\n    // Convert Map to object for persistence\n    stores: Object.fromEntries(state.stores),\n  }),\n  merge: (persistedState, currentState) => {\n    // Convert persisted object back to Map\n    const stores = ensureMap(\n      (persistedState as any)?.stores || currentState.stores,\n    );\n\n    return {\n      ...currentState,\n      stores,\n    };\n  },\n});\n\n// Create root store with devtools enabled in development\n// Always enable devtools in dev mode for Redux DevTools\nexport const rootStore = isDev\n  ? create<RootStoreState>()(\n      devtools(persistedStore, {\n        name: \"RootStore\",\n        enabled: true,\n      }),\n    )\n  : create<RootStoreState>()(persistedStore);\n\n// Debug log - always log to help debug\nif (typeof window !== \"undefined\") {\n  console.log(\"🔧 RootStore - isDev:\", isDev);\n  console.log(\"🔧 RootStore - NODE_ENV:\", process.env.NODE_ENV);\n  console.log(\"🔧 RootStore - hostname:\", window.location.hostname);\n  console.log(\"📦 RootStore created:\", rootStore);\n}\n\n// Direct access (không subscribe, không gây re-render)\nexport const getRootStoreValue = <T>(key: string): T | undefined => {\n  const stores = ensureMap(rootStore.getState().stores);\n\n  return stores.get(key) as T | undefined;\n};\n\nexport const setRootStoreValue = <T>(key: string, value: T) => {\n  rootStore.getState().setStoreValue(key, value);\n};\n\nexport const clearRootStoreValue = (key: string) => {\n  rootStore.getState().clearStoreValue(key);\n};\n\nexport const hasRootStore = (key: string) => {\n  return rootStore.getState().hasStore(key);\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/themes/theme-demo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/themes/theme-switch.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[74,74],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `clsx`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[15,318],"text":"import { FC } from \"react\";\nimport { VisuallyHidden } from \"@react-aria/visually-hidden\";\nimport { useSwitch } from \"@heroui/switch\";\nimport { useTheme } from \"next-themes\";\nimport { useIsSSR } from \"@react-aria/ssr\";\nimport clsx from \"clsx\";\nimport { IBaseSwitchProps } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":25,"fix":{"range":[317,317],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { IBaseSwitchProps } from \"@base/client/components\";\nimport { FC } from \"react\";\nimport { VisuallyHidden } from \"@react-aria/visually-hidden\";\nimport { useSwitch } from \"@heroui/switch\";\nimport { useTheme } from \"next-themes\";\nimport { useIsSSR } from \"@react-aria/ssr\";\nimport clsx from \"clsx\";\nimport { SunFilledIcon, MoonFilledIcon } from \"@base/client/components/icons\";\n\nexport interface ThemeSwitchProps {\n  className?: string;\n  classNames?: IBaseSwitchProps[\"classNames\"];\n}\n\nexport const ThemeSwitch: FC<ThemeSwitchProps> = ({\n  className,\n  classNames,\n}) => {\n  const { theme, setTheme } = useTheme();\n  const isSSR = useIsSSR();\n\n  const onChange = () => {\n    theme === \"light\" ? setTheme(\"dark\") : setTheme(\"light\");\n  };\n\n  const {\n    Component,\n    slots,\n    isSelected,\n    getBaseProps,\n    getInputProps,\n    getWrapperProps,\n  } = useSwitch({\n    isSelected: theme === \"light\" || isSSR,\n    \"aria-label\": `IBaseSwitch to ${theme === \"light\" || isSSR ? \"dark\" : \"light\"} mode`,\n    onChange,\n  });\n\n  return (\n    <Component\n      {...getBaseProps({\n        className: clsx(\n          \"px-px transition-opacity hover:opacity-80 cursor-pointer\",\n          className,\n          classNames?.base,\n        ),\n      })}\n    >\n      <VisuallyHidden>\n        <input {...getInputProps()} />\n      </VisuallyHidden>\n      <div\n        {...getWrapperProps()}\n        className={slots.wrapper({\n          class: clsx(\n            [\n              \"w-auto h-auto\",\n              \"bg-transparent\",\n              \"rounded-lg\",\n              \"flex items-center justify-center\",\n              \"group-data-[selected=true]:bg-transparent\",\n              \"!text-default-500\",\n              \"pt-px\",\n              \"px-0\",\n              \"mx-0\",\n            ],\n            classNames?.wrapper,\n          ),\n        })}\n      >\n        {!isSelected || isSSR ? (\n          <SunFilledIcon size={22} />\n        ) : (\n          <MoonFilledIcon size={22} />\n        )}\n      </div>\n    </Component>\n  );\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/address/addressUtils.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":68,"fix":{"range":[182,182],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`lodash/isEmpty` import should occur before import of `@base/client/interface/LocalizeText`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":38,"fix":{"range":[115,221],"text":"import isEmpty from \"lodash/isEmpty\";\nimport { LocalizeText } from \"@base/client/interface/LocalizeText\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLocalizedName' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  Address,\n  AdministrativeUnit,\n  AdministrativeUnitType,\n} from \"@base/client/interface/Address\";\n\nimport { LocalizeText } from \"@base/client/interface/LocalizeText\";\nimport isEmpty from \"lodash/isEmpty\";\n\ntype LocalizeTextOrString = LocalizeText | string;\n/**\n * Get localized name from LocalizeText\n */\nconst getLocalizedName = (\n  name:\n    | string\n    | { vi?: string; en?: string; [key: string]: string | undefined },\n): string => {\n  if (typeof name === \"string\") {\n    return name;\n  }\n\n  return name.vi || name.en || \"\";\n};\n\n/**\n * Build address string from Address object\n * Format: \"Street, [Administrative Units sorted by level], PostalCode, Country\"\n */\nexport const buildAddressString = (\n  address: Partial<Address>,\n  locale: string,\n): string => {\n  const buildObjectOrString = (\n    value: LocalizeTextOrString | undefined,\n  ): string => {\n    if (typeof value === \"string\") {\n      return value?.trim() || \"\";\n    }\n    if (typeof value === \"object\" && value !== null) {\n      const localizeText = value as LocalizeText;\n      const result = (localizeText[locale as keyof LocalizeText] ||\n        localizeText.vi ||\n        localizeText.en ||\n        \"\") as string;\n\n      return result?.trim() || \"\";\n    }\n\n    return \"\";\n  };\n\n  const street = buildObjectOrString(address.street);\n\n  const administrativeUnits: string[] =\n    address.administrativeUnits\n      ?.sort((a, b) => a.level - b.level)\n      .map((unit) => {\n        return buildObjectOrString(unit.name);\n      }) ?? [];\n\n  const country = buildObjectOrString(address.country?.name);\n\n  const fullAddress = [street, ...administrativeUnits, country]\n    .filter((x) => !isEmpty(x as string))\n    .join(\", \");\n\n  return fullAddress;\n};\n\n/**\n * Format address for display\n */\nexport const formatAddressDisplay = (\n  address: Partial<Address>,\n  locale: string,\n): string => {\n  return buildAddressString(address, locale);\n};\n\n/**\n * Get administrative unit by level\n */\nexport const getUnitByLevel = (\n  address: Partial<Address>,\n  level: number,\n): AdministrativeUnit | undefined => {\n  return address.administrativeUnits?.find((u) => u.level === level);\n};\n\n/**\n * Get administrative unit by type\n */\nexport const getUnitByType = (\n  address: Partial<Address>,\n  type: AdministrativeUnitType,\n): AdministrativeUnit | undefined => {\n  return address.administrativeUnits?.find((u) => u.type === type);\n};\n\n/**\n * Get all units of a specific type\n */\nexport const getUnitsByType = (\n  address: Partial<Address>,\n  type: AdministrativeUnitType,\n): AdministrativeUnit[] => {\n  return address.administrativeUnits?.filter((u) => u.type === type) || [];\n};\n\n/**\n * Get the highest level administrative unit (largest level number)\n */\nexport const getHighestLevelUnit = (\n  address: Partial<Address>,\n): AdministrativeUnit | undefined => {\n  if (\n    !address.administrativeUnits ||\n    address.administrativeUnits.length === 0\n  ) {\n    return undefined;\n  }\n\n  return [...address.administrativeUnits].sort((a, b) => b.level - a.level)[0];\n};\n\n/**\n * Get the lowest level administrative unit (smallest level number > 0)\n */\nexport const getLowestLevelUnit = (\n  address: Partial<Address>,\n): AdministrativeUnit | undefined => {\n  if (\n    !address.administrativeUnits ||\n    address.administrativeUnits.length === 0\n  ) {\n    return undefined;\n  }\n\n  return [...address.administrativeUnits]\n    .filter((u) => u.level > 0)\n    .sort((a, b) => a.level - b.level)[0];\n};\n\n/**\n * Check if address has a specific administrative unit type\n */\nexport const hasUnitType = (\n  address: Partial<Address>,\n  type: AdministrativeUnitType,\n): boolean => {\n  return address.administrativeUnits?.some((u) => u.type === type) || false;\n};\n\n/**\n * Check if Vietnam address uses old structure (3 levels) or new structure (2 levels)\n *\n * @param address - Address object to check\n * @returns true if old structure (has district), false if new structure (no district)\n *\n * @example\n * ```typescript\n * const isOld = isOldVietnamStructure(address);\n * if (isOld) {\n *   // Cấu trúc cũ: Tỉnh -> Quận/Huyện -> Phường/Xã\n * } else {\n *   // Cấu trúc mới: Tỉnh/TP -> Phường/Xã\n * }\n * ```\n */\nexport const isOldVietnamStructure = (address: Partial<Address>): boolean => {\n  return hasUnitType(address, \"district\");\n};\n\n/**\n * Get the structure type for Vietnam address\n *\n * @param address - Address object to check\n * @returns \"old\" (3 levels), \"new\" (2 levels), or undefined if not Vietnam\n *\n * @example\n * ```typescript\n * const structureType = getVietnamStructureType(address);\n * switch (structureType) {\n *   case \"old\":\n *     // Cấu trúc cũ: có Quận/Huyện\n *     break;\n *   case \"new\":\n *     // Cấu trúc mới: không có Quận/Huyện\n *     break;\n *   case undefined:\n *     // Không phải địa chỉ Việt Nam\n *     break;\n * }\n * ```\n */\nexport const getVietnamStructureType = (\n  address: Partial<Address>,\n): \"old\" | \"new\" | undefined => {\n  if (address.country?.id !== \"VN\") {\n    return undefined;\n  }\n\n  return isOldVietnamStructure(address) ? \"old\" : \"new\";\n};\n\n/**\n * Validate Vietnam address structure\n * Returns true if valid, false if invalid\n * Valid structures:\n * - Old: [province (1), district (2), ward/commune/township (3)]\n * - New: [province (1), ward/commune/township (3)]\n */\nexport const validateVietnamAddress = (address: Partial<Address>): boolean => {\n  if (address.country?.id !== \"VN\") {\n    return true; // Not Vietnam, skip validation\n  }\n\n  if (\n    !address.administrativeUnits ||\n    address.administrativeUnits.length === 0\n  ) {\n    return false;\n  }\n\n  const hasProvince = hasUnitType(address, \"province\");\n  const hasDistrict = hasUnitType(address, \"district\");\n  const hasWard = hasUnitType(address, \"ward\");\n  const hasCommune = hasUnitType(address, \"commune\");\n  const hasTownship = hasUnitType(address, \"township\");\n  const hasLevel3 = hasWard || hasCommune || hasTownship;\n\n  // Must have province and at least one level 3 unit\n  if (!hasProvince || !hasLevel3) {\n    return false;\n  }\n\n  // If has district, must be old structure (3 levels)\n  if (hasDistrict) {\n    return hasLevel3; // Old structure: province + district + ward/commune/township\n  }\n\n  // If no district, must be new structure (2 levels)\n  return hasLevel3; // New structure: province + ward/commune/township\n};\n\n/**\n * Create an administrative unit with automatic level assignment based on type\n * Type-safe: level is automatically set based on the type using discriminated union\n */\nexport const createAdministrativeUnit = (\n  id: string,\n  name: string | { vi?: string; en?: string },\n  type: AdministrativeUnitType,\n): AdministrativeUnit => {\n  const nameObj: LocalizeText =\n    typeof name === \"string\"\n      ? { vi: name, en: name }\n      : { vi: name.vi, en: name.en };\n\n  // Type-safe creation based on discriminated union\n  // Note: \"country\", \"street\", and \"postal_code\" are not allowed here as they're stored separately in Address\n  switch (type) {\n    case \"province\":\n    case \"state\":\n    case \"region\":\n      return {\n        id,\n        name: nameObj,\n        type: type as \"province\" | \"state\" | \"region\",\n        level: 1,\n      };\n    case \"district\":\n    case \"city\":\n    case \"county\":\n      return {\n        id,\n        name: nameObj,\n        type: type as \"district\" | \"city\" | \"county\",\n        level: 2,\n      };\n    case \"ward\":\n    case \"commune\":\n    case \"neighborhood\":\n    case \"township\":\n      return {\n        id,\n        name: nameObj,\n        type: type as \"ward\" | \"commune\" | \"neighborhood\" | \"township\",\n        level: 3,\n      };\n    default:\n      // This should never happen, but TypeScript needs it for exhaustiveness\n      const _exhaustive: never = type;\n\n      throw new Error(`Unknown administrative unit type: ${_exhaustive}`);\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/csrf.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":20,"suggestions":[{"fix":{"range":[1429,1473],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":74,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":74,"endColumn":18,"suggestions":[{"fix":{"range":[1603,1654],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CSRF Token Utilities for Client-side\n */\n\nconst CSRF_COOKIE_NAME = \"csrf-token\";\nconst CSRF_HEADER_NAME = \"X-CSRF-Token\";\n\n/**\n * Get CSRF token from cookie\n */\nexport function getCsrfTokenFromCookie(): string | null {\n  if (typeof document === \"undefined\") return null;\n\n  const cookies = document.cookie.split(\";\");\n\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split(\"=\");\n\n    if (name === CSRF_COOKIE_NAME) {\n      return decodeURIComponent(value);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract plain token from signed token\n * Signed token format: token:signature:expiresAt\n */\nexport function extractTokenFromSigned(signedToken: string): string | null {\n  try {\n    const parts = signedToken.split(\":\");\n\n    return parts[0] || null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get CSRF token (plain token) from cookie\n * Returns the plain token that should be sent in X-CSRF-Token header\n */\nexport function getCsrfToken(): string | null {\n  const signedToken = getCsrfTokenFromCookie();\n\n  if (!signedToken) return null;\n\n  return extractTokenFromSigned(signedToken);\n}\n\n/**\n * Fetch CSRF token from API\n * This will also set the cookie automatically\n */\nexport async function fetchCsrfToken(): Promise<string | null> {\n  try {\n    const response = await fetch(\"/api/base/utils/get-csrf-token\", {\n      method: \"GET\",\n      credentials: \"include\",\n    });\n\n    if (!response.ok) {\n      console.error(\"Failed to fetch CSRF token\");\n\n      return null;\n    }\n\n    const data = await response.json();\n\n    return data.data?.token || null;\n  } catch (error) {\n    console.error(\"Error fetching CSRF token:\", error);\n\n    return null;\n  }\n}\n\n/**\n * Get CSRF token, fetch if not available\n */\nexport async function ensureCsrfToken(): Promise<string | null> {\n  // Try to get from cookie first\n  let token = getCsrfToken();\n\n  if (token) return token;\n\n  // If not in cookie, fetch from API\n  token = await fetchCsrfToken();\n\n  return token;\n}\n\n/**\n * Get headers with CSRF token\n */\nexport async function getHeadersWithCsrf(\n  additionalHeaders?: HeadersInit,\n): Promise<HeadersInit> {\n  const token = await ensureCsrfToken();\n  const headers: HeadersInit = {\n    \"Content-Type\": \"application/json\",\n    ...(additionalHeaders || {}),\n  };\n\n  if (token) {\n    (headers as Record<string, string>)[CSRF_HEADER_NAME] = token;\n  }\n\n  return headers;\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/date/formatDate.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":58,"fix":{"range":[57,57],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `dayjs/plugin/utc`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":58,"fix":{"range":[0,167],"text":"import dayjs from \"dayjs\";\nimport timezone from \"dayjs/plugin/timezone\";\nimport utc from \"dayjs/plugin/utc\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":17,"column":49,"nodeType":null,"messageId":"insert","endLine":17,"endColumn":49,"fix":{"range":[419,419],"text":","}},{"ruleId":"prettier/prettier","severity":1,"message":"Insert `,`","line":34,"column":49,"nodeType":null,"messageId":"insert","endLine":34,"endColumn":49,"fix":{"range":[741,741],"text":","}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport dayjs from \"dayjs\";\nimport timezone from \"dayjs/plugin/timezone\";\nimport utc from \"dayjs/plugin/utc\";\n\ndayjs.extend(utc);\ndayjs.extend(timezone);\n\n/**\n * Format date with time\n * @param date\n * @param timezone\n * @returns\n */\nexport const formatDateWithTime = (\n  date: number | undefined | null | string,\n  timezone: string | undefined = SYSTEM_TIMEZONE\n) => {\n  if (!date) return \"\";\n  const d = dayjs(date).tz(timezone);\n\n  if (!d.isValid()) return \"\";\n\n  return d.format(\"DD/MM/YYYY HH:mm\");\n};\n/**\n *\n * @param date\n * @param timezone\n * @returns\n */\nexport const formatDate = (\n  date: number | undefined | null | string,\n  timezone: string | undefined = SYSTEM_TIMEZONE\n) => {\n  if (!date) return \"\";\n  const d = dayjs(date).tz(timezone);\n\n  if (!d.isValid()) return \"\";\n\n  return d.format(\"DD/MM/YYYY\");\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/date/parseDateInput.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":58,"fix":{"range":[205,205],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/constants` import should occur after import of `dayjs/plugin/utc`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":58,"fix":{"range":[148,479],"text":"import { CalendarDate } from \"@internationalized/date\";\nimport dayjs from \"dayjs\";\nimport customParseFormat from \"dayjs/plugin/customParseFormat\";\nimport isoWeek from \"dayjs/plugin/isoWeek\";\nimport timezone from \"dayjs/plugin/timezone\";\nimport utc from \"dayjs/plugin/utc\";\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type { DateValue } from \"@react-types/calendar\";\nimport type { RangeValue } from \"@react-types/shared\";\nimport type { Dayjs } from \"dayjs\";\n\nimport { SYSTEM_TIMEZONE } from \"@base/shared/constants\";\nimport { CalendarDate } from \"@internationalized/date\";\nimport dayjs from \"dayjs\";\nimport customParseFormat from \"dayjs/plugin/customParseFormat\";\nimport isoWeek from \"dayjs/plugin/isoWeek\";\nimport timezone from \"dayjs/plugin/timezone\";\nimport utc from \"dayjs/plugin/utc\";\n\nexport type { Dayjs } from \"dayjs\";\n\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(customParseFormat);\ndayjs.extend(isoWeek);\n\nexport type DateLike = string | number | Date | Dayjs | null | undefined;\nexport type DateRangeLike =\n  | { start: DateLike; end: DateLike }\n  | null\n  | undefined;\n\nconst DEFAULT_DATE_FORMAT = \"YYYY-MM-DD\";\n\nfunction pad2(n: number) {\n  return String(n).padStart(2, \"0\");\n}\n\nfunction isDigitsOnly(s: string) {\n  return /^\\d+$/.test(s);\n}\n\ntype FormatToken = \"YYYY\" | \"YY\" | \"MM\" | \"DD\" | \"HH\" | \"mm\" | \"ss\";\ntype FormatPart =\n  | { type: \"token\"; token: FormatToken }\n  | { type: \"literal\"; value: string };\n\nfunction splitFormat(format: string): FormatPart[] {\n  const tokenRe = /(YYYY|YY|MM|DD|HH|mm|ss)/g;\n  const parts: FormatPart[] = [];\n  let lastIdx = 0;\n  let m: RegExpExecArray | null;\n\n  while ((m = tokenRe.exec(format))) {\n    const idx = m.index;\n\n    if (idx > lastIdx) {\n      parts.push({ type: \"literal\", value: format.slice(lastIdx, idx) });\n    }\n    parts.push({ type: \"token\", token: m[1] as FormatToken });\n    lastIdx = idx + m[1].length;\n  }\n  if (lastIdx < format.length) {\n    parts.push({ type: \"literal\", value: format.slice(lastIdx) });\n  }\n\n  return parts;\n}\n\nfunction tokenLen(token: FormatToken): number {\n  switch (token) {\n    case \"YYYY\":\n      return 4;\n    case \"YY\":\n      return 2;\n    case \"MM\":\n    case \"DD\":\n    case \"HH\":\n    case \"mm\":\n    case \"ss\":\n      return 2;\n  }\n}\n\n/**\n * Normalize a digits-only input into the provided format.\n * Example: input `17122025` + format `DD/MM/YYYY` => `17/12/2025`.\n * Returns null if it doesn't match expected length/tokens.\n */\nexport function normalizeDigitsToFormat(\n  digits: string,\n  format: string,\n): string | null {\n  const parts = splitFormat(format);\n  const tokens = parts.filter((p) => p.type === \"token\") as Array<\n    Extract<FormatPart, { type: \"token\" }>\n  >;\n  const expectedLen = tokens.reduce((sum, t) => sum + tokenLen(t.token), 0);\n\n  if (digits.length !== expectedLen) return null;\n  if (!isDigitsOnly(digits)) return null;\n\n  let cursor = 0;\n  const tokenValues: Record<FormatToken, string[]> = {\n    YYYY: [],\n    YY: [],\n    MM: [],\n    DD: [],\n    HH: [],\n    mm: [],\n    ss: [],\n  };\n\n  for (const t of tokens) {\n    const len = tokenLen(t.token);\n    const slice = digits.slice(cursor, cursor + len);\n\n    tokenValues[t.token].push(slice);\n    cursor += len;\n  }\n\n  // Rebuild output by walking format parts in order and consuming values.\n  const consumed: Record<FormatToken, number> = {\n    YYYY: 0,\n    YY: 0,\n    MM: 0,\n    DD: 0,\n    HH: 0,\n    mm: 0,\n    ss: 0,\n  };\n\n  let out = \"\";\n\n  for (const p of parts) {\n    if (p.type === \"literal\") {\n      out += p.value;\n      continue;\n    }\n    const i = consumed[p.token]++;\n    const v = tokenValues[p.token][i];\n\n    if (v == null) return null;\n    out += v;\n  }\n\n  return out;\n}\n\nexport function formatDayjs(\n  value: Dayjs,\n  format: string,\n  tz: string = SYSTEM_TIMEZONE,\n) {\n  return value.tz(tz).format(format);\n}\n\nexport function nowInTz(tz: string = SYSTEM_TIMEZONE) {\n  return dayjs().tz(tz);\n}\n\n/**\n * Parse a string strictly with the given format, then re-create the value in a timezone.\n * This avoids timezone drift while keeping strict parsing semantics.\n */\nexport function parseStrictInTz(\n  text: string,\n  format: string,\n  tz: string = SYSTEM_TIMEZONE,\n): Dayjs | null {\n  const parsed = dayjs(text, format, true);\n\n  if (!parsed.isValid()) return null;\n\n  const hasTime = /H|m|s/.test(format);\n\n  const y = parsed.year();\n  const mo = parsed.month() + 1;\n  const d = parsed.date();\n  const hh = hasTime ? parsed.hour() : 0;\n  const mm = hasTime ? parsed.minute() : 0;\n  const ss = hasTime ? parsed.second() : 0;\n\n  const iso = `${y}-${pad2(mo)}-${pad2(d)} ${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;\n  const tzParsed = dayjs.tz(iso, \"YYYY-MM-DD HH:mm:ss\", tz);\n\n  return tzParsed.isValid() ? tzParsed : null;\n}\n\nexport function toDayjs(\n  value: DateLike,\n  format: string = DEFAULT_DATE_FORMAT,\n  tz: string = SYSTEM_TIMEZONE,\n): Dayjs | null {\n  if (!value) return null;\n  if (dayjs.isDayjs(value)) return value.tz(tz);\n  if (typeof value === \"number\") {\n    const d = dayjs(value).tz(tz);\n\n    return d.isValid() ? d : null;\n  }\n  if (value instanceof Date) {\n    const d = dayjs(value).tz(tz);\n\n    return d.isValid() ? d : null;\n  }\n\n  const text = value.trim();\n\n  if (!text) return null;\n\n  // Strict parse by format first.\n  const strict = parseStrictInTz(text, format, tz);\n\n  if (strict) return strict;\n\n  // Allow digits-only input (ddmmyyyy etc.) and normalize.\n  if (isDigitsOnly(text)) {\n    const normalized = normalizeDigitsToFormat(text, format);\n\n    if (normalized) {\n      const strict2 = parseStrictInTz(normalized, format, tz);\n\n      if (strict2) return strict2;\n    }\n  }\n\n  // Fallback: try dayjs parser (ISO, timestamps, etc.) then tz.\n  const fallback = dayjs(text);\n\n  if (fallback.isValid()) return fallback.tz(tz);\n\n  return null;\n}\n\nexport function dayjsToCalendarDate(\n  value: Dayjs,\n  tz: string = SYSTEM_TIMEZONE,\n): CalendarDate {\n  const d = value.tz(tz);\n\n  return new CalendarDate(d.year(), d.month() + 1, d.date());\n}\n\nexport function calendarDateToDayjs(\n  value: DateValue,\n  tz: string = SYSTEM_TIMEZONE,\n): Dayjs {\n  // CalendarDate.toString() => YYYY-MM-DD\n  const iso = value.toString();\n\n  return dayjs.tz(iso, \"YYYY-MM-DD\", tz);\n}\n\nexport function toCalendarDateValue(\n  value: DateLike,\n  format: string,\n  tz: string = SYSTEM_TIMEZONE,\n): CalendarDate | null {\n  const d = toDayjs(value, format, tz);\n\n  return d ? dayjsToCalendarDate(d, tz) : null;\n}\n\nexport function toRangeCalendarValue(\n  value: DateRangeLike,\n  format: string,\n  tz: string = SYSTEM_TIMEZONE,\n): RangeValue<CalendarDate> | null {\n  if (!value) return null;\n  const start = toCalendarDateValue(value.start, format, tz);\n  const end = toCalendarDateValue(value.end, format, tz);\n\n  if (!start || !end) return null;\n\n  return { start, end };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/link/getClientLink.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/number/formatNumber.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/client/utils/number/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/csrf.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/rate-limit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/config/system.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/admin/model/get-model-list.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[125,125],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,169],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport { RuntimeContext } from \"../../../runtime/RuntimeContext\";\n\nconst getModelList = async () => {\n  const modelInstance = await RuntimeContext.getModelInstance();\n  const modelKeys = modelInstance?.getAllModels() ?? [];\n  // sort by module name\n  const sortedModelKeys = modelKeys\n    .sort((a, b) => a.module.localeCompare(b.module))\n    .map((model) => {\n      return {\n        key: model.key,\n        module: model.module,\n        path: model.path,\n      };\n    });\n\n  return sortedModelKeys;\n};\n\nconst REQUIRED_PERMISSIONS = [\"system.models.read\"];\n\nexport async function GET(request: NextRequest) {\n  const authzResponse = await requirePermissions(request, REQUIRED_PERMISSIONS);\n\n  if (authzResponse) {\n    return authzResponse;\n  }\n\n  const modelList = await getModelList();\n\n  return JSONResponse({\n    data: modelList,\n    total: modelList.length,\n    message: `Loaded ${modelList.length} model(s)`,\n    status: 200,\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/admin/model/reload-model.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":64,"fix":{"range":[189,189],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":43,"fix":{"range":[0,233],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { escapeHtml } from \"@base/server/utils/xss-protection\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":18,"suggestions":[{"fix":{"range":[1699,1747],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { escapeHtml } from \"@base/server/utils/xss-protection\";\nimport { NextRequest } from \"next/server\";\n\nimport { RuntimeContext } from \"../../../runtime/RuntimeContext\";\n\ntype ReloadModelRequest = {\n  key?: unknown;\n};\n\nconst REQUIRED_PERMISSIONS = [\"system.models.reload\"];\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authzResponse = await requirePermissions(\n      request,\n      REQUIRED_PERMISSIONS,\n    );\n\n    if (authzResponse) {\n      return authzResponse;\n    }\n\n    const body = (await request.json().catch(() => ({}))) as ReloadModelRequest;\n    const modelKey = typeof body.key === \"string\" ? body.key.trim() : \"\";\n\n    if (!modelKey) {\n      return JSONResponse({\n        message: \"Model key is required.\",\n        status: 400,\n      });\n    }\n\n    const modelInstance = await RuntimeContext.getModelInstance();\n\n    if (!modelInstance) {\n      return JSONResponse({\n        message: \"Model instance is not available.\",\n        status: 500,\n      });\n    }\n\n    const reloaded = await modelInstance.reloadModel(modelKey);\n\n    if (!reloaded) {\n      // Sanitize modelKey to prevent XSS in error message\n      const safeModelKey = escapeHtml(modelKey);\n\n      return JSONResponse({\n        message: `Failed to reload model \"${safeModelKey}\".`,\n        status: 404,\n      });\n    }\n\n    // Sanitize modelKey to prevent XSS in success message\n    const safeModelKey = escapeHtml(modelKey);\n\n    return JSONResponse({\n      message: `Model \"${safeModelKey}\" reloaded successfully.`,\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Failed to reload model:\", error);\n\n    return JSONResponse({\n      message: \"Unexpected error while reloading model.\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/auth/login.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":18,"suggestions":[{"fix":{"range":[5321,5358],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { compare } from \"bcryptjs\";\nimport { eq } from \"drizzle-orm\";\nimport { NextRequest } from \"next/server\";\n\nimport { SESSION_CONFIG } from \"../../config\";\nimport { setCsrfTokenCookie } from \"../../middleware/csrf\";\nimport SessionModel from \"../../models/Sessions/SessionModel\";\nimport { RuntimeContext } from \"../../runtime/RuntimeContext\";\nimport { base_tb_users, base_tb_users_login } from \"../../schemas/base.user\";\nimport { JSONResponse } from \"../../utils/JSONResponse\";\nimport {\n  getClientIp,\n  getUserAgent,\n  logAuthFailure,\n  logAuthSuccess,\n} from \"../../utils/security-logger\";\n\ninterface LoginRequest {\n  username?: string;\n  email?: string;\n  phone?: string;\n  password: string;\n  rememberMe?: boolean;\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body: LoginRequest = await request.json();\n    const { username, password, rememberMe = false } = body;\n\n    // Validate input\n    if (!password) {\n      return JSONResponse({\n        error: \"Password is required\",\n        status: 400,\n      });\n    }\n\n    if (!username) {\n      return JSONResponse({\n        error: \"Username, email, or phone is required\",\n        status: 400,\n      });\n    }\n\n    const db = await RuntimeContext.getDbConnect();\n\n    // Find user login by username, email, or phone in parallel\n    const queries = [];\n\n    if (username) {\n      queries.push(\n        db\n          .select()\n          .from(base_tb_users_login)\n          .where(eq(base_tb_users_login.username, username))\n          .limit(1)\n          .then((result) => result[0] || null),\n      );\n      queries.push(\n        db\n          .select()\n          .from(base_tb_users_login)\n          .where(eq(base_tb_users_login.email, username))\n          .limit(1)\n          .then((result) => result[0] || null),\n      );\n      queries.push(\n        db\n          .select()\n          .from(base_tb_users_login)\n          .where(eq(base_tb_users_login.phone, username))\n          .limit(1)\n          .then((result) => result[0] || null),\n      );\n    }\n\n    // Execute all queries in parallel and get the first non-null result\n    const results = await Promise.all(queries);\n    const userLogin = results.find((user) => user !== null);\n\n    if (!userLogin) {\n      logAuthFailure(\"User not found\", {\n        ip: getClientIp(request),\n        userAgent: getUserAgent(request),\n        path: request.nextUrl.pathname,\n        username,\n      });\n\n      return JSONResponse({\n        error: \"Invalid credentials\",\n        status: 401,\n      });\n    }\n\n    // Verify password\n\n    const passwordValid = await compare(password, userLogin.passwordHash);\n\n    if (!passwordValid) {\n      logAuthFailure(\"Password mismatch\", {\n        ip: getClientIp(request),\n        userAgent: getUserAgent(request),\n        path: request.nextUrl.pathname,\n        username: userLogin.username || undefined,\n        email: userLogin.email || undefined,\n      });\n\n      return JSONResponse({\n        error: \"Invalid credentials\",\n        status: 401,\n      });\n    }\n\n    // Get user info\n    const [user] = await db\n      .select()\n      .from(base_tb_users)\n      .where(eq(base_tb_users.id, userLogin.userId))\n      .limit(1);\n\n    if (!user) {\n      return JSONResponse({\n        error: \"User not found\",\n        status: 404,\n      });\n    }\n\n    // Check if user is active\n\n    if (user.status !== \"active\") {\n      return JSONResponse({\n        error: \"Account is not active\",\n        status: 403,\n      });\n    }\n\n    // Create session\n    const ipAddress = getClientIp(request);\n    const userAgent = getUserAgent(request);\n    const sessionModel = new SessionModel();\n\n    // Set session expiration: 30 days if remember me, 7 days otherwise\n    const expiresIn = rememberMe\n      ? SESSION_CONFIG.expiration.rememberMe\n      : SESSION_CONFIG.expiration.default;\n\n    const session = await sessionModel.createSession({\n      userId: user.id,\n      ipAddress,\n      userAgent,\n      expiresIn,\n    });\n\n    // Update last login info\n    const now = new Date();\n\n    await db\n      .update(base_tb_users_login)\n      .set({\n        lastLoginAt: now,\n        lastLoginIp: ipAddress,\n        lastLoginUserAgent: userAgent,\n        updatedAt: now,\n      })\n      .where(eq(base_tb_users_login.userId, user.id));\n\n    // Create response with session cookie\n    const response = JSONResponse({\n      data: {\n        user: {\n          id: user.id,\n          username: userLogin.username,\n          avatar: user.avatar,\n        },\n      },\n      status: 200,\n    });\n\n    // Set session cookie\n    const cookieMaxAge = rememberMe\n      ? SESSION_CONFIG.cookie.maxAge.rememberMe\n      : SESSION_CONFIG.cookie.maxAge.default;\n\n    response.cookies.set(SESSION_CONFIG.cookie.name, session.sessionToken, {\n      httpOnly: SESSION_CONFIG.cookie.httpOnly,\n      secure: SESSION_CONFIG.cookie.secure,\n      sameSite: SESSION_CONFIG.cookie.sameSite,\n      maxAge: cookieMaxAge,\n      path: SESSION_CONFIG.cookie.path,\n    });\n\n    // Set CSRF token cookie after successful login\n    setCsrfTokenCookie(response);\n\n    // Log successful authentication\n    logAuthSuccess({\n      ip: ipAddress,\n      userAgent,\n      path: request.nextUrl.pathname,\n      userId: user.id,\n      username: userLogin.username || \"unknown\",\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"Login error:\", error);\n\n    return JSONResponse({\n      error: \"Login failed\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/auth/logout.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/JSONResponse`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,107],"text":"import { NextRequest } from \"next/server\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":18,"suggestions":[{"fix":{"range":[904,942],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport { SESSION_CONFIG } from \"../../config\";\nimport SessionModel from \"../../models/Sessions/SessionModel\";\n\n/**\n * POST /api/base/auth/logout\n * Logout user by destroying session\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const sessionToken = request.cookies.get(SESSION_CONFIG.cookie.name)?.value;\n\n    if (sessionToken) {\n      const sessionModel = new SessionModel();\n\n      await sessionModel.destroySession(sessionToken);\n    }\n\n    // Create response\n    const response = JSONResponse({\n      message: \"Logged out successfully\",\n      status: 200,\n    });\n\n    // Clear session cookie\n    response.cookies.delete(SESSION_CONFIG.cookie.name);\n\n    // Clear CSRF token cookie\n    response.cookies.delete(\"csrf-token\");\n\n    return response;\n  } catch (error) {\n    console.error(\"Logout error:\", error);\n\n    return JSONResponse({\n      error: \"Logout failed\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/auth/me.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/JSONResponse`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,107],"text":"import { NextRequest } from \"next/server\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":31,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":31,"endColumn":18,"suggestions":[{"fix":{"range":[795,843],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport { getAuthenticatedUser } from \"../../utils/auth-helpers\";\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Authentication is handled by proxy.ts\n    // User info is available in headers if authenticated\n    const user = getAuthenticatedUser(request);\n\n    if (!user) {\n      return JSONResponse({\n        error: \"Authentication required\",\n        message: \"You must be authenticated to access this resource\",\n        status: 401,\n      });\n    }\n\n    return JSONResponse({\n      data: {\n        user: {\n          id: user.id,\n          username: user.username,\n          avatar: user.avatar,\n        },\n      },\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Get current user error:\", error);\n\n    return JSONResponse({\n      error: \"Failed to get current user\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/heath/index.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/JSONResponse`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,107],"text":"import { NextRequest } from \"next/server\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":16,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":16,"endColumn":18,"suggestions":[{"fix":{"range":[411,455],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nexport async function GET(_request: NextRequest) {\n  try {\n    return JSONResponse({\n      message: \"Health check passed\",\n      data: {\n        status: \"healthy\",\n        timestamp: new Date().toISOString(),\n        uptime: process.uptime(),\n      },\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Health check error:\", error);\n\n    return JSONResponse({\n      message: \"Health check failed\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/heath/ping.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/JSONResponse`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,107],"text":"import { NextRequest } from \"next/server\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nexport async function GET(_request: NextRequest) {\n  return JSONResponse({\n    message: \"pong\",\n    data: {\n      timestamp: new Date().toISOString(),\n    },\n    status: 200,\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/media/get.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":66,"fix":{"range":[65,65],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/models/Media`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":57,"fix":{"range":[0,123],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport { getMediaServiceModel } from \"@base/server/models/Media\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":18,"suggestions":[{"fix":{"range":[1456,1496],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { getMediaServiceModel } from \"@base/server/models/Media\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport async function GET(\n  request: NextRequest,\n  context: { params: Promise<{ type: string; filename: string }> },\n) {\n  try {\n    const params = await context.params;\n    const { type, filename } = params;\n\n    // Validate type\n    if (type !== \"image\" && type !== \"file\") {\n      return NextResponse.json(\n        { error: \"Invalid type. Must be 'image' or 'file'\" },\n        { status: 400 },\n      );\n    }\n\n    const mediaService = getMediaServiceModel();\n    const fileData = await mediaService.getFile(\n      type as \"image\" | \"file\",\n      filename,\n    );\n\n    if (!fileData) {\n      return NextResponse.json({ error: \"File not found\" }, { status: 404 });\n    }\n\n    // Return file with appropriate headers\n    // Add Content Security Policy for SVG files to prevent XSS\n    const headers: HeadersInit = {\n      \"Content-Type\": fileData.mimeType,\n      \"Content-Length\": fileData.size.toString(),\n      \"Cache-Control\": \"public, max-age=31536000, immutable\",\n      \"X-Content-Type-Options\": \"nosniff\",\n    };\n\n    // For SVG files, add CSP to prevent XSS\n    if (fileData.mimeType === \"image/svg+xml\") {\n      headers[\"Content-Security-Policy\"] =\n        \"default-src 'none'; script-src 'none'; style-src 'unsafe-inline'\";\n    }\n\n    return new NextResponse(fileData.buffer as any, { headers });\n  } catch (error) {\n    console.error(\"Get file error:\", error);\n\n    return NextResponse.json(\n      {\n        error: \"Failed to get file\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/media/upload.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[129,129],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/models/Media`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,173],"text":"import { NextRequest } from \"next/server\";\nimport { getMediaServiceModel } from \"@base/server/models/Media\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":18,"suggestions":[{"fix":{"range":[697,735],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { getMediaServiceModel } from \"@base/server/models/Media\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"file\") as File | null;\n\n    if (!file) {\n      return JSONResponse({\n        error: \"No file provided\",\n        status: 400,\n      });\n    }\n\n    const mediaService = getMediaServiceModel();\n    const result = await mediaService.upload(file);\n\n    return JSONResponse({\n      data: result,\n      message: \"File uploaded successfully\",\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Upload error:\", error);\n\n    return JSONResponse({\n      error: \"Failed to upload file\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/rpc/handle.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":18,"suggestions":[{"fix":{"range":[693,750],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\";\n\nimport JsonRpcHandler from \"../../rpc/jsonRpcHandler\";\n\n// Create RPC handler instance (internal use, no auth/rate limit - handled by middleware)\nconst rpcHandler = new JsonRpcHandler();\n\nexport async function POST(request: NextRequest) {\n  // get header X-RPC-Method\n  const method = request.headers.get(\"X-RPC-Method\") || \"\";\n\n  try {\n    // Handle JSON-RPC request directly without authentication or rate limiting\n    // Authentication and rate limiting are handled by middleware\n    const response = await rpcHandler.handle(request);\n\n    response.headers.set(\"X-RPC-Method\", method);\n\n    return response;\n  } catch (error) {\n    console.error(\"Internal JSON-RPC handler error:\", error);\n\n    const response = NextResponse.json(\n      {\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32700,\n          message: \"Parse error\",\n          data: error instanceof Error ? error.message : String(error),\n        },\n        id: null,\n      },\n      { status: 400 },\n    );\n\n    response.headers.set(\"X-RPC-Method\", method);\n\n    return response;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/permissions/list.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":17,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":17,"endColumn":18,"suggestions":[{"fix":{"range":[490,541],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\n\nimport PermissionModel from \"../../../models/Permission/PermissionModel\";\n\nexport async function GET() {\n  try {\n    const permissionModel = new PermissionModel();\n    const permissions = await permissionModel.getPermissions();\n\n    return JSONResponse({\n      data: permissions,\n      total: permissions.length,\n      message: `Loaded ${permissions.length} permission(s)`,\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Error loading permissions:\", error);\n\n    return JSONResponse({\n      data: [],\n      error: \"Failed to load permissions\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/roles/create.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[125,125],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,169],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":18,"suggestions":[{"fix":{"range":[1510,1555],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport RoleModel, { type RoleInput } from \"../../../models/Role/RoleModel\";\n\nconst REQUIRED_PERMISSIONS = [\"settings.roles.manage\"];\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authzResponse = await requirePermissions(\n      request,\n      REQUIRED_PERMISSIONS,\n    );\n\n    if (authzResponse) {\n      return authzResponse;\n    }\n\n    const body = await request.json();\n    const { code, name, description, permissionIds } = body;\n\n    if (!code || !name) {\n      return JSONResponse({\n        error: \"Code and name are required\",\n        status: 400,\n      });\n    }\n\n    const roleModel = new RoleModel();\n\n    // Check if role with same code already exists\n    const existingRole = await roleModel.getRoleByCode(code);\n\n    if (existingRole) {\n      return JSONResponse({\n        error: \"Role with this code already exists\",\n        status: 400,\n      });\n    }\n\n    const permissions = Array.isArray(permissionIds) ? permissionIds : [];\n\n    const roleInput: RoleInput = {\n      code,\n      name,\n      description: description || null,\n      permissions,\n      isSystem: false,\n      isActive: true,\n    };\n\n    const newRole = await roleModel.createRole(roleInput);\n\n    return JSONResponse({\n      data: newRole,\n      message: \"Role created successfully\",\n      status: 201,\n    });\n  } catch (error) {\n    console.error(\"Error creating role:\", error);\n\n    return JSONResponse({\n      error: \"Failed to create role\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/roles/delete.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[125,125],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,169],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":18,"suggestions":[{"fix":{"range":[1085,1130],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport RoleModel from \"../../../models/Role/RoleModel\";\n\nconst REQUIRED_PERMISSIONS = [\"settings.roles.manage\"];\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const authzResponse = await requirePermissions(\n      request,\n      REQUIRED_PERMISSIONS,\n    );\n\n    if (authzResponse) {\n      return authzResponse;\n    }\n\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get(\"id\");\n\n    if (!id) {\n      return JSONResponse({\n        error: \"Role ID is required\",\n        status: 400,\n      });\n    }\n\n    const roleModel = new RoleModel();\n    const result = await roleModel.deleteRole(id);\n\n    if (!result.success) {\n      return JSONResponse({\n        error: result.message,\n        status: result.message === \"Role not found\" ? 404 : 400,\n      });\n    }\n\n    return JSONResponse({\n      message: result.message,\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Error deleting role:\", error);\n\n    return JSONResponse({\n      error: \"Failed to delete role\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/roles/get.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[125,125],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,169],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":49,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":49,"endColumn":18,"suggestions":[{"fix":{"range":[1142,1186],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport RoleModel from \"../../../models/Role/RoleModel\";\n\nconst REQUIRED_PERMISSIONS = [\"settings.roles.read\"];\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authzResponse = await requirePermissions(\n      request,\n      REQUIRED_PERMISSIONS,\n    );\n\n    if (authzResponse) {\n      return authzResponse;\n    }\n\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get(\"id\");\n\n    if (!id) {\n      return JSONResponse({\n        error: \"Role ID is required\",\n        status: 400,\n      });\n    }\n\n    const roleModel = new RoleModel();\n    const result = await roleModel.getRoleWithPermissions(id);\n\n    if (!result) {\n      return JSONResponse({\n        error: \"Role not found\",\n        status: 404,\n      });\n    }\n\n    return JSONResponse({\n      data: {\n        ...result.role,\n        permissions: result.permissions,\n      },\n      message: \"Role loaded successfully\",\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Error loading role:\", error);\n\n    return JSONResponse({\n      error: \"Failed to load role\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/roles/list.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[125,125],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,169],"text":"import { NextRequest } from \"next/server\";\nimport { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":30,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":30,"endColumn":18,"suggestions":[{"fix":{"range":[764,809],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { requirePermissions } from \"@base/server/middleware\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport RoleModel from \"../../../models/Role/RoleModel\";\n\nconst REQUIRED_PERMISSIONS = [\"settings.roles.read\"];\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authzResponse = await requirePermissions(\n      request,\n      REQUIRED_PERMISSIONS,\n    );\n\n    if (authzResponse) {\n      return authzResponse;\n    }\n\n    const roleModel = new RoleModel();\n    const roles = await roleModel.getAllRoles();\n\n    return JSONResponse({\n      data: roles,\n      total: roles.length,\n      message: `Loaded ${roles.length} role(s)`,\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Error loading roles:\", error);\n\n    return JSONResponse({\n      data: [],\n      error: \"Failed to load roles\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/settings/roles/update.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/JSONResponse`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,107],"text":"import { NextRequest } from \"next/server\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":18,"suggestions":[{"fix":{"range":[1905,1950],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\nimport RoleModel, { type RoleInput } from \"../../../models/Role/RoleModel\";\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { id, code, name, description, permissionIds } = body;\n\n    if (!id || !code || !name) {\n      return JSONResponse({\n        error: \"ID, code, and name are required\",\n        status: 400,\n      });\n    }\n\n    const roleModel = new RoleModel();\n\n    // Check if role exists\n    const existingRole = await roleModel.getRoleById(id);\n\n    if (!existingRole) {\n      return JSONResponse({\n        error: \"Role not found\",\n        status: 404,\n      });\n    }\n\n    // Check if another role with same code exists (excluding current role)\n    const duplicateRole = await roleModel.getRoleByCode(code);\n\n    if (duplicateRole && duplicateRole.id !== id) {\n      return JSONResponse({\n        error: \"Role with this code already exists\",\n        status: 400,\n      });\n    }\n\n    // Convert permissionIds to permission keys if needed\n    // For now, assuming permissionIds are permission IDs, not keys\n    // But RoleModel.updateRole expects permission keys, so we need to convert\n    // For simplicity, let's assume permissionIds are already permission keys\n    const permissions = Array.isArray(permissionIds) ? permissionIds : [];\n\n    const updatePayload: Partial<RoleInput> = {\n      code,\n      name,\n      description: description || null,\n      permissions,\n    };\n\n    const updatedRole = await roleModel.updateRole(id, updatePayload);\n\n    if (!updatedRole) {\n      return JSONResponse({\n        error: \"Failed to update role\",\n        status: 500,\n      });\n    }\n\n    return JSONResponse({\n      data: updatedRole,\n      message: \"Role updated successfully\",\n      status: 200,\n    });\n  } catch (error) {\n    console.error(\"Error updating role:\", error);\n\n    return JSONResponse({\n      error: \"Failed to update role\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/utils/get-csrf-token.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":64,"fix":{"range":[134,134],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/utils/csrf-token`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":43,"fix":{"range":[0,178],"text":"import { NextRequest } from \"next/server\";\nimport { createSignedCsrfToken } from \"@base/server/utils/csrf-token\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":9,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":18,"suggestions":[{"fix":{"range":[1072,1125],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { createSignedCsrfToken } from \"@base/server/utils/csrf-token\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { NextRequest } from \"next/server\";\n\n/**\n * GET /api/base/utils/get-csrf-token\n * Generate and return a CSRF token for the client\n */\nexport async function GET(request: NextRequest) {\n  try {\n    // Generate signed CSRF token\n    const { token, signedToken, expiresAt } = createSignedCsrfToken();\n\n    // Create response with token\n    const response = JSONResponse({\n      data: {\n        token,\n        expiresAt,\n      },\n      status: 200,\n    });\n\n    // Set the same signed token in cookie (not generating a new one)\n    const isProduction = process.env.NODE_ENV === \"production\";\n    const maxAge = Math.floor((expiresAt - Date.now()) / 1000); // Convert to seconds\n\n    response.cookies.set(\"csrf-token\", signedToken, {\n      httpOnly: false, // Allow client-side JavaScript to read it\n      secure: isProduction,\n      sameSite: \"lax\",\n      maxAge,\n      path: \"/\",\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"CSRF token generation error:\", error);\n\n    return JSONResponse({\n      error: \"Failed to generate CSRF token\",\n      message: error instanceof Error ? error.message : \"Unknown error\",\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/controllers/workspace/get-menu.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":16,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":16,"endColumn":18,"suggestions":[{"fix":{"range":[385,430],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/interfaces/DynamicEntities.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LocaleDataType } from \"../../shared/interface/Locale\";\nimport { User } from \"./User\";\n\nexport type DynamicEntityData =\n  | \"string\"\n  | \"number\"\n  | \"boolean\"\n  | \"date\"\n  | \"select\"\n  | \"multi-select\";\n\nexport type DynamicEntityValidationNumber = {\n  min?: number;\n  max?: number;\n  notZero?: boolean;\n  allowNegative?: boolean;\n  message?: LocaleDataType<string>;\n};\nexport type DynamicEntityValidationString = {\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  message?: LocaleDataType<string>;\n};\n\nexport interface DynamicEntity<V = string> {\n  id: string; // uuid v7\n  code: string; // code là một string viết liền không dấu, hoặc cách nhau dấu _\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string>;\n  model: string; // name of the model // 'product, customer, supplier, etc.\n  dataType: DynamicEntityData;\n  options?: {\n    label: LocaleDataType<string>;\n    value: V;\n  }[];\n  defaultValue?: V;\n  isRequired?: boolean;\n  validation?: (\n    | DynamicEntityValidationNumber\n    | DynamicEntityValidationString\n  )[];\n\n  useIn?: {\n    report?: boolean;\n    list?: boolean;\n    filter?: boolean;\n  };\n  isActive: boolean;\n  order: number;\n  createdAt?: number; // unix timestamp (ms)\n  updatedAt?: number; // unix timestamp (ms)\n  createdBy?: User;\n  updatedBy?: User;\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/interfaces/Menu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/interfaces/User.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/loaders/menu-loader.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":20,"suggestions":[{"fix":{"range":[1586,1637],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":18,"suggestions":[{"fix":{"range":[2122,2176],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":128,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":128,"endColumn":20,"suggestions":[{"fix":{"range":[3363,3463],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync, readFileSync, readdirSync } from \"fs\";\nimport { join } from \"path\";\n\nimport { MenuFactoryElm } from \"../interfaces/Menu\";\n\nconst normalizePath = (modulePrefix: string, segment?: string) => {\n  if (!segment) return undefined;\n\n  const cleaned = segment.startsWith(\"/\")\n    ? segment\n    : segment.length > 0\n      ? `/${segment}`\n      : \"/\";\n\n  return `${modulePrefix}${cleaned.replace(/\\/$/, \"\") || \"/\"}`;\n};\n\nconst sortByOrder = (items: MenuFactoryElm[] = []) =>\n  [...items].sort((a, b) => {\n    const orderA = a.order ?? Number.MAX_SAFE_INTEGER;\n    const orderB = b.order ?? Number.MAX_SAFE_INTEGER;\n\n    if (orderA !== orderB) {\n      return orderA - orderB;\n    }\n\n    return a.name.localeCompare(b.name);\n  });\n\nconst attachPrefix = (\n  items: MenuFactoryElm[] = [],\n  modulePrefix: string,\n  type: \"main\" | \"mdl\",\n): MenuFactoryElm[] =>\n  sortByOrder(items).map((item) => ({\n    ...item,\n    type,\n    path: normalizePath(modulePrefix, item.path),\n    as: normalizePath(modulePrefix, item.as ?? item.path),\n    children: item.children\n      ? attachPrefix(item.children, modulePrefix, type)\n      : undefined,\n  }));\n\n/**\n * Load menus from module-base (main menus)\n */\nexport function loadMenusFromBase(): MenuFactoryElm[] {\n  const baseMenuFile = join(\n    process.cwd(),\n    \"module-base\",\n    \"client\",\n    \"menu.json\",\n  );\n\n  if (!existsSync(baseMenuFile)) {\n    return [];\n  }\n\n  try {\n    const raw = readFileSync(baseMenuFile, \"utf8\");\n    const menuDataArray = JSON.parse(raw) as MenuFactoryElm[];\n\n    if (!Array.isArray(menuDataArray)) {\n      console.error(\"Base menu.json should be an array\");\n\n      return [];\n    }\n\n    const basePrefix = \"/workspace\";\n\n    return sortByOrder(\n      menuDataArray.map((menuData) => ({\n        ...menuData,\n        type: \"main\" as const,\n        path: normalizePath(basePrefix, menuData.path ?? \"/\"),\n        as: normalizePath(basePrefix, menuData.as ?? menuData.path ?? \"/\"),\n        children: menuData.children\n          ? attachPrefix(menuData.children, basePrefix, \"main\")\n          : undefined,\n      })),\n    );\n  } catch (error) {\n    console.error(\"Error parsing base menu.json:\", error);\n\n    return [];\n  }\n}\n\n/**\n * Load menus from modules (module menus)\n */\nexport function loadMenusFromModules(): MenuFactoryElm[] {\n  const modulesDirectory = join(process.cwd(), \"modules\");\n\n  if (!existsSync(modulesDirectory)) {\n    return [];\n  }\n\n  const moduleDirs = readdirSync(modulesDirectory, { withFileTypes: true })\n    .filter((dirent) => dirent.isDirectory())\n    .map((dirent) => dirent.name);\n\n  const menus: MenuFactoryElm[] = [];\n\n  for (const moduleDir of moduleDirs) {\n    const menuFile = join(modulesDirectory, moduleDir, \"client\", \"menu.json\");\n\n    if (!existsSync(menuFile)) {\n      continue;\n    }\n\n    try {\n      const raw = readFileSync(menuFile, \"utf8\");\n      const menuData = JSON.parse(raw) as MenuFactoryElm;\n      const modulePrefix = `/workspace/modules/${moduleDir}`;\n\n      menus.push({\n        ...menuData,\n        type: \"mdl\" as const,\n        // path: normalizePath(modulePrefix, menuData.path ?? \"/\"),\n        // as: normalizePath(modulePrefix, menuData.as ?? menuData.path ?? \"/\"),\n        children: menuData.children\n          ? attachPrefix(menuData.children, modulePrefix, \"mdl\")\n          : undefined,\n      });\n    } catch (error) {\n      console.error(\n        `Error parsing menu.json for module \"${moduleDir}\":`,\n        error,\n      );\n    }\n  }\n\n  return sortByOrder(menus);\n}\n\n/**\n * Load all menus (base + modules) as a single array\n */\nexport function loadAllMenus(): MenuFactoryElm[] {\n  const menuItems: MenuFactoryElm[] = [];\n\n  // Load base menus (type: \"main\")\n  const baseMenus = loadMenusFromBase();\n\n  menuItems.push(...baseMenus);\n\n  // Load module menus (type: \"mdl\")\n  const moduleMenus = loadMenusFromModules();\n\n  menuItems.push(...moduleMenus);\n\n  return sortByOrder(menuItems);\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/auth.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[223,223],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/config`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":57,"fix":{"range":[0,281],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport { AUTH_CONFIG } from \"@base/server/config\";\nimport SessionModel from \"@base/server/models/Sessions/SessionModel\";\nimport {\n  getClientIp,\n  getUserAgent,\n  logAuthFailure,\n} from \"@base/server/utils/security-logger\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { AUTH_CONFIG } from \"@base/server/config\";\nimport SessionModel from \"@base/server/models/Sessions/SessionModel\";\nimport {\n  getClientIp,\n  getUserAgent,\n  logAuthFailure,\n} from \"@base/server/utils/security-logger\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * Authenticate request and inject user info into headers\n * Returns error response if authentication fails, null otherwise\n */\nexport async function authenticateRequest(\n  request: NextRequest,\n  nextHeaders: Headers,\n): Promise<NextResponse | null> {\n  const sessionToken = request.cookies.get(\n    AUTH_CONFIG.sessionCookieName,\n  )?.value;\n\n  if (!sessionToken) {\n    logAuthFailure(\"Missing session token\", {\n      ip: getClientIp(request),\n      userAgent: getUserAgent(request),\n      path: request.nextUrl.pathname,\n      method: request.method,\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"Authentication required\",\n        message: \"Session token is required\",\n      },\n      { status: 401 },\n    );\n  }\n\n  try {\n    const sessionModel = new SessionModel();\n    const validationResult = await sessionModel.validateSession(sessionToken);\n\n    if (!validationResult.valid || !validationResult.session) {\n      logAuthFailure(\"Invalid or expired session\", {\n        ip: getClientIp(request),\n        userAgent: getUserAgent(request),\n        path: request.nextUrl.pathname,\n        method: request.method,\n        reason: validationResult.valid\n          ? \"Session expired\"\n          : \"Invalid session token\",\n      });\n\n      return NextResponse.json(\n        {\n          success: false,\n          error: \"Authentication failed\",\n          message: \"Invalid or expired session\",\n        },\n        { status: 401 },\n      );\n    }\n\n    // Inject user info into headers for route handlers\n    if (validationResult.user) {\n      nextHeaders.set(\"x-user-id\", validationResult.user.id);\n      nextHeaders.set(\"x-username\", validationResult.user.username);\n      if (validationResult.user.avatar) {\n        nextHeaders.set(\"x-user-avatar\", validationResult.user.avatar);\n      }\n    }\n    nextHeaders.set(\"x-session-id\", validationResult.session.id);\n    nextHeaders.set(\"x-session-token\", sessionToken);\n\n    return null;\n  } catch (error) {\n    logAuthFailure(\"Session validation error\", {\n      ip: getClientIp(request),\n      userAgent: getUserAgent(request),\n      path: request.nextUrl.pathname,\n      method: request.method,\n      error: error instanceof Error ? error.message : String(error),\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"Authentication failed\",\n        message: \"Failed to validate session\",\n      },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/csrf.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":45,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/config`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":57,"fix":{"range":[0,310],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport { CSRF_CONFIG } from \"@base/server/config\";\nimport {\n  createSignedCsrfToken,\n  verifyCsrfToken,\n} from \"@base/server/utils/csrf-token\";\nimport {\n  getClientIp,\n  getUserAgent,\n  logSuspiciousRequest,\n} from \"@base/server/utils/security-logger\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { CSRF_CONFIG } from \"@base/server/config\";\nimport {\n  createSignedCsrfToken,\n  verifyCsrfToken,\n} from \"@base/server/utils/csrf-token\";\nimport {\n  getClientIp,\n  getUserAgent,\n  logSuspiciousRequest,\n} from \"@base/server/utils/security-logger\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n// CSRF configuration\nconst CSRF_COOKIE_NAME = \"csrf-token\";\nconst CSRF_HEADER_NAME = \"X-CSRF-Token\";\nconst SAFE_METHODS = [\"GET\", \"HEAD\", \"OPTIONS\"];\n\n/**\n * Check CSRF protection for state-changing requests\n * Implements Double Submit Cookie Pattern:\n * 1. Token in cookie (signed) must match token in header (plain)\n * 2. Verify signature of cookie token\n * Returns error response if CSRF validation fails, null otherwise\n */\nexport function checkCsrfProtection(request: NextRequest): NextResponse | null {\n  const method = request.method;\n\n  // Skip CSRF check for safe methods\n  if (SAFE_METHODS.includes(method)) {\n    return null;\n  }\n\n  // Get tokens from both cookie and header (both are required)\n  const headerToken = request.headers.get(CSRF_HEADER_NAME);\n  const cookieSignedToken = request.cookies.get(CSRF_COOKIE_NAME)?.value;\n\n  // Both are required for Double Submit Cookie Pattern\n  if (!headerToken || !cookieSignedToken) {\n    logSuspiciousRequest(\"CSRF token missing\", {\n      ip: getClientIp(request),\n      userAgent: getUserAgent(request),\n      path: request.nextUrl.pathname,\n      method: request.method,\n      reason: !headerToken ? \"Missing header token\" : \"Missing cookie token\",\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"CSRF token validation failed\",\n        message: \"CSRF token is required in both cookie and header\",\n      },\n      { status: 403 },\n    );\n  }\n\n  // Verify the signed token from cookie\n  const verification = verifyCsrfToken(cookieSignedToken);\n\n  if (!verification.valid) {\n    const message = verification.expired\n      ? \"CSRF token has expired\"\n      : \"Invalid CSRF token\";\n\n    logSuspiciousRequest(\"CSRF token validation failed\", {\n      ip: getClientIp(request),\n      userAgent: getUserAgent(request),\n      path: request.nextUrl.pathname,\n      method: request.method,\n      reason: verification.expired\n        ? \"Token expired\"\n        : \"Invalid token signature\",\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"CSRF token validation failed\",\n        message,\n      },\n      { status: 403 },\n    );\n  }\n\n  // Extract plain token from cookie and compare with header token\n  // This is the core of Double Submit Cookie Pattern\n  const cookiePlainToken = verification.token;\n\n  if (!cookiePlainToken || cookiePlainToken !== headerToken) {\n    logSuspiciousRequest(\"CSRF token mismatch\", {\n      ip: getClientIp(request),\n      userAgent: getUserAgent(request),\n      path: request.nextUrl.pathname,\n      method: request.method,\n      reason: \"Cookie token does not match header token\",\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"CSRF token validation failed\",\n        message: \"CSRF token mismatch between cookie and header\",\n      },\n      { status: 403 },\n    );\n  }\n\n  return null;\n}\n\n/**\n * Generate and set CSRF token in response cookie\n * Used for initial token generation or token refresh\n */\nexport function setCsrfTokenCookie(response: NextResponse): void {\n  const { signedToken } = createSignedCsrfToken();\n  const isProduction = process.env.NODE_ENV === \"production\";\n  const maxAge = Math.floor(CSRF_CONFIG.expirationMs / 1000); // Convert to seconds\n\n  response.cookies.set(CSRF_COOKIE_NAME, signedToken, {\n    httpOnly: false, // Allow client-side JavaScript to read it\n    secure: isProduction,\n    sameSite: \"lax\",\n    maxAge,\n    path: \"/\",\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/page-headers.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":51,"fix":{"range":[50,50],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/config`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":43,"fix":{"range":[0,94],"text":"import { NextRequest } from \"next/server\";\nimport { AUTH_CONFIG } from \"@base/server/config\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { AUTH_CONFIG } from \"@base/server/config\";\nimport { NextRequest } from \"next/server\";\n\n/**\n * Add application-specific headers for page routes\n * - Locale header from cookie\n * - Workspace module header\n * - Optional session token (for pages to use)\n */\nexport function addPageHeaders(\n  request: NextRequest,\n  nextHeaders: Headers,\n  pathname: string,\n): void {\n  // Get locale from cookie and set it to x-locale header\n  const cookie = request.headers.get(\"cookie\");\n  let locale = \"en\";\n\n  if (cookie) {\n    const localeMatch = cookie\n      .split(\";\")\n      .map((c) => c.trim())\n      .find((c) => c.startsWith(\"NEXT_LOCALE=\"));\n\n    if (localeMatch) {\n      const localeCookie = localeMatch.split(\"=\")[1];\n\n      if (localeCookie) {\n        locale = localeCookie;\n      }\n    }\n  }\n  nextHeaders.set(\"x-locale\", locale);\n\n  // Handle workspace module header\n  if (pathname.startsWith(\"/workspace/modules/\")) {\n    const match = pathname.match(/^\\/workspace\\/modules\\/([^/]+)/);\n\n    if (match?.[1]) {\n      nextHeaders.set(\"x-workspace-module\", match[1]);\n    }\n  }\n\n  // Optionally inject session token for pages (if authenticated)\n  const sessionToken = request.cookies.get(\n    AUTH_CONFIG.sessionCookieName,\n  )?.value;\n\n  if (sessionToken) {\n    nextHeaders.set(\"x-session-token\", sessionToken);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/permissions.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":43,"fix":{"range":[42,42],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { NextRequest } from \"next/server\";\nimport UserPermissionModel from \"@base/server/models/UserPermission/UserPermissionModel\";\nimport { getAuthenticatedUser } from \"@base/server/utils/auth-helpers\";\nimport { JSONResponse } from \"@base/server/utils/JSONResponse\";\nimport { logAuthzFailure } from \"@base/server/utils/security-logger\";\n\n/**\n * Helper to ensure the current user has all required permissions.\n * Returns JSONResponse (403) if the user lacks permission, otherwise null.\n */\nexport async function requirePermissions(\n  request: NextRequest,\n  permissions: string[],\n) {\n  const user = getAuthenticatedUser(request);\n\n  if (!user) {\n    logAuthzFailure(\"Missing authenticated user in headers\", {\n      path: request.nextUrl.pathname,\n      method: request.method,\n    });\n\n    return JSONResponse({\n      status: 401,\n      error: \"Unauthorized\",\n      message: \"Authentication required\",\n    });\n  }\n\n  const permissionModel = new UserPermissionModel();\n  const hasAll = await permissionModel.hasAllPermissions(user.id, permissions);\n\n  if (!hasAll) {\n    logAuthzFailure(\"User lacks required permissions\", {\n      path: request.nextUrl.pathname,\n      method: request.method,\n      userId: user.id,\n      username: user.username,\n      requiredPermissions: permissions,\n    });\n\n    return JSONResponse({\n      status: 403,\n      error: \"Forbidden\",\n      message: \"You do not have permission to perform this action\",\n    });\n  }\n\n  return null;\n}\n\n/**\n * Helper to ensure the current user has at least one of the specified permissions.\n */\nexport async function requireAnyPermission(\n  request: NextRequest,\n  permissions: string[],\n) {\n  const user = getAuthenticatedUser(request);\n\n  if (!user) {\n    logAuthzFailure(\"Missing authenticated user in headers\", {\n      path: request.nextUrl.pathname,\n      method: request.method,\n    });\n\n    return JSONResponse({\n      status: 401,\n      error: \"Unauthorized\",\n      message: \"Authentication required\",\n    });\n  }\n\n  const permissionModel = new UserPermissionModel();\n  const hasAny = await permissionModel.hasAnyPermission(user.id, permissions);\n\n  if (!hasAny) {\n    logAuthzFailure(\"User lacks any of the required permissions\", {\n      path: request.nextUrl.pathname,\n      method: request.method,\n      userId: user.id,\n      username: user.username,\n      requiredPermissions: permissions,\n    });\n\n    return JSONResponse({\n      status: 403,\n      error: \"Forbidden\",\n      message: \"You do not have permission to perform this action\",\n    });\n  }\n\n  return null;\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/rate-limit.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[204,204],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/config`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":57,"fix":{"range":[0,262],"text":"import { NextRequest, NextResponse } from \"next/server\";\nimport { RATE_LIMIT_CONFIG } from \"@base/server/config\";\nimport { rateLimitStore } from \"@base/server/stores\";\nimport {\n  getClientIp,\n  logRateLimitViolation,\n} from \"@base/server/utils/security-logger\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { RATE_LIMIT_CONFIG } from \"@base/server/config\";\nimport { rateLimitStore } from \"@base/server/stores\";\nimport {\n  getClientIp,\n  logRateLimitViolation,\n} from \"@base/server/utils/security-logger\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * Check rate limit for request\n * Returns error response if rate limit exceeded, null otherwise\n */\nexport function checkRateLimit(\n  request: NextRequest,\n  pathname: string,\n): NextResponse | null {\n  const ip = getClientIp(request);\n  const isAuthRoute = pathname.startsWith(\"/api/base/auth/\");\n  const config = isAuthRoute ? RATE_LIMIT_CONFIG.auth : RATE_LIMIT_CONFIG.api;\n\n  const key = `rate-limit:${ip}`;\n  const count = rateLimitStore.increment(key, config.windowMs);\n\n  if (count > config.max) {\n    const resetTime = Math.ceil(\n      (rateLimitStore.getTimeUntilReset(key) + Date.now()) / 1000,\n    );\n    const retryAfter = Math.ceil(rateLimitStore.getTimeUntilReset(key) / 1000);\n\n    // Log rate limit violation\n    logRateLimitViolation({\n      ip,\n      userAgent: request.headers.get(\"user-agent\") || \"unknown\",\n      path: pathname,\n      method: request.method,\n      limit: config.max,\n      window: config.windowMs,\n      count,\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: \"Rate limit exceeded\",\n        message: \"Too many requests, please try again later\",\n        retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          \"X-RateLimit-Limit\": String(config.max),\n          \"X-RateLimit-Remaining\": \"0\",\n          \"X-RateLimit-Reset\": String(resetTime),\n          \"Retry-After\": String(retryAfter),\n        },\n      },\n    );\n  }\n\n  return null;\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/middleware/security-headers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/BaseModel.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":20,"suggestions":[{"fix":{"range":[1085,1135],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":26,"suggestions":[{"fix":{"range":[1412,1471],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Column } from \"drizzle-orm\";\nimport type { PgTable } from \"drizzle-orm/pg-core\";\nimport type { PostgresJsDatabase } from \"drizzle-orm/postgres-js\";\n\nimport { and, eq } from \"drizzle-orm\";\nimport { isEmpty } from \"lodash\";\n\nimport { RuntimeContext } from \"../runtime/RuntimeContext\";\n\nexport class BaseModel<TTable extends PgTable = PgTable> {\n  /**Main table of the model */\n  protected readonly table: TTable;\n  private _db: PostgresJsDatabase<Record<string, never>> | null = null;\n\n  constructor(table: TTable) {\n    this.table = table;\n  }\n\n  public get db(): PostgresJsDatabase<Record<string, never>> {\n    if (!this._db) {\n      // Try to grab a ready connection synchronously if RuntimeContext is already initialized.\n      // This avoids a race where the constructor kicks off async init but methods access `db`\n      // immediately (same tick) before the Promise resolves.\n      try {\n        const ctx = RuntimeContext.getInstance();\n        const db = ctx.getConnectionPool().getConnection();\n\n        this._db = db;\n\n        return db;\n      } catch {\n        console.log(\"Error getting database connection:\");\n        // Best-effort warm-up in background (do not block a sync getter)\n        void RuntimeContext.getDbConnect()\n          .then((db) => {\n            this._db = db;\n          })\n          .catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error(\"Error getting database connection:\", error);\n          });\n\n        throw new Error(\"Database connection not initialized\");\n      }\n    }\n\n    return this._db;\n  }\n\n  /**Check if a field and value exists in the model */\n  protected isExistInModelByFieldAndValue = async (params: {\n    field: string;\n    value: string;\n    ignore?: Record<string, unknown>;\n  }) => {\n    const { field, value, ignore } = params;\n\n    // check if field exists in table schema\n    const column = this.table[field as keyof typeof this.table] as\n      | Column\n      | undefined;\n\n    if (!column) {\n      throw new Error(`Field ${field} not found in table definition.`);\n    }\n    // if ignore is provided, ignore the row with this id when checking for duplicates, otherwise check for duplicates\n    if (!isEmpty(ignore)) {\n      // check  ignored has in table schema\n      const ignoredColumns = Object.keys(ignore || {});\n      const ignoredColumnsInTable = ignoredColumns.filter((columnName) =>\n        Boolean(\n          this.table[columnName as keyof typeof this.table] as\n            | Column\n            | undefined,\n        ),\n      );\n\n      if (ignoredColumnsInTable.length !== ignoredColumns.length) {\n        throw new Error(`Ignored columns not found in table definition.`);\n      }\n    }\n\n    const whereClause = !isEmpty(ignore)\n      ? and(\n          eq(column, value),\n          ...Object.entries(ignore).map(([key, value]) => {\n            const ignoreColumn = this.table[key as keyof typeof this.table] as\n              | Column\n              | undefined;\n\n            if (!ignoreColumn) {\n              throw new Error(\n                `Ignored column ${key} not found in table definition.`,\n              );\n            }\n\n            return eq(ignoreColumn, value);\n          }),\n        )\n      : eq(column, value);\n\n    const result = await this.db\n      ?.select()\n      .from(this.table as any)\n      .where(whereClause)\n      .limit(1);\n\n    return result?.length && result.length > 0\n      ? { isExist: true, data: result[0] }\n      : { isExist: false, data: null };\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/BaseViewListModel.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":141,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":58},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":233,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":233,"endColumn":20,"suggestions":[{"fix":{"range":[7182,7234],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":234,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":234,"endColumn":20,"suggestions":[{"fix":{"range":[7243,7281],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { PgTable } from \"drizzle-orm/pg-core\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamSortMultiple } from \"@base/shared/interface/SortInterface\";\n\nimport { isNil, omitBy } from \"lodash\";\nimport { asc, desc, or, sql, type Column } from \"drizzle-orm\";\n\nimport { BaseModel } from \"./BaseModel\";\n\n/**\n * Abstract base class for models that support view list data table functionality\n * Extends BaseModel and implements IBaseViewListModel interface\n *\n * Models that need view list functionality should extend this class\n * and implement the getViewDataList method\n */\nexport type ColumnMap = Map<\n  string,\n  {\n    column: Column;\n    sort?: boolean;\n  }\n>;\nexport type SearchConditionMap = Map<string, (text: string) => unknown>;\nexport type FilterCondition<TFilter extends ParamFilter> = (\n  currentFilterValue?: unknown,\n  filters?: TFilter | undefined,\n) => unknown | undefined;\nexport type FilterConditionMap<TFilter extends ParamFilter> = Map<\n  string,\n  FilterCondition<TFilter>\n>;\n\nexport abstract class BaseViewListModel<\n  TTable extends PgTable = PgTable,\n  TRow = unknown,\n  TFilter extends ParamFilter = ParamFilter,\n> extends BaseModel<TTable> {\n  private _columns?: ColumnMap;\n  private _search?: SearchConditionMap;\n  private _filter?: FilterConditionMap<TFilter>;\n  private _sortDefault?: ParamSortMultiple;\n  private readonly _sortDefaultOverride?: ParamSortMultiple;\n\n  constructor({\n    table,\n    sortDefault,\n  }: {\n    table: TTable;\n    sortDefault?: ParamSortMultiple;\n  }) {\n    super(table);\n    this._sortDefaultOverride = sortDefault;\n  }\n\n  // Lazy getters that call overridden methods when first accessed\n  protected get columns(): ColumnMap {\n    if (!this._columns) {\n      this._columns = this.declarationColumns();\n    }\n\n    return this._columns;\n  }\n\n  protected get search(): SearchConditionMap {\n    if (!this._search) {\n      this._search = this.declarationSearch();\n    }\n\n    return this._search;\n  }\n\n  protected get filter(): FilterConditionMap<TFilter> {\n    if (!this._filter) {\n      this._filter = this.declarationFilter();\n    }\n\n    return this._filter;\n  }\n\n  protected get sortDefault(): ParamSortMultiple {\n    if (!this._sortDefault) {\n      this._sortDefault = this._sortDefaultOverride ?? [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ];\n    }\n\n    return this._sortDefault;\n  }\n\n  // ============================================================================\n  // PROTECTED METHODS - Can be overridden by subclasses\n  // ============================================================================\n\n  /**\n   * Declare which columns are available for select/sort.\n   * Default implementation returns an empty Map.\n   * Subclass can override to provide columns mapping.\n   */\n  protected declarationColumns = (): ColumnMap => {\n    return new Map();\n  };\n\n  /**\n   * Declare how global search text is mapped to conditions.\n   * Returns a Map where key is the search field name and value is a function\n   * that receives the processed search text (may be empty string)\n   * and should return a drizzle condition or undefined.\n   * Default implementation returns an empty Map (no search).\n   * Subclass can override to provide search conditions.\n   */\n  protected declarationSearch = (): SearchConditionMap => {\n    return new Map();\n  };\n\n  /**\n   * Declare how filters are mapped to conditions.\n   * Returns a Map where key is the filter field name and value is a function\n   * that receives the filters object and returns a drizzle condition or undefined.\n   * Default implementation returns an empty Map (no additional filters).\n   * Subclass can override to provide filter conditions.\n   */\n\n  protected declarationFilter = (): FilterConditionMap<TFilter> => {\n    return new Map();\n  };\n\n  /**\n   * Declare how to map a raw DB row to the view row type (TRow)\n   * when using shared list/query helpers.\n   * Default implementation returns the row as-is.\n   * Subclass can override to transform the row data.\n   */\n  protected declarationMappingData = (row: unknown, index?: number): TRow => {\n    return row as TRow;\n  };\n\n  // ============================================================================\n  // PROTECTED HELPER METHODS\n  // ============================================================================\n\n  /**\n   * Build a query data list but allows specifying custom select columns/expressions.\n   * @param params - List query parameters\n   * @param select - Array of columns/expressions or a function (queryBuilder) to customize the select clause\n   * @param callBackBuildQuery - Optional callback to extend query (joins / where / filters) after search is applied\n   */\n  buildQueryDataListWithSelect = async (\n    params: ListParamsRequest<TFilter>,\n    select?: Record<string, Column>,\n    callBackBuildQuery?: (query: any) => any,\n  ): Promise<ListParamsResponse<TRow>> => {\n    const {\n      filters = undefined,\n      search,\n      sorts = undefined,\n      offset = 0,\n      limit = 50,\n    } = params;\n\n    const totalResultKey = \"total-data-response\" as keyof TRow;\n\n    // Start with a query builder: allow calling with select clauses\n\n    let query: any;\n\n    switch (typeof select) {\n      case \"object\":\n        {\n          const selectWithTotal = {\n            ...select,\n            [totalResultKey]: sql<number>`count(*) over()::int`.as(\"total\"),\n          };\n\n          query = this.db\n            .select(selectWithTotal as any)\n            .from(this.table as any);\n        }\n        break;\n\n      default:\n        {\n          const selectWithTotal = {\n            ...this.table, // select all columns (i.e., SELECT *)\n            [totalResultKey]: sql<number>`count(*) over()::int`.as(\"total\"),\n          };\n\n          query = this.db\n            .select(selectWithTotal as any)\n            .from(this.table as any);\n        }\n        break;\n    }\n\n    // Apply filter, search, etc., as per buildQueryDataList\n    // 1. Filter\n\n    // Lọc những key của filter có trong map this.filter\n    const filterKeys =\n      filters && typeof filters === \"object\" ? Object.keys(filters) : [];\n    const validFilterKeys = filterKeys.filter((key) => this.filter.has(key));\n    const filterConditionsByKeys = validFilterKeys\n      .map((key) => {\n        const filterFn = this.filter.get(key);\n        const filterValue = filters?.[key];\n\n        return filterFn ? filterFn(filterValue, filters) : undefined;\n      })\n      .filter((expr): expr is Exclude<typeof expr, undefined> => Boolean(expr));\n\n    if (filterConditionsByKeys.length > 0) {\n      query = query.where(...filterConditionsByKeys);\n    }\n\n    // 2. Search\n    const searchText = isNil(search) ? undefined : String(search).trim();\n\n    if (searchText) {\n      const searchExpressions = Array.from(this.search.values())\n        .map((searchTerm) => searchTerm(searchText))\n        .filter((expr): expr is Exclude<typeof expr, undefined> =>\n          Boolean(expr),\n        );\n\n      if (searchExpressions.length > 0) {\n        console.log(\"searchExpressions\", searchExpressions);\n        console.log(\"searchText\", searchText);\n\n        query = query.where(or(...(searchExpressions as any[])) as any);\n      }\n    }\n\n    // 3. Allow child model to extend query (joins / where / filters) via callback\n    if (callBackBuildQuery) {\n      query = callBackBuildQuery(query);\n    }\n\n    // 4. Sort\n    let orderByExpressions =\n      sorts\n        ?.map((sortObj: ParamSortMultiple[number]) => {\n          const sortColumn = this.columns.get(sortObj.column);\n\n          if (!sortColumn || !sortColumn.sort) {\n            return undefined;\n          }\n          if (sortObj.direction === \"descending\") {\n            return desc(sortColumn.column);\n          }\n\n          return asc(sortColumn.column);\n        })\n        .filter((expr): expr is ReturnType<typeof asc> => Boolean(expr)) ?? [];\n\n    if (orderByExpressions.length === 0) {\n      orderByExpressions = this.sortDefault\n        .map((sort) => {\n          const sortColumn = this.columns.get(sort.column);\n\n          if (!sortColumn || !sortColumn.sort) {\n            return undefined;\n          }\n          if (sort.direction === \"descending\") {\n            return desc(sortColumn.column);\n          }\n\n          return asc(sortColumn.column);\n        })\n        .filter((expr): expr is ReturnType<typeof asc> => Boolean(expr));\n    }\n\n    query = query.orderBy(...orderByExpressions);\n\n    // console.log(query.toSQL());\n\n    // drizzle select is then-able, so await directly\n    const result = (await query.limit(limit).offset(offset)) as Array<\n      Record<string, unknown>\n    >;\n\n    // Try to determine total if result includes it, otherwise fallback to length\n    // Check for both \"total-data-response\" (from buildQueryDataList) and \"totalResult\" keys\n\n    const total = (result?.[0]?.[totalResultKey as string] as number) ?? 0;\n    const data = result?.map((row) =>\n      omitBy(row, totalResultKey as string),\n    ) as TRow[];\n\n    return { data, total };\n  };\n\n  /**\n   * Helper to build paginated list query with common behavior.\n   *\n   * Sections:\n   * 1) Parse list params (offset, limit, search, filters, sorts)\n   * 2) Build base SELECT + FROM with columns map\n   * 3) Apply global search (this.search) if configured\n   * 4) Allow child model to extend query (joins / where / filters) via callback\n   * 5) Apply ORDER BY from `sorts` or `sortDefault`\n   * 6) Apply LIMIT/OFFSET and return `{ data, total, meta }`\n   */\n  protected buildQueryDataList = async (\n    params: ListParamsRequest<TFilter>,\n\n    callBackBuildQuery?: (query: any) => any,\n  ) => {\n    // Build base SELECT list from column map with total count\n    const selectColumns = Object.fromEntries(\n      Array.from(this.columns.entries()).map(([key, config]) => [\n        key,\n        config.column,\n      ]),\n    );\n\n    // Use buildQueryDataListWithSelect with custom select and callback\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      selectColumns as Record<string, Column>,\n      callBackBuildQuery,\n    );\n\n    return {\n      data:\n        result?.data?.map((row, index) =>\n          this.declarationMappingData(row, index),\n        ) ?? [],\n      total: result?.total ?? 0,\n    };\n  };\n\n  // ============================================================================\n  // PUBLIC METHODS\n  // ============================================================================\n\n  /**\n   * Default getData implementation using shared query/mapping logic\n   */\n  getData = async (\n    params: ListParamsRequest<TFilter>,\n  ): Promise<ListParamsResponse<TRow>> => {\n    return await this.buildQueryDataList(params);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Guidelines/GuidelineModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Locations/LocationInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Locations/LocationModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Logs/LogCompressionModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Logs/LogModel.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":214,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":214,"endColumn":20,"suggestions":[{"fix":{"range":[5626,5679],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":215,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":215,"endColumn":20,"suggestions":[{"fix":{"range":[5686,5735],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":235,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":235,"endColumn":20,"suggestions":[{"fix":{"range":[6209,6264],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":236,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":236,"endColumn":20,"suggestions":[{"fix":{"range":[6271,6320],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":253,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":253,"endColumn":20,"suggestions":[{"fix":{"range":[6643,6692],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Log Model\n *\n * Handles logging to files with rotation and compression support\n */\n\nimport {\n  appendFileSync,\n  existsSync,\n  mkdirSync,\n  statSync,\n  writeFileSync,\n} from \"fs\";\nimport { dirname, join } from \"path\";\n\nimport dayjs from \"dayjs\";\n\nimport { LOG_CONFIG } from \"../../config\";\n\nimport { LogGroup, LogSeverity, LogType, LogTypesToGroups } from \"./LogTypes\";\n\nexport interface LogEntry {\n  timestamp: string;\n  type: LogType;\n  severity: LogSeverity;\n  message: string;\n  metadata: Record<string, unknown>;\n}\n\nclass LogModel {\n  private readonly baseDirectory: string;\n  private readonly maxSizeBytes: number;\n  private readonly enabled: boolean;\n  private readonly destination: \"file\" | \"webhook\";\n  private readonly currentFiles: Map<string, { path: string; size: number }> =\n    new Map();\n\n  constructor() {\n    this.enabled = LOG_CONFIG.enabled;\n    this.destination = LOG_CONFIG.destination;\n    this.baseDirectory = LOG_CONFIG.file.directory;\n    this.maxSizeBytes = LOG_CONFIG.file.maxSizeBytes;\n\n    if (this.enabled && this.destination === \"file\") {\n      this.ensureDirectoryExists();\n    }\n  }\n\n  /**\n   * Ensure log directory exists\n   */\n  private ensureDirectoryExists(): void {\n    if (!existsSync(this.baseDirectory)) {\n      mkdirSync(this.baseDirectory, { recursive: true });\n    }\n  }\n\n  /**\n   * Ensure group directory exists (cached check)\n   */\n  private readonly groupDirsCache = new Set<string>();\n\n  /**\n   * Get log group for a log type\n   */\n  private getLogGroup(logType: LogType): LogGroup {\n    const group = LogTypesToGroups.get(logType);\n\n    if (!group) {\n      // Fallback to application if not found\n      return LogGroup.APPLICATION;\n    }\n\n    return group;\n  }\n\n  /**\n   * Ensure group directory exists\n   */\n  private ensureGroupDirectory(logType: LogType): string {\n    const group = this.getLogGroup(logType);\n    const groupDir = join(this.baseDirectory, group);\n\n    if (!this.groupDirsCache.has(groupDir) && !existsSync(groupDir)) {\n      mkdirSync(groupDir, { recursive: true });\n      this.groupDirsCache.add(groupDir);\n    }\n\n    return groupDir;\n  }\n\n  /**\n   * Get log file path for a specific log type and date\n   * Structure: log/{group}/{type}_DD_MM_YYYY[_number].log\n   */\n  private getLogFilePath(\n    logType: LogType,\n    date: dayjs.Dayjs,\n    chunkNumber: number = 0,\n  ): string {\n    const dateStr = date.format(\"DD_MM_YYYY\");\n    const groupDir = this.ensureGroupDirectory(logType);\n\n    const fileName =\n      chunkNumber === 0\n        ? `${logType}_${dateStr}.log`\n        : `${logType}_${dateStr}_${chunkNumber}.log`;\n\n    return join(groupDir, fileName);\n  }\n\n  /**\n   * Get or create current log file for a log type\n   */\n  private getCurrentLogFile(logType: LogType): string {\n    const today = dayjs();\n    const dateKey = today.format(\"YYYY-MM-DD\");\n    const cacheKey = `${logType}_${dateKey}`;\n\n    // Check if we have a cached file for today\n    const cached = this.currentFiles.get(cacheKey);\n\n    if (cached?.path && existsSync(cached.path)) {\n      try {\n        const stats = statSync(cached.path);\n\n        if (stats.size < this.maxSizeBytes) {\n          return cached.path;\n        }\n      } catch {\n        // File was deleted or inaccessible, continue to create new one\n      }\n    }\n\n    // Find the next available chunk number\n    let chunkNumber = 0;\n    let filePath = this.getLogFilePath(logType, today, chunkNumber);\n\n    while (existsSync(filePath)) {\n      try {\n        const stats = statSync(filePath);\n\n        if (stats.size < this.maxSizeBytes) {\n          // This file is still under size limit, use it\n          this.currentFiles.set(cacheKey, { path: filePath, size: stats.size });\n\n          return filePath;\n        }\n      } catch {\n        // File inaccessible, try next chunk\n      }\n      // File is too large, try next chunk\n      chunkNumber++;\n      filePath = this.getLogFilePath(logType, today, chunkNumber);\n    }\n\n    // Create new file\n    this.currentFiles.set(cacheKey, { path: filePath, size: 0 });\n\n    return filePath;\n  }\n\n  /**\n   * Format log entry to string\n   */\n  private formatLogEntry(entry: LogEntry): string {\n    const { timestamp, type, severity, message, metadata } = entry;\n\n    const metadataStr = Object.entries(metadata)\n      .filter(([_, value]) => value !== undefined && value !== null)\n      .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n      .join(\" \");\n\n    return `[SECURITY] [${severity.toUpperCase()}] [${type}] ${timestamp} ${message} ${metadataStr}\\n`;\n  }\n\n  /**\n   * Write log to file\n   */\n  private async writeToFile(entry: LogEntry): Promise<void> {\n    try {\n      const filePath = this.getCurrentLogFile(entry.type);\n      const logLine = this.formatLogEntry(entry);\n\n      if (existsSync(filePath)) {\n        appendFileSync(filePath, logLine, \"utf8\");\n      } else {\n        // Ensure directory exists (should already exist, but double-check)\n        const dir = dirname(filePath);\n\n        if (!existsSync(dir)) {\n          mkdirSync(dir, { recursive: true });\n        }\n        writeFileSync(filePath, logLine, \"utf8\");\n      }\n\n      // Update cached file size\n      const today = dayjs();\n      const dateKey = today.format(\"YYYY-MM-DD\");\n      const cacheKey = `${entry.type}_${dateKey}`;\n      const cached = this.currentFiles.get(cacheKey);\n\n      if (cached?.path === filePath) {\n        try {\n          const stats = statSync(filePath);\n\n          cached.size = stats.size;\n        } catch {\n          // Ignore errors when updating cache\n        }\n      }\n    } catch (error) {\n      // Fallback to console if file write fails\n      console.error(\"Failed to write log to file:\", error);\n      console.error(this.formatLogEntry(entry).trim());\n    }\n  }\n\n  /**\n   * Send log to webhook\n   */\n  private async writeToWebhook(entry: LogEntry): Promise<void> {\n    try {\n      const response = await fetch(LOG_CONFIG.webhook.url, {\n        method: \"POST\",\n        headers: LOG_CONFIG.webhook.headers,\n        body: JSON.stringify(entry),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Webhook returned ${response.status}`);\n      }\n    } catch (error) {\n      // Fallback to console if webhook fails\n      console.error(\"Failed to send log to webhook:\", error);\n      console.error(this.formatLogEntry(entry).trim());\n    }\n  }\n\n  /**\n   * Write log entry\n   */\n  async write(entry: LogEntry): Promise<void> {\n    if (!this.enabled) {\n      return;\n    }\n\n    if (this.destination === \"file\") {\n      await this.writeToFile(entry);\n    } else if (this.destination === \"webhook\") {\n      await this.writeToWebhook(entry);\n    } else {\n      console.error(this.formatLogEntry(entry).trim());\n    }\n  }\n\n  /**\n   * Initialize logging system\n   */\n  static initialize(): LogModel {\n    return new LogModel();\n  }\n}\n\n// Singleton instance\nlet logModelInstance: LogModel | null = null;\n\n/**\n * Get log model instance\n */\nexport function getLogModel(): LogModel {\n  if (!logModelInstance) {\n    logModelInstance = LogModel.initialize();\n  }\n\n  return logModelInstance;\n}\n\nexport default LogModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Logs/LogTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Logs/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Media/MediaServiceModel.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":20,"suggestions":[{"fix":{"range":[1777,1837],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":20,"suggestions":[{"fix":{"range":[5666,5712],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":245,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":245,"endColumn":22,"suggestions":[{"fix":{"range":[6889,6949],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":20,"suggestions":[{"fix":{"range":[8059,8103],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":316,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":316,"endColumn":20,"suggestions":[{"fix":{"range":[8651,8696],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from \"crypto\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nexport interface UploadResult {\n  id: string;\n  filename: string;\n  originalName: string;\n  path: string;\n  url: string;\n  size: number;\n  mimeType: string;\n  type: \"image\" | \"file\";\n}\n\n// Allowed file extensions\nconst ALLOWED_IMAGE_EXTENSIONS = [\".jpg\", \".jpeg\", \".png\", \".gif\", \".webp\"];\nconst ALLOWED_FILE_EXTENSIONS = [\n  \".pdf\",\n  \".doc\",\n  \".docx\",\n  \".xls\",\n  \".xlsx\",\n  \".txt\",\n  \".csv\",\n];\n\n// Allowed MIME types\nconst ALLOWED_IMAGE_MIME_TYPES = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/gif\",\n  \"image/webp\",\n];\nconst ALLOWED_FILE_MIME_TYPES = [\n  \"application/pdf\",\n  \"application/msword\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n  \"application/vnd.ms-excel\",\n  \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  \"text/plain\",\n  \"text/csv\",\n];\n\n// Maximum file size: 10MB (from env or default)\nconst MAX_FILE_SIZE =\n  parseInt(process.env.MAX_FILE_SIZE || \"10485760\", 10) || 10485760;\n\nclass MediaServiceModel {\n  private readonly storageDir: string;\n  private readonly imageDir: string;\n  private readonly fileDir: string;\n\n  constructor() {\n    // Get storage directory from env or use default\n    const rootDir = process.cwd();\n\n    this.storageDir = path.join(rootDir, \"storage\");\n    this.imageDir = path.join(this.storageDir, \"image\");\n    this.fileDir = path.join(this.storageDir, \"file\");\n\n    // Ensure directories exist\n    this.ensureDirectories();\n  }\n\n  private async ensureDirectories() {\n    try {\n      await fs.mkdir(this.storageDir, { recursive: true });\n      await fs.mkdir(this.imageDir, { recursive: true });\n      await fs.mkdir(this.fileDir, { recursive: true });\n    } catch (error) {\n      console.error(\"Error creating storage directories:\", error);\n    }\n  }\n\n  /**\n   * Check if a file is an image based on MIME type\n   */\n  private isImage(mimeType: string): boolean {\n    return mimeType.startsWith(\"image/\");\n  }\n\n  /**\n   * Get file extension from filename\n   */\n  private getFileExtension(filename: string): string {\n    return path.extname(filename).toLowerCase();\n  }\n\n  /**\n   * Sanitize filename to prevent path traversal\n   */\n  private sanitizeFilename(filename: string): string {\n    // Remove path separators and dangerous characters\n    return filename\n      .replace(/[\\/\\\\]/g, \"\")\n      .replace(/\\.\\./g, \"\")\n      .replace(/[<>:\"|?*]/g, \"\")\n      .trim();\n  }\n\n  /**\n   * Validate file extension against allowed list\n   */\n  private validateExtension(extension: string, isImage: boolean): boolean {\n    const allowedExtensions = isImage\n      ? ALLOWED_IMAGE_EXTENSIONS\n      : ALLOWED_FILE_EXTENSIONS;\n\n    return allowedExtensions.includes(extension);\n  }\n\n  /**\n   * Validate MIME type against allowed list\n   */\n  private validateMimeType(mimeType: string, isImage: boolean): boolean {\n    const allowedMimeTypes = isImage\n      ? ALLOWED_IMAGE_MIME_TYPES\n      : ALLOWED_FILE_MIME_TYPES;\n\n    return allowedMimeTypes.includes(mimeType);\n  }\n\n  /**\n   * Validate file size\n   */\n  private validateFileSize(size: number): boolean {\n    return size > 0 && size <= MAX_FILE_SIZE;\n  }\n\n  /**\n   * Upload a file to storage\n   */\n  upload = async (file: {\n    name: string;\n    size: number;\n    type: string;\n    arrayBuffer: () => Promise<ArrayBuffer>;\n  }): Promise<UploadResult> => {\n    try {\n      // 1. Validate file size\n      if (!this.validateFileSize(file.size)) {\n        throw new Error(\n          `File size exceeds maximum allowed size of ${MAX_FILE_SIZE} bytes (${Math.round(MAX_FILE_SIZE / 1024 / 1024)}MB)`,\n        );\n      }\n\n      // 2. Sanitize original filename\n      const sanitizedOriginalName = this.sanitizeFilename(file.name);\n\n      // 3. Determine if it's an image or file\n      const isImageFile = this.isImage(file.type);\n      const targetDir = isImageFile ? this.imageDir : this.fileDir;\n      const fileType: \"image\" | \"file\" = isImageFile ? \"image\" : \"file\";\n\n      // 4. Get and validate file extension\n      const fileExtension = this.getFileExtension(sanitizedOriginalName);\n\n      if (!this.validateExtension(fileExtension, isImageFile)) {\n        throw new Error(\n          `File extension ${fileExtension} is not allowed for ${fileType} uploads`,\n        );\n      }\n\n      // 5. Validate MIME type\n      if (!this.validateMimeType(file.type, isImageFile)) {\n        throw new Error(\n          `MIME type ${file.type} is not allowed for ${fileType} uploads`,\n        );\n      }\n\n      // 6. Generate unique filename (using UUID to prevent collisions and path traversal)\n      const uniqueId = randomUUID();\n      const filename = `${uniqueId}${fileExtension}`;\n\n      // 7. Use path.join and resolve to prevent path traversal\n      const filePath = path.resolve(targetDir, filename);\n\n      // 8. Ensure the resolved path is still within the target directory\n      const resolvedTargetDir = path.resolve(targetDir);\n\n      if (!filePath.startsWith(resolvedTargetDir)) {\n        throw new Error(\"Invalid file path detected\");\n      }\n\n      // 9. Read file buffer\n      const arrayBuffer = await file.arrayBuffer();\n      const buffer = Buffer.from(arrayBuffer);\n\n      // 10. Write file to disk\n      await fs.writeFile(filePath, buffer);\n\n      // 11. Generate URL path (relative to storage)\n      const urlPath = `/api/base/media/${fileType}/${filename}`;\n\n      return {\n        id: uniqueId,\n        filename,\n        originalName: sanitizedOriginalName,\n        path: filePath,\n        url: urlPath,\n        size: file.size,\n        mimeType: file.type,\n        type: fileType,\n      };\n    } catch (error) {\n      console.error(\"Error uploading file:\", error);\n      throw error instanceof Error\n        ? error\n        : new Error(\"Failed to upload file: Unknown error\");\n    }\n  };\n\n  /**\n   * Get file by type and filename\n   */\n  getFile = async (\n    type: \"image\" | \"file\",\n    filename: string,\n  ): Promise<{ buffer: Buffer; mimeType: string; size: number } | null> => {\n    try {\n      // 1. Sanitize filename to prevent path traversal\n      const sanitizedFilename = this.sanitizeFilename(filename);\n\n      if (sanitizedFilename !== filename) {\n        // Filename was modified, reject request\n        return null;\n      }\n\n      // 2. Validate file extension\n      const ext = this.getFileExtension(sanitizedFilename);\n      const isImage = type === \"image\";\n\n      if (!this.validateExtension(ext, isImage)) {\n        return null;\n      }\n\n      // 3. Resolve paths to prevent path traversal\n      const targetDir = type === \"image\" ? this.imageDir : this.fileDir;\n      const resolvedTargetDir = path.resolve(targetDir);\n      const filePath = path.resolve(targetDir, sanitizedFilename);\n\n      // 4. Ensure the resolved path is still within the target directory\n      if (!filePath.startsWith(resolvedTargetDir)) {\n        console.error(\"Path traversal attempt detected:\", filename);\n\n        return null;\n      }\n\n      // 5. Check if file exists\n      try {\n        await fs.access(filePath);\n      } catch {\n        return null;\n      }\n\n      // 6. Read file\n      const buffer = await fs.readFile(filePath);\n      const stats = await fs.stat(filePath);\n\n      // 7. Determine MIME type from file extension (whitelist only)\n      const mimeTypes: Record<string, string> = {\n        \".jpg\": \"image/jpeg\",\n        \".jpeg\": \"image/jpeg\",\n        \".png\": \"image/png\",\n        \".gif\": \"image/gif\",\n        \".webp\": \"image/webp\",\n        \".pdf\": \"application/pdf\",\n        \".doc\": \"application/msword\",\n        \".docx\":\n          \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n        \".xls\": \"application/vnd.ms-excel\",\n        \".xlsx\":\n          \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        \".txt\": \"text/plain\",\n        \".csv\": \"text/csv\",\n      };\n\n      const mimeType = mimeTypes[ext] || \"application/octet-stream\";\n\n      return {\n        buffer,\n        mimeType,\n        size: stats.size,\n      };\n    } catch (error) {\n      console.error(\"Error getting file:\", error);\n\n      return null;\n    }\n  };\n\n  /**\n   * Delete file by type and filename\n   */\n  deleteFile = async (\n    type: \"image\" | \"file\",\n    filename: string,\n  ): Promise<boolean> => {\n    try {\n      const targetDir = type === \"image\" ? this.imageDir : this.fileDir;\n      const filePath = path.join(targetDir, filename);\n\n      // Check if file exists\n      try {\n        await fs.access(filePath);\n      } catch {\n        return false;\n      }\n\n      // Delete file\n      await fs.unlink(filePath);\n\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting file:\", error);\n\n      return false;\n    }\n  };\n}\n\n// Singleton instance\nlet mediaServiceModelInstance: MediaServiceModel | null = null;\n\nexport const getMediaServiceModel = (): MediaServiceModel => {\n  if (!mediaServiceModelInstance) {\n    mediaServiceModelInstance = new MediaServiceModel();\n  }\n\n  return mediaServiceModelInstance;\n};\n\nexport default MediaServiceModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Media/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/PaymentMethod/PaymentMethodDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[148,301],"text":"import { asc, eq, inArray } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":77,"fix":{"range":[378,378],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.payment-method`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[302,449],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_payment_methods } from \"../../schemas/base.payment-method\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":76,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, inArray } from \"drizzle-orm\";\n\nimport { base_tb_payment_methods } from \"../../schemas/base.payment-method\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\ntype PaymentMethodDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass PaymentMethodDropdownListModel extends BaseViewListModel<\n  typeof base_tb_payment_methods,\n  PaymentMethodDropdownOption\n> {\n  constructor() {\n    super({\n      table: base_tb_payment_methods,\n      sortDefault: [\n        {\n          column: \"order\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: base_tb_payment_methods.id, sort: false }],\n      [\"code\", { column: base_tb_payment_methods.code, sort: true }],\n      [\"name\", { column: base_tb_payment_methods.name, sort: false }],\n      [\"order\", { column: base_tb_payment_methods.order, sort: true }],\n    ]);\n\n  protected declarationSearch = () => new Map();\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_payment_methods.isActive, value)\n            : undefined,\n      ],\n      [\n        \"type\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          Array.isArray(value) && value.length > 0\n            ? inArray(base_tb_payment_methods.type, value as string[])\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): PaymentMethodDropdownOption => {\n    // Handle LocaleDataType<string> for name\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PaymentMethodDropdownOption>> => {\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: base_tb_payment_methods.id,\n        code: base_tb_payment_methods.code,\n        name: base_tb_payment_methods.name,\n        order: base_tb_payment_methods.order,\n      },\n      (query) => {\n        return query\n          .orderBy(asc(base_tb_payment_methods.order))\n          .limit(params.limit);\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default PaymentMethodDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/PaymentMethod/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/PaymentTerm/PaymentTermDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[148,301],"text":"import { asc, eq, inArray } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":73,"fix":{"range":[374,374],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.payment-term`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[302,445],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_payment_terms } from \"../../schemas/base.payment-term\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":76,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, inArray } from \"drizzle-orm\";\n\nimport { base_tb_payment_terms } from \"../../schemas/base.payment-term\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\ntype PaymentTermDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass PaymentTermDropdownListModel extends BaseViewListModel<\n  typeof base_tb_payment_terms,\n  PaymentTermDropdownOption\n> {\n  constructor() {\n    super({\n      table: base_tb_payment_terms,\n      sortDefault: [\n        {\n          column: \"order\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: base_tb_payment_terms.id, sort: false }],\n      [\"code\", { column: base_tb_payment_terms.code, sort: true }],\n      [\"name\", { column: base_tb_payment_terms.name, sort: false }],\n      [\"order\", { column: base_tb_payment_terms.order, sort: true }],\n    ]);\n\n  protected declarationSearch = () => new Map();\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_payment_terms.isActive, value)\n            : undefined,\n      ],\n      [\n        \"type\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          Array.isArray(value) && value.length > 0\n            ? inArray(base_tb_payment_terms.type, value as string[])\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): PaymentTermDropdownOption => {\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PaymentTermDropdownOption>> => {\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: base_tb_payment_terms.id,\n        code: base_tb_payment_terms.code,\n        name: base_tb_payment_terms.name,\n        order: base_tb_payment_terms.order,\n      },\n      (query) => {\n        return query\n          .orderBy(asc(base_tb_payment_terms.order))\n          .limit(params.limit);\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default PaymentTermDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/PaymentTerm/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Permission/PermissionModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":34,"fix":{"range":[0,93],"text":"import { eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { base_tb_permissions } from \"../../schemas\";\n\nexport interface PermissionRow {\n  id: string;\n  key: string;\n  module: string;\n  resource: string;\n  action: string;\n  name?: unknown;\n  description?: unknown;\n  isActive?: boolean;\n  createdAt?: Date | null;\n}\n\nexport default class PermissionModel extends BaseModel<\n  typeof base_tb_permissions\n> {\n  constructor() {\n    super(base_tb_permissions);\n  }\n\n  /**\n   * Get all active permissions\n   */\n  async getPermissions(): Promise<PermissionRow[]> {\n    const db = await this.db;\n    const results = await db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.isActive, true))\n      .orderBy(this.table.module, this.table.resource, this.table.action);\n\n    return results.map((row) => this.mapToPermissionRow(row));\n  }\n\n  private mapToPermissionRow(\n    row: typeof base_tb_permissions.$inferSelect,\n  ): PermissionRow {\n    return {\n      id: row.id,\n      key: row.key,\n      module: row.module,\n      resource: row.resource,\n      action: row.action,\n      name: row.name,\n      description: row.description ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt ?? undefined,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Permission/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Role/RoleModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":39,"fix":{"range":[0,162],"text":"import { and, eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'permissions' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":182,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq } from \"drizzle-orm\";\n\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n  base_tb_roles,\n  base_tb_user_roles,\n} from \"../../schemas\";\n\nexport interface RoleRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  permissions?: string[];\n  isSystem?: boolean;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface RoleInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: string | null;\n  permissions: string[];\n  isSystem?: boolean;\n  isActive?: boolean;\n}\n\nexport default class RoleModel extends BaseModel<typeof base_tb_roles> {\n  constructor() {\n    super(base_tb_roles);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  /**\n   * Get all active roles\n   */\n  async getRoles(): Promise<RoleRow[]> {\n    const results = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.isActive, true))\n      .orderBy(this.table.code);\n\n    return Promise.all(results.map((row) => this.mapToRoleRow(row)));\n  }\n\n  /**\n   * Get all roles (including inactive)\n   */\n  async getAllRoles(): Promise<RoleRow[]> {\n    const results = await this.db\n      .select()\n      .from(this.table)\n      .orderBy(this.table.createdAt);\n\n    return Promise.all(results.map((row) => this.mapToRoleRow(row)));\n  }\n\n  getRoleById = async (id: string): Promise<RoleRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return this.mapToRoleRow(row);\n  };\n\n  /**\n   * Get role by code\n   */\n  async getRoleByCode(code: string): Promise<RoleRow | null> {\n    const [result] = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.code, code))\n      .limit(1);\n\n    if (!result) {\n      return null;\n    }\n\n    return this.mapToRoleRow(result);\n  }\n\n  /**\n   * Get role by ID with permissions details\n   */\n  async getRoleWithPermissions(id: string): Promise<{\n    role: RoleRow;\n    permissions: Array<{\n      id: string;\n      key: string;\n      module: string;\n      resource: string;\n      action: string;\n      name?: unknown;\n      description?: unknown;\n    }>;\n  } | null> {\n    const role = await this.getRoleById(id);\n\n    if (!role) {\n      return null;\n    }\n\n    const rolePermissions = await this.db\n      .select({\n        id: base_tb_permissions.id,\n        key: base_tb_permissions.key,\n        module: base_tb_permissions.module,\n        resource: base_tb_permissions.resource,\n        action: base_tb_permissions.action,\n        name: base_tb_permissions.name,\n        description: base_tb_permissions.description,\n      })\n      .from(base_tb_role_permissions_default)\n      .innerJoin(\n        base_tb_permissions,\n        eq(\n          base_tb_role_permissions_default.permissionId,\n          base_tb_permissions.id,\n        ),\n      )\n      .where(eq(base_tb_role_permissions_default.roleId, id));\n\n    return {\n      role,\n      permissions: rolePermissions,\n    };\n  }\n\n  getDataById = async (params: { id: string }): Promise<RoleRow | null> => {\n    return this.getRoleById(params.id);\n  };\n\n  createRole = async (payload: RoleInput): Promise<RoleRow> => {\n    const now = new Date();\n    const insertData = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description ?? null,\n      isSystem: payload.isSystem ?? false,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create role\");\n    }\n\n    // Add permissions to role_permissions_default if provided\n    if (payload.permissions && payload.permissions.length > 0) {\n      // Get permission IDs from keys\n      const permissions = await this.db\n        .select({ id: base_tb_permissions.id })\n        .from(base_tb_permissions)\n        .where(\n          and(\n            eq(base_tb_permissions.isActive, true),\n            // Note: We'd need to filter by keys, but for now we'll handle this differently\n          ),\n        );\n\n      // For now, we'll need to match permission keys to IDs\n      // This is a simplified version - you may want to improve this\n      for (const permKey of payload.permissions) {\n        const perm = await this.db\n          .select({ id: base_tb_permissions.id })\n          .from(base_tb_permissions)\n          .where(eq(base_tb_permissions.key, permKey))\n          .limit(1);\n\n        if (perm[0]) {\n          await this.db.insert(base_tb_role_permissions_default).values({\n            roleId: created.id,\n            permissionId: perm[0].id,\n            isActive: true,\n            createdAt: now,\n          });\n        }\n      }\n    }\n\n    const role = await this.getRoleById(created.id);\n\n    if (!role) {\n      throw new Error(\"Failed to load role after creation\");\n    }\n\n    return role;\n  };\n\n  updateRole = async (\n    id: string,\n    payload: Partial<RoleInput>,\n  ): Promise<RoleRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    // Update permissions if provided\n    if (payload.permissions !== undefined) {\n      // Get permission IDs from keys\n      const permissionIds: string[] = [];\n\n      for (const permKey of payload.permissions) {\n        const perm = await this.db\n          .select({ id: base_tb_permissions.id })\n          .from(base_tb_permissions)\n          .where(eq(base_tb_permissions.key, permKey))\n          .limit(1);\n\n        if (perm[0]) {\n          permissionIds.push(perm[0].id);\n        }\n      }\n\n      // Remove all current permissions\n      await this.db\n        .update(base_tb_role_permissions_default)\n        .set({ isActive: false })\n        .where(eq(base_tb_role_permissions_default.roleId, id));\n\n      // Add new permissions\n      const now = new Date();\n\n      for (const permissionId of permissionIds) {\n        // Check if exists\n        const existing = await this.db\n          .select()\n          .from(base_tb_role_permissions_default)\n          .where(\n            and(\n              eq(base_tb_role_permissions_default.roleId, id),\n              eq(base_tb_role_permissions_default.permissionId, permissionId),\n            ),\n          )\n          .limit(1);\n\n        if (existing[0]) {\n          // Reactivate if inactive\n          await this.db\n            .update(base_tb_role_permissions_default)\n            .set({ isActive: true })\n            .where(eq(base_tb_role_permissions_default.id, existing[0].id));\n        } else {\n          // Insert new\n          await this.db.insert(base_tb_role_permissions_default).values({\n            roleId: id,\n            permissionId,\n            isActive: true,\n            createdAt: now,\n          });\n        }\n      }\n    }\n\n    return this.getRoleById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<RoleInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description =\n        payload.description !== null && payload.description !== undefined\n          ? String(payload.description)\n          : null;\n    }\n    if (payload.permissions !== undefined) {\n      normalizedPayload.permissions = Array.isArray(payload.permissions)\n        ? payload.permissions\n        : [];\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateRole(id, normalizedPayload);\n  };\n\n  /**\n   * Delete role\n   */\n  async deleteRole(id: string): Promise<{ success: boolean; message: string }> {\n    const db = await this.db;\n\n    // Check if role exists\n    const [role] = await db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    if (!role) {\n      return {\n        success: false,\n        message: \"Role not found\",\n      };\n    }\n\n    // Check if role is system role (cannot be deleted)\n    if (role.isSystem) {\n      return {\n        success: false,\n        message: \"System roles cannot be deleted\",\n      };\n    }\n\n    // Check if role is assigned to any users\n    const userRoles = await db\n      .select()\n      .from(base_tb_user_roles)\n      .where(eq(base_tb_user_roles.roleId, id))\n      .limit(1);\n\n    // Delete role (cascade will handle related records)\n    await db.delete(this.table).where(eq(this.table.id, id));\n\n    return {\n      success: true,\n      message:\n        userRoles.length > 0\n          ? \"Role deleted. Users with this role have been unassigned.\"\n          : \"Role deleted successfully\",\n    };\n  }\n\n  private async mapToRoleRow(\n    row: typeof base_tb_roles.$inferSelect,\n  ): Promise<RoleRow> {\n    // Get permissions for this role\n    const db = await this.db;\n    const permissions = await db\n      .select({\n        permissionKey: base_tb_permissions.key,\n      })\n      .from(base_tb_role_permissions_default)\n      .innerJoin(\n        base_tb_permissions,\n        eq(\n          base_tb_role_permissions_default.permissionId,\n          base_tb_permissions.id,\n        ),\n      )\n      .where(\n        and(\n          eq(base_tb_role_permissions_default.roleId, row.id),\n          eq(base_tb_role_permissions_default.isActive, true),\n          eq(base_tb_permissions.isActive, true),\n        ),\n      );\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description ?? undefined,\n      permissions: permissions.map((p) => p.permissionKey),\n      isSystem: row.isSystem ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Role/RoleViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":48,"fix":{"range":[298,298],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":46,"fix":{"range":[149,345],"text":"import { eq, ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type ColumnMap,\n  type FilterConditionMap,\n  type SearchConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":57,"fix":{"range":[402,402],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.role`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":70,"fix":{"range":[346,473],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_roles } from \"../../schemas/base.role\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { RoleRow } from \"./RoleModel\";\n\nimport {\n  BaseViewListModel,\n  type ColumnMap,\n  type FilterConditionMap,\n  type SearchConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike, sql } from \"drizzle-orm\";\n\nimport { base_tb_roles } from \"../../schemas/base.role\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nclass RoleViewListModel extends BaseViewListModel<\n  typeof base_tb_roles,\n  RoleRow\n> {\n  constructor() {\n    super({\n      table: base_tb_roles,\n      sortDefault: [\n        { column: \"isSystem\", direction: \"descending\" },\n        { column: \"createdAt\", direction: \"descending\" },\n      ],\n    });\n  }\n\n  protected declarationColumns = (): ColumnMap =>\n    new Map([\n      [\"id\", { column: base_tb_roles.id, sort: false }],\n      [\"code\", { column: base_tb_roles.code, sort: true }],\n      [\"name\", { column: base_tb_roles.name, sort: false }],\n      [\"description\", { column: base_tb_roles.description, sort: false }],\n      [\"isSystem\", { column: base_tb_roles.isSystem, sort: true }],\n      [\"isActive\", { column: base_tb_roles.isActive, sort: true }],\n      [\"createdAt\", { column: base_tb_roles.createdAt, sort: true }],\n      [\"updatedAt\", { column: base_tb_roles.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = (): SearchConditionMap =>\n    new Map([\n      [\n        \"code\",\n        (text: string) =>\n          text ? ilike(base_tb_roles.code, `%${text}%`) : undefined,\n      ],\n      [\n        \"name\",\n        (text: string) =>\n          text\n            ? sql`LOWER(${base_tb_roles.name}::text) LIKE ${`%${text.toLowerCase()}%`}`\n            : undefined,\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_roles.isActive, value)\n            : undefined,\n      ],\n      [\n        \"isSystem\",\n        (value?: unknown) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_roles.isSystem, value)\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (row: any): RoleRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    description: row.description ?? undefined,\n    permissions: [],\n    isSystem: row.isSystem ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<RoleRow>> => this.buildQueryDataList(params);\n}\n\nexport default RoleViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Role/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/RolePermission/RolePermissionModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":48,"fix":{"range":[0,107],"text":"import { and, eq, inArray } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, inArray } from \"drizzle-orm\";\n\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n} from \"../../schemas\";\n\nexport interface RolePermissionRow {\n  id: string;\n  roleId: string;\n  permissionId: string;\n  permissionKey: string;\n  isActive: boolean;\n  createdAt?: number;\n  createdBy?: string;\n}\n\nexport default class RolePermissionModel extends BaseModel<\n  typeof base_tb_role_permissions_default\n> {\n  constructor() {\n    super(base_tb_role_permissions_default);\n  }\n\n  /**\n   * Get all permissions for a role\n   */\n  async getPermissionsByRole(roleId: string): Promise<string[]> {\n    const results = await this.db\n      .select({\n        permissionKey: base_tb_permissions.key,\n      })\n      .from(this.table)\n      .innerJoin(\n        base_tb_permissions,\n        eq(this.table.permissionId, base_tb_permissions.id),\n      )\n      .where(\n        and(\n          eq(this.table.roleId, roleId),\n          eq(this.table.isActive, true),\n          eq(base_tb_permissions.isActive, true),\n        ),\n      );\n\n    return results.map((r) => r.permissionKey);\n  }\n\n  /**\n   * Get permissions for multiple roles\n   */\n  async getPermissionsByRoles(\n    roleIds: string[],\n  ): Promise<Map<string, string[]>> {\n    if (roleIds.length === 0) {\n      return new Map();\n    }\n\n    const results = await this.db\n      .select({\n        roleId: this.table.roleId,\n        permissionKey: base_tb_permissions.key,\n      })\n      .from(this.table)\n      .innerJoin(\n        base_tb_permissions,\n        eq(this.table.permissionId, base_tb_permissions.id),\n      )\n      .where(\n        and(\n          inArray(this.table.roleId, roleIds),\n          eq(this.table.isActive, true),\n          eq(base_tb_permissions.isActive, true),\n        ),\n      );\n\n    const permissionsMap = new Map<string, string[]>();\n\n    for (const roleId of roleIds) {\n      permissionsMap.set(roleId, []);\n    }\n\n    for (const result of results) {\n      const existing = permissionsMap.get(result.roleId) || [];\n\n      existing.push(result.permissionKey);\n      permissionsMap.set(result.roleId, existing);\n    }\n\n    return permissionsMap;\n  }\n\n  /**\n   * Add permission to role\n   */\n  async addPermissionToRole(\n    roleId: string,\n    permissionId: string,\n    createdBy?: string,\n  ): Promise<RolePermissionRow> {\n    const now = new Date();\n\n    // Get permission key for return value\n    const permission = await this.db\n      .select({ key: base_tb_permissions.key })\n      .from(base_tb_permissions)\n      .where(eq(base_tb_permissions.id, permissionId))\n      .limit(1);\n\n    if (!permission[0]) {\n      throw new Error(\"Permission not found\");\n    }\n\n    // Check if already exists\n    const existing = await this.db\n      .select()\n      .from(this.table)\n      .where(\n        and(\n          eq(this.table.roleId, roleId),\n          eq(this.table.permissionId, permissionId),\n        ),\n      )\n      .limit(1);\n\n    if (existing[0]) {\n      // Reactivate if inactive\n      if (!existing[0].isActive) {\n        await this.db\n          .update(this.table)\n          .set({\n            isActive: true,\n          })\n          .where(eq(this.table.id, existing[0].id));\n      }\n\n      return {\n        id: existing[0].id,\n        roleId: existing[0].roleId,\n        permissionId: existing[0].permissionId,\n        permissionKey: permission[0].key,\n        isActive: true,\n        createdAt: existing[0].createdAt?.getTime(),\n        createdBy: existing[0].createdBy ?? undefined,\n      };\n    }\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values({\n        roleId,\n        permissionId,\n        isActive: true,\n        createdAt: now,\n        createdBy: createdBy ?? null,\n      })\n      .returning();\n\n    if (!created) {\n      throw new Error(\"Failed to add permission to role\");\n    }\n\n    return {\n      id: created.id,\n      roleId: created.roleId,\n      permissionId: created.permissionId,\n      permissionKey: permission[0].key,\n      isActive: created.isActive,\n      createdAt: created.createdAt?.getTime(),\n      createdBy: created.createdBy ?? undefined,\n    };\n  }\n\n  /**\n   * Remove permission from role (soft delete)\n   */\n  async removePermissionFromRole(\n    roleId: string,\n    permissionId: string,\n  ): Promise<boolean> {\n    const result = await this.db\n      .update(this.table)\n      .set({\n        isActive: false,\n      })\n      .where(\n        and(\n          eq(this.table.roleId, roleId),\n          eq(this.table.permissionId, permissionId),\n          eq(this.table.isActive, true),\n        ),\n      )\n      .returning();\n\n    return result.length > 0;\n  }\n\n  /**\n   * Set permissions for role (replace all)\n   */\n  async setPermissionsForRole(\n    roleId: string,\n    permissionIds: string[],\n    createdBy?: string,\n  ): Promise<void> {\n    // Get current permissions\n    const current = await this.db\n      .select({\n        permissionId: this.table.permissionId,\n      })\n      .from(this.table)\n      .where(and(eq(this.table.roleId, roleId), eq(this.table.isActive, true)));\n\n    const currentSet = new Set(current.map((c) => c.permissionId));\n    const newSet = new Set(permissionIds);\n\n    // Deactivate permissions not in new list\n    for (const perm of current) {\n      if (!newSet.has(perm.permissionId)) {\n        await this.removePermissionFromRole(roleId, perm.permissionId);\n      }\n    }\n\n    // Add new permissions\n    for (const permissionId of permissionIds) {\n      if (!currentSet.has(permissionId)) {\n        await this.addPermissionToRole(roleId, permissionId, createdBy);\n      }\n    }\n  }\n\n  /**\n   * Standard CRUD method\n   */\n  getDataById = async (params: { id: string }) => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, params.id))\n      .limit(1);\n\n    return result[0] || null;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/RolePermission/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Sessions/SessionInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Sessions/SessionModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Sessions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/ShippingMethod/ShippingMethodDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[148,301],"text":"import { asc, eq, inArray } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":79,"fix":{"range":[380,380],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.shipping-method`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[302,451],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_shipping_methods } from \"../../schemas/base.shipping-method\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":76,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, inArray } from \"drizzle-orm\";\n\nimport { base_tb_shipping_methods } from \"../../schemas/base.shipping-method\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\ntype ShippingMethodDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass ShippingMethodDropdownListModel extends BaseViewListModel<\n  typeof base_tb_shipping_methods,\n  ShippingMethodDropdownOption\n> {\n  constructor() {\n    super({\n      table: base_tb_shipping_methods,\n      sortDefault: [\n        {\n          column: \"order\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: base_tb_shipping_methods.id, sort: false }],\n      [\"code\", { column: base_tb_shipping_methods.code, sort: true }],\n      [\"name\", { column: base_tb_shipping_methods.name, sort: false }],\n      [\"order\", { column: base_tb_shipping_methods.order, sort: true }],\n    ]);\n\n  protected declarationSearch = () => new Map();\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_shipping_methods.isActive, value)\n            : undefined,\n      ],\n      [\n        \"type\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          Array.isArray(value) && value.length > 0\n            ? inArray(base_tb_shipping_methods.type, value as string[])\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): ShippingMethodDropdownOption => {\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<ShippingMethodDropdownOption>> => {\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: base_tb_shipping_methods.id,\n        code: base_tb_shipping_methods.code,\n        name: base_tb_shipping_methods.name,\n        order: base_tb_shipping_methods.order,\n      },\n      (query) => {\n        return query\n          .orderBy(asc(base_tb_shipping_methods.order))\n          .limit(params.limit);\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default ShippingMethodDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/ShippingMethod/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/ShippingTerm/ShippingTermDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[148,301],"text":"import { asc, eq, inArray } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":75,"fix":{"range":[376,376],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.shipping-term`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[302,447],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_shipping_terms } from \"../../schemas/base.shipping-term\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":76,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, inArray } from \"drizzle-orm\";\n\nimport { base_tb_shipping_terms } from \"../../schemas/base.shipping-term\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\ntype ShippingTermDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass ShippingTermDropdownListModel extends BaseViewListModel<\n  typeof base_tb_shipping_terms,\n  ShippingTermDropdownOption\n> {\n  constructor() {\n    super({\n      table: base_tb_shipping_terms,\n      sortDefault: [\n        {\n          column: \"order\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: base_tb_shipping_terms.id, sort: false }],\n      [\"code\", { column: base_tb_shipping_terms.code, sort: true }],\n      [\"name\", { column: base_tb_shipping_terms.name, sort: false }],\n      [\"order\", { column: base_tb_shipping_terms.order, sort: true }],\n    ]);\n\n  protected declarationSearch = () => new Map();\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_shipping_terms.isActive, value)\n            : undefined,\n      ],\n      [\n        \"type\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          Array.isArray(value) && value.length > 0\n            ? inArray(base_tb_shipping_terms.type, value as string[])\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): ShippingTermDropdownOption => {\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<ShippingTermDropdownOption>> => {\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: base_tb_shipping_terms.id,\n        code: base_tb_shipping_terms.code,\n        name: base_tb_shipping_terms.name,\n        order: base_tb_shipping_terms.order,\n      },\n      (query) => {\n        return query\n          .orderBy(asc(base_tb_shipping_terms.order))\n          .limit(params.limit);\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default ShippingTermDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/ShippingTerm/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/TaxRate/TaxRateDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[148,301],"text":"import { asc, eq, inArray } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":65,"fix":{"range":[366,366],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/shared/interface/FilterInterface` import should occur before import of `../../schemas/base.tax-rate`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[302,437],"text":"import { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport { base_tb_tax_rates } from \"../../schemas/base.tax-rate\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":76,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, inArray } from \"drizzle-orm\";\n\nimport { base_tb_tax_rates } from \"../../schemas/base.tax-rate\";\nimport { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\ntype TaxRateDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass TaxRateDropdownListModel extends BaseViewListModel<\n  typeof base_tb_tax_rates,\n  TaxRateDropdownOption\n> {\n  constructor() {\n    super({\n      table: base_tb_tax_rates,\n      sortDefault: [\n        {\n          column: \"order\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: base_tb_tax_rates.id, sort: false }],\n      [\"code\", { column: base_tb_tax_rates.code, sort: true }],\n      [\"name\", { column: base_tb_tax_rates.name, sort: false }],\n      [\"order\", { column: base_tb_tax_rates.order, sort: true }],\n    ]);\n\n  protected declarationSearch = () => new Map();\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map([\n      [\n        \"isActive\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          typeof value === \"boolean\"\n            ? eq(base_tb_tax_rates.isActive, value)\n            : undefined,\n      ],\n      [\n        \"type\",\n        (value?: unknown, _filters?: ParamFilter) =>\n          Array.isArray(value) && value.length > 0\n            ? inArray(base_tb_tax_rates.type, value as string[])\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): TaxRateDropdownOption => {\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<TaxRateDropdownOption>> => {\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: base_tb_tax_rates.id,\n        code: base_tb_tax_rates.code,\n        name: base_tb_tax_rates.name,\n        order: base_tb_tax_rates.order,\n      },\n      (query) => {\n        return query.orderBy(asc(base_tb_tax_rates.order)).limit(params.limit);\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default TaxRateDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/TaxRate/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/UserPermission/UserPermissionModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":48,"fix":{"range":[0,107],"text":"import { and, eq, inArray } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, inArray } from \"drizzle-orm\";\n\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n  base_tb_roles,\n  base_tb_user_permissions,\n  base_tb_user_roles,\n} from \"../../schemas\";\n\nexport interface UserPermissionResult {\n  permissions: Set<string>;\n  roles: Array<{\n    id: string;\n    code: string;\n    name: unknown;\n  }>;\n}\n\nexport default class UserPermissionModel extends BaseModel<\n  typeof base_tb_user_permissions\n> {\n  constructor() {\n    super(base_tb_user_permissions);\n  }\n\n  /**\n   * Standard CRUD method - Get by ID\n   */\n  getDataById = async (params: { id: string }) => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, params.id))\n      .limit(1);\n\n    return result[0] || null;\n  };\n\n  /**\n   * Get user's final permissions (role permissions + overrides)\n   * Logic:\n   * 1. Get all permissions from user's roles\n   * 2. Apply granted permissions from overrides\n   * 3. Remove revoked permissions from overrides\n   */\n  async getPermissionsByUser(userId: string): Promise<UserPermissionResult> {\n    // 1. Get user's roles\n    const userRoles = await this.db\n      .select({\n        role: {\n          id: base_tb_roles.id,\n          code: base_tb_roles.code,\n          name: base_tb_roles.name,\n        },\n      })\n      .from(base_tb_user_roles)\n      .innerJoin(base_tb_roles, eq(base_tb_user_roles.roleId, base_tb_roles.id))\n      .where(\n        and(\n          eq(base_tb_user_roles.userId, userId),\n          eq(base_tb_user_roles.isActive, true),\n          eq(base_tb_roles.isActive, true),\n        ),\n      );\n\n    const roles = userRoles.map((r) => ({\n      id: r.role.id,\n      code: r.role.code,\n      name: r.role.name,\n    }));\n\n    // 2. Get permissions from role_permissions_default table for all user's roles\n    const rolePermissions = new Set<string>();\n    const roleIds = roles.map((r) => r.id);\n\n    if (roleIds.length > 0) {\n      const rolePerms = await this.db\n        .select({\n          permissionKey: base_tb_permissions.key,\n        })\n        .from(base_tb_role_permissions_default)\n        .innerJoin(\n          base_tb_permissions,\n          eq(\n            base_tb_role_permissions_default.permissionId,\n            base_tb_permissions.id,\n          ),\n        )\n        .where(\n          and(\n            inArray(base_tb_role_permissions_default.roleId, roleIds),\n            eq(base_tb_role_permissions_default.isActive, true),\n            eq(base_tb_permissions.isActive, true),\n          ),\n        );\n\n      for (const rp of rolePerms) {\n        rolePermissions.add(rp.permissionKey);\n      }\n    }\n\n    // 3. Get additional user permissions (from user_permissions table)\n    const userPerms = await this.db\n      .select({\n        permissionKey: base_tb_permissions.key,\n      })\n      .from(base_tb_user_permissions)\n      .innerJoin(\n        base_tb_permissions,\n        eq(base_tb_user_permissions.permissionId, base_tb_permissions.id),\n      )\n      .where(\n        and(\n          eq(base_tb_user_permissions.userId, userId),\n          eq(base_tb_user_permissions.isActive, true),\n          eq(base_tb_permissions.isActive, true),\n        ),\n      );\n\n    // 4. Combine role permissions and user permissions\n    const finalPermissions = new Set(rolePermissions);\n\n    for (const up of userPerms) {\n      finalPermissions.add(up.permissionKey);\n    }\n\n    return {\n      permissions: finalPermissions,\n      roles,\n    };\n  }\n\n  /**\n   * Get user's permissions as array (for API responses)\n   */\n  async getPermissionsByUserArray(userId: string): Promise<string[]> {\n    const result = await this.getPermissionsByUser(userId);\n\n    return Array.from(result.permissions).sort();\n  }\n\n  /**\n   * Check if user has specific permission\n   */\n  async hasPermission(userId: string, permission: string): Promise<boolean> {\n    const result = await this.getPermissionsByUser(userId);\n\n    return result.permissions.has(permission);\n  }\n\n  /**\n   * Check if user has any of the specified permissions\n   */\n  async hasAnyPermission(\n    userId: string,\n    permissions: string[],\n  ): Promise<boolean> {\n    const result = await this.getPermissionsByUser(userId);\n\n    return permissions.some((perm) => result.permissions.has(perm));\n  }\n\n  /**\n   * Check if user has all of the specified permissions\n   */\n  async hasAllPermissions(\n    userId: string,\n    permissions: string[],\n  ): Promise<boolean> {\n    const result = await this.getPermissionsByUser(userId);\n\n    return permissions.every((perm) => result.permissions.has(perm));\n  }\n\n  /**\n   * Add permission to user\n   */\n  async addPermissionToUser(\n    userId: string,\n    permissionId: string,\n    createdBy?: string,\n  ) {\n    const now = new Date();\n\n    // Check if already exists\n    const existing = await this.db\n      .select()\n      .from(this.table)\n      .where(\n        and(\n          eq(this.table.userId, userId),\n          eq(this.table.permissionId, permissionId),\n        ),\n      )\n      .limit(1);\n\n    if (existing[0]) {\n      // Reactivate if inactive\n      if (!existing[0].isActive) {\n        await this.db\n          .update(this.table)\n          .set({\n            isActive: true,\n          })\n          .where(eq(this.table.id, existing[0].id));\n      }\n\n      return existing[0];\n    }\n\n    // Create new user permission\n    const [created] = await this.db\n      .insert(this.table)\n      .values({\n        userId,\n        permissionId,\n        isActive: true,\n        createdAt: now,\n        createdBy: createdBy ?? null,\n      })\n      .returning();\n\n    return created;\n  }\n\n  /**\n   * Remove permission from user (soft delete)\n   */\n  async removePermissionFromUser(userId: string, permissionId: string) {\n    const result = await this.db\n      .update(this.table)\n      .set({\n        isActive: false,\n      })\n      .where(\n        and(\n          eq(this.table.userId, userId),\n          eq(this.table.permissionId, permissionId),\n          eq(this.table.isActive, true),\n        ),\n      )\n      .returning();\n\n    return result.length > 0;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/UserPermission/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/UserRole/UserRoleModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":48,"fix":{"range":[0,107],"text":"import { and, eq, inArray } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, inArray } from \"drizzle-orm\";\n\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n  base_tb_user_roles,\n  base_tb_roles,\n} from \"../../schemas\";\n\nexport interface UserRoleRow {\n  id: string;\n  userId: string;\n  roleId: string;\n  isActive: boolean;\n  createdAt?: number;\n  createdBy?: string;\n}\n\nexport default class UserRoleModel extends BaseModel<\n  typeof base_tb_user_roles\n> {\n  constructor() {\n    super(base_tb_user_roles);\n  }\n\n  /**\n   * Get user's permissions (aggregate từ tất cả roles)\n   */\n  async getUserPermissions(userId: string): Promise<Set<string>> {\n    // Get user's roles\n    const userRoles = await this.db\n      .select({\n        roleId: base_tb_roles.id,\n      })\n      .from(this.table)\n      .innerJoin(base_tb_roles, eq(this.table.roleId, base_tb_roles.id))\n      .where(\n        and(\n          eq(this.table.userId, userId),\n          eq(this.table.isActive, true),\n          eq(base_tb_roles.isActive, true),\n        ),\n      );\n\n    const roleIds = userRoles.map((r) => r.roleId);\n    const permissionsSet = new Set<string>();\n\n    if (roleIds.length > 0) {\n      // Get permissions from role_permissions_default\n      const rolePerms = await this.db\n        .select({\n          permissionKey: base_tb_permissions.key,\n        })\n        .from(base_tb_role_permissions_default)\n        .innerJoin(\n          base_tb_permissions,\n          eq(\n            base_tb_role_permissions_default.permissionId,\n            base_tb_permissions.id,\n          ),\n        )\n        .where(\n          and(\n            inArray(base_tb_role_permissions_default.roleId, roleIds),\n            eq(base_tb_role_permissions_default.isActive, true),\n            eq(base_tb_permissions.isActive, true),\n          ),\n        );\n\n      for (const rp of rolePerms) {\n        permissionsSet.add(rp.permissionKey);\n      }\n    }\n\n    return permissionsSet;\n  }\n\n  /**\n   * Get user's roles\n   */\n  async getUserRoles(userId: string): Promise<UserRoleRow[]> {\n    const conditions = [\n      eq(this.table.userId, userId),\n      eq(this.table.isActive, true),\n    ];\n\n    const results = await this.db\n      .select({\n        userRole: this.table,\n        role: base_tb_roles,\n      })\n      .from(this.table)\n      .innerJoin(base_tb_roles, eq(this.table.roleId, base_tb_roles.id))\n      .where(and(...conditions));\n\n    return results.map((r) => ({\n      id: r.userRole.id,\n      userId: r.userRole.userId,\n      roleId: r.userRole.roleId,\n      isActive: r.userRole.isActive,\n      createdAt: r.userRole.createdAt?.getTime(),\n      createdBy: r.userRole.createdBy ?? undefined,\n    }));\n  }\n\n  /**\n   * Assign role to user\n   */\n  async assignRole(\n    userId: string,\n    roleId: string,\n    createdBy?: string,\n  ): Promise<UserRoleRow> {\n    const now = new Date();\n\n    // Check if already assigned\n    const existing = await this.db\n      .select()\n      .from(this.table)\n      .where(and(eq(this.table.userId, userId), eq(this.table.roleId, roleId)))\n      .limit(1);\n\n    if (existing[0]) {\n      // Reactivate if inactive\n      await this.db\n        .update(this.table)\n        .set({\n          isActive: true,\n          createdBy: createdBy ?? null,\n        })\n        .where(eq(this.table.id, existing[0].id));\n\n      return {\n        id: existing[0].id,\n        userId: existing[0].userId,\n        roleId: existing[0].roleId,\n        isActive: true,\n        createdAt: now.getTime(),\n        createdBy: createdBy ?? undefined,\n      };\n    }\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values({\n        userId,\n        roleId,\n        isActive: true,\n        createdAt: now,\n        createdBy: createdBy ?? null,\n      })\n      .returning();\n\n    if (!created) {\n      throw new Error(\"Failed to assign role\");\n    }\n\n    return {\n      id: created.id,\n      userId: created.userId,\n      roleId: created.roleId,\n      isActive: created.isActive,\n      createdAt: created.createdAt?.getTime(),\n      createdBy: created.createdBy ?? undefined,\n    };\n  }\n\n  /**\n   * Revoke role from user (soft delete)\n   */\n  async revokeRole(userId: string, roleId: string): Promise<boolean> {\n    const result = await this.db\n      .update(this.table)\n      .set({\n        isActive: false,\n      })\n      .where(\n        and(\n          eq(this.table.userId, userId),\n          eq(this.table.roleId, roleId),\n          eq(this.table.isActive, true),\n        ),\n      )\n      .returning();\n\n    return result.length > 0;\n  }\n\n  /**\n   * Check if user has specific permission\n   */\n  async hasPermission(userId: string, permission: string): Promise<boolean> {\n    const permissions = await this.getUserPermissions(userId);\n\n    return permissions.has(permission);\n  }\n\n  /**\n   * Check if user has any of the specified permissions\n   */\n  async hasAnyPermission(\n    userId: string,\n    permissions: string[],\n  ): Promise<boolean> {\n    const userPermissions = await this.getUserPermissions(userId);\n\n    return permissions.some((perm) => userPermissions.has(perm));\n  }\n\n  /**\n   * Check if user has all of the specified permissions\n   */\n  async hasAllPermissions(\n    userId: string,\n    permissions: string[],\n  ): Promise<boolean> {\n    const userPermissions = await this.getUserPermissions(userId);\n\n    return permissions.every((perm) => userPermissions.has(perm));\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/UserRole/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Users/UserInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/models/Users/UserModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/rpc/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/rpc/jsonRpcHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":88,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":234,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":234,"endColumn":20,"suggestions":[{"fix":{"range":[5686,5735],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\";\n\nimport { RuntimeContext } from \"../runtime/RuntimeContext\";\nimport {\n  sanitizeJsonRpcParams,\n  validateJsonRpcMethod,\n} from \"../validation/schemas/jsonrpc\";\n\nexport interface JsonRpcRequest {\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: any;\n  id?: string | number | null;\n}\n\nexport interface JsonRpcResponse {\n  jsonrpc: \"2.0\";\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n  id?: string | number | null;\n}\n\nexport interface JsonRpcMethod {\n  (params: any, request: NextRequest): Promise<any>;\n}\n\nexport class JsonRpcError extends Error {\n  constructor(\n    public code: number,\n    message: string,\n    public data?: any,\n  ) {\n    super(message);\n    this.name = \"JsonRpcError\";\n  }\n}\n\nexport const JSON_RPC_ERROR_CODES = {\n  PARSE_ERROR: -32700,\n  INVALID_REQUEST: -32600,\n  METHOD_NOT_FOUND: -32601,\n  INVALID_PARAMS: -32602,\n  INTERNAL_ERROR: -32603,\n  AUTHENTICATION_ERROR: -32001,\n  AUTHORIZATION_ERROR: -32002,\n  VALIDATION_ERROR: -32003,\n  NOT_FOUND: -32004,\n  MODEL_ERROR: -32005,\n  MODEL_NOT_FOUND: -32006,\n} as const;\n\n// Constants for method structure\nconst SUB_TYPE_LIST = \"list\";\nconst SUB_TYPE_DROPDOWN = \"dropdown\";\nconst SUB_TYPE_CRUD = \"curd\";\n\n/**\n * Method structure: <model-id>.<sub-type>.<method>\n *\n * Examples:\n * - product.list.getData\n * - product.dropdown.getData\n * - product.curd.create\n * - product.curd.update\n * - product-category.list.getData\n * - product-category.curd.getById\n *\n * Where:\n * - <model-id>: Base model name from module.json (e.g., \"product\", \"product.category\")\n * - <sub-type>: \"list\", \"dropdown\", or \"curd\"\n * - <method>: Method name on the model instance (e.g., \"getData\", \"create\", \"update\")\n */\n\nexport class JsonRpcHandler {\n  private readonly rpcVersion: string = \"2.0\";\n  constructor() {}\n  /**\n   * Handle dynamic model query using module.json definitions\n   * Format: <model-id>.<sub-type>.<method>\n   */\n  private async handleDynamicModelQuery(\n    method: string,\n    params: any,\n    request: NextRequest,\n  ): Promise<any> {\n    // Parse method: <model-id>.<sub-type>.<method>\n    const parts = method.split(\".\");\n\n    if (parts.length < 3) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        `Invalid model method format. Expected: <model-id>.<sub-type>.<method>\\n` +\n          `Example: product-category.list.getData, product.curd.create`,\n      );\n    }\n\n    const [modelId, subType, methodName] = parts;\n\n    // Validate sub-type\n    if (\n      subType !== SUB_TYPE_LIST &&\n      subType !== SUB_TYPE_DROPDOWN &&\n      subType !== SUB_TYPE_CRUD\n    ) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        `Invalid model type. Expected: ${SUB_TYPE_LIST}, ${SUB_TYPE_DROPDOWN}, ${SUB_TYPE_CRUD}`,\n      );\n    }\n\n    // Build model key\n    const modelKey = `${modelId}.${subType}`;\n\n    // Get model instance\n    const modelInstance = await RuntimeContext.getModelInstanceBy(modelKey);\n\n    if (!modelInstance) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.MODEL_NOT_FOUND,\n        `Model \"${modelKey}\" not found`,\n      );\n    }\n\n    // Get method function\n    const modelMethodFunction = (modelInstance as any)[methodName] as (\n      params?: Record<string, any>,\n    ) => Promise<any>;\n\n    if (!modelMethodFunction || typeof modelMethodFunction !== \"function\") {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n        `Method \"${methodName}\" not found on model \"${modelKey}\"`,\n      );\n    }\n\n    // Call model method\n    return await modelMethodFunction(params || {});\n  }\n\n  /**\n   * Create error response\n   */\n  private createErrorResponse(\n    code: number,\n    message: string,\n    data?: any,\n    id?: string | number | null,\n  ): JsonRpcResponse {\n    return {\n      jsonrpc: \"2.0\" as const,\n      error: {\n        code,\n        message,\n        data,\n      },\n      id: id ?? null,\n    };\n  }\n\n  /**\n   * Create success response\n   */\n  private createSuccessResponse(\n    result: any,\n    id?: string | number | null,\n  ): JsonRpcResponse {\n    return {\n      jsonrpc: \"2.0\" as const,\n      result,\n      id: id ?? null,\n    };\n  }\n\n  /**\n   * Handle a single JSON-RPC request\n   */\n  private async handleRequest(\n    request: JsonRpcRequest,\n    httpRequest: NextRequest,\n  ): Promise<JsonRpcResponse> {\n    // Validate JSON-RPC version\n    if (request.jsonrpc !== this.rpcVersion) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n        `Invalid JSON-RPC version. Only ${this.rpcVersion} is supported`,\n      );\n    }\n\n    // Validate method exists\n    if (!request.method) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n        \"Method is required\",\n      );\n    }\n\n    // Validate method format\n    const methodValidation = validateJsonRpcMethod(request.method);\n\n    if (!methodValidation.valid) {\n      throw new JsonRpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        methodValidation.error || \"Invalid method format\",\n      );\n    }\n\n    // Sanitize params to prevent XSS\n    const sanitizedParams = request.params\n      ? sanitizeJsonRpcParams(request.params)\n      : undefined;\n\n    try {\n      const result = await this.handleDynamicModelQuery(\n        request.method,\n        sanitizedParams,\n        httpRequest,\n      );\n\n      return this.createSuccessResponse(result, request.id);\n    } catch (error) {\n      if (error instanceof JsonRpcError) {\n        return this.createErrorResponse(\n          error.code,\n          error.message,\n          error.data,\n          request.id,\n        );\n      }\n\n      console.error(\"JSON-RPC internal error:\", error);\n\n      return this.createErrorResponse(\n        JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n        error instanceof Error ? error.message : \"Internal error\",\n        process.env.NODE_ENV === \"development\" ? String(error) : undefined,\n        request.id,\n      );\n    }\n  }\n\n  /**\n   * Handle HTTP request (single or batch)\n   */\n  async handle(httpRequest: NextRequest): Promise<NextResponse> {\n    try {\n      const body = await httpRequest.json();\n\n      // FOR BATCH REQUEST, each request is a JsonRpcRequest\n      if (Array.isArray(body)) {\n        if (!body.length) {\n          return NextResponse.json(\n            this.createErrorResponse(\n              JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n              \"Empty batch request\",\n            ),\n            { status: 400 },\n          );\n        }\n\n        const responses = await Promise.all(\n          body.map((request) => this.handleRequest(request, httpRequest)),\n        );\n\n        return NextResponse.json(responses);\n      }\n\n      // FOR SINGLE REQUEST\n      const response = await this.handleRequest(body, httpRequest);\n\n      return NextResponse.json(response);\n    } catch (error) {\n      return NextResponse.json(\n        this.createErrorResponse(\n          JSON_RPC_ERROR_CODES.PARSE_ERROR,\n          \"Parse error\",\n          error instanceof Error ? error.message : String(error),\n        ),\n        { status: 400 },\n      );\n    }\n  }\n}\n\nexport default JsonRpcHandler;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/ConfigManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/ConnectionPool.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":16,"suggestions":[{"fix":{"range":[2394,2456],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":22,"suggestions":[{"fix":{"range":[2841,2907],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":129,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":129,"endColumn":18,"suggestions":[{"fix":{"range":[3392,3461],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":131,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":131,"endColumn":20,"suggestions":[{"fix":{"range":[3490,3552],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":256,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":256,"endColumn":19,"suggestions":[{"fix":{"range":[6582,6643],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":264,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":264,"endColumn":19,"suggestions":[{"fix":{"range":[6771,6910],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":269,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":269,"endColumn":16,"suggestions":[{"fix":{"range":[6922,6983],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":302,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":302,"endColumn":18,"suggestions":[{"fix":{"range":[7869,7925],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":304,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":304,"endColumn":20,"suggestions":[{"fix":{"range":[7954,8018],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { PostgresJsDatabase } from \"drizzle-orm/postgres-js\";\nimport type { IConnectionPool } from \"./types\";\n\nimport { existsSync, readdirSync } from \"fs\";\nimport { join, relative } from \"path\";\n\nimport { drizzle } from \"drizzle-orm/postgres-js\";\nimport postgres from \"postgres\";\n\ntype SchemaRegistry = Record<string, unknown>;\n\n/**\n * Database connection configuration\n */\nexport interface DbConnectionConfig {\n  host?: string;\n  port?: number;\n  user?: string;\n  password?: string;\n  database?: string;\n  sslMode?: string;\n  max?: number;\n  idleTimeout?: number;\n  connectTimeout?: number;\n}\n\n/**\n * Database type\n */\nexport type DatabaseType = \"postgres\" | \"mongo\" | \"mysql\" | \"sqlite\";\n\n/**\n * Database connection interface\n */\nexport interface DatabaseConnection {\n  name: string;\n  type: DatabaseType;\n  db: PostgresJsDatabase<any> | any;\n  isPrimary: boolean;\n  config?: DbConnectionConfig;\n}\n\n/**\n * Connection Pool Manager\n * - Loads schemas from modules and wires drizzle/postgres connections\n */\nexport class ConnectionPool implements IConnectionPool {\n  private readonly projectRoot: string;\n  private connections = new Map<string, DatabaseConnection>();\n  private primaryConnectionName: string | null = null;\n  private isInitialized = false;\n\n  constructor(projectRoot: string = process.cwd()) {\n    this.projectRoot = projectRoot;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n    await this.registerPrimaryDatabase();\n    this.isInitialized = true;\n  }\n\n  private createPgClient() {\n    const config = this.getDefaultConfig();\n\n    return postgres({\n      host: config.host,\n      port: config.port,\n      user: config.user,\n      password: config.password,\n      database: config.database,\n      ssl: config.sslMode === \"require\" ? \"require\" : undefined,\n      max: config.max,\n      idle_timeout: config.idleTimeout,\n      connect_timeout: config.connectTimeout,\n    });\n  }\n\n  private getDefaultConfig(): DbConnectionConfig {\n    return {\n      host: process.env.PGHOST || \"localhost\",\n      port: Number(process.env.PGPORT || 5432),\n      user: process.env.PGUSER,\n      password: process.env.PGPASSWORD,\n      database: process.env.PGDATABASE,\n      sslMode: process.env.PGSSLMODE,\n      max: 10,\n      idleTimeout: 20,\n      connectTimeout: 10,\n    };\n  }\n\n  private async registerPrimaryDatabase(): Promise<void> {\n    console.log(\"Connecting to primary database (PostgreSQL)...\");\n\n    const isProduction = process.env.NODE_ENV === \"production\";\n    const schemas: SchemaRegistry = {};\n    const schemaEntryPoints = this.collectSchemaEntryPoints();\n\n    for (const schemaPath of schemaEntryPoints) {\n      try {\n        const schemaModule = await import(this.toImportPath(schemaPath));\n\n        Object.assign(schemas, schemaModule);\n      } catch (error) {\n        console.error(`Failed to load schema from ${schemaPath}:`, error);\n      }\n    }\n\n    try {\n      const client = this.createPgClient();\n      const db = drizzle(client, {\n        schema: schemas,\n      }) as PostgresJsDatabase<any>;\n\n      const connection: DatabaseConnection = {\n        name: \"primary\",\n        type: \"postgres\",\n        db,\n        config: isProduction ? this.getDefaultConfig() : undefined,\n        isPrimary: true,\n      };\n\n      this.connections.set(\"primary\", connection);\n      this.primaryConnectionName = \"primary\";\n\n      console.log(\"✅ Primary database (PostgreSQL) connected with schema\");\n    } catch (error) {\n      console.error(\"❌ Primary database connection failed:\", error);\n      throw error;\n    }\n  }\n\n  private collectSchemaEntryPoints(): string[] {\n    const schemaPaths: string[] = [];\n\n    const baseSchema = join(\n      this.projectRoot,\n      \"module-base\",\n      \"server\",\n      \"schemas\",\n      \"index.ts\",\n    );\n\n    if (existsSync(baseSchema)) {\n      schemaPaths.push(baseSchema);\n    }\n\n    const modulesRoot = join(this.projectRoot, \"modules\");\n\n    for (const dir of this.safeReadDir(modulesRoot)) {\n      const schemaPath = join(\n        modulesRoot,\n        dir,\n        \"server\",\n        \"schemas\",\n        \"index.ts\",\n      );\n\n      if (existsSync(schemaPath)) {\n        schemaPaths.push(schemaPath);\n      }\n    }\n\n    return schemaPaths;\n  }\n\n  private safeReadDir(dirPath: string): string[] {\n    if (!existsSync(dirPath)) return [];\n\n    return readdirSync(dirPath, { withFileTypes: true })\n      .filter((entry) => entry.isDirectory())\n      .map((entry) => entry.name);\n  }\n\n  private toImportPath(targetPath: string): string {\n    const relativePath = relative(this.projectRoot, targetPath).replace(\n      /\\\\/g,\n      \"/\",\n    );\n\n    return `@/${relativePath}`;\n  }\n\n  getConnection(\n    name: string = \"primary\",\n  ): PostgresJsDatabase<Record<string, never>> {\n    if (!this.isInitialized) {\n      throw new Error(\n        \"ConnectionPool not initialized. Call initialize() first.\",\n      );\n    }\n\n    const connection = this.connections.get(name);\n\n    if (!connection) {\n      throw new Error(`Database connection \"${name}\" not found.`);\n    }\n    if (!connection.db) {\n      throw new Error(`Database connection \"${name}\" not initialized.`);\n    }\n\n    if (connection.type !== \"postgres\") {\n      throw new Error(\n        `Database connection \"${name}\" is not a PostgreSQL connection.`,\n      );\n    }\n\n    return connection.db as PostgresJsDatabase<Record<string, never>>;\n  }\n\n  getPrimaryConnection(): PostgresJsDatabase<Record<string, never>> {\n    if (!this.isInitialized || !this.primaryConnectionName) {\n      throw new Error(\n        \"ConnectionPool not initialized. Call initialize() first.\",\n      );\n    }\n\n    const connection = this.connections.get(this.primaryConnectionName);\n\n    if (!connection) {\n      throw new Error(\"Primary database connection not found\");\n    }\n\n    return connection.db as PostgresJsDatabase<Record<string, never>>;\n  }\n\n  hasConnection(name: string): boolean {\n    return this.connections.has(name);\n  }\n\n  async closeAll(): Promise<void> {\n    this.connections.forEach((connection) => {\n      if (connection.type === \"postgres\" && connection.db) {\n        const client = (connection.db as any).$client;\n\n        if (client && typeof client.end === \"function\") {\n          client.end();\n        }\n      }\n    });\n    this.connections.clear();\n    this.primaryConnectionName = null;\n    this.isInitialized = false;\n  }\n\n  async registerDatabase(\n    name: string,\n    type: DatabaseType,\n    config?: Partial<DbConnectionConfig>,\n    schemas?: SchemaRegistry,\n  ): Promise<void> {\n    if (this.connections.has(name)) {\n      console.warn(`Database connection \"${name}\" already exists`);\n\n      return;\n    }\n\n    const isProduction = process.env.NODE_ENV === \"production\";\n\n    if (isProduction && config) {\n      console.warn(\n        `⚠️  Config parameters are ignored in production. Using environment variables only for database \"${name}\".`,\n      );\n    }\n\n    console.log(`Connecting to database \"${name}\" (${type})...`);\n\n    try {\n      let db: any;\n\n      switch (type) {\n        case \"postgres\": {\n          const client = this.createPgClient();\n\n          db = drizzle(client, { schema: schemas }) as PostgresJsDatabase<any>;\n          break;\n        }\n        case \"mongo\":\n          throw new Error(\"MongoDB connection not yet implemented\");\n        case \"mysql\":\n          throw new Error(\"MySQL connection not yet implemented\");\n        case \"sqlite\":\n          throw new Error(\"SQLite connection not yet implemented\");\n        default:\n          throw new Error(`Unsupported database type: ${type}`);\n      }\n\n      const connection: DatabaseConnection = {\n        name,\n        type,\n        db,\n        config: isProduction\n          ? this.getDefaultConfig()\n          : config || this.getDefaultConfig(),\n        isPrimary: false,\n      };\n\n      this.connections.set(name, connection);\n      console.log(`✅ Database \"${name}\" (${type}) connected`);\n    } catch (error) {\n      console.error(`❌ Database \"${name}\" connection failed:`, error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/ModelInstance.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":18,"suggestions":[{"fix":{"range":[1418,1538],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":71,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":71,"endColumn":20,"suggestions":[{"fix":{"range":[1706,1849],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":92,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":92,"endColumn":19,"suggestions":[{"fix":{"range":[2201,2255],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":121,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":121,"endColumn":20,"suggestions":[{"fix":{"range":[3091,3201],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":142,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":142,"endColumn":20,"suggestions":[{"fix":{"range":[3598,3736],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":157,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":157,"endColumn":16,"suggestions":[{"fix":{"range":[3938,3975],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":195,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":195,"endColumn":24,"suggestions":[{"fix":{"range":[5215,5329],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":16,"suggestions":[{"fix":{"range":[5359,5470],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":244,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":244,"endColumn":20,"suggestions":[{"fix":{"range":[6419,6482],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":278,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":278,"endColumn":20,"suggestions":[{"fix":{"range":[7126,7265],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":303,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":303,"endColumn":16,"suggestions":[{"fix":{"range":[7765,7801],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync, readdirSync, readFileSync } from \"fs\";\nimport { dirname, join, relative } from \"path\";\n\nimport dayjs from \"dayjs\";\nimport timezone from \"dayjs/plugin/timezone\";\nimport utc from \"dayjs/plugin/utc\";\n\nimport { MenuFactoryElm } from \"../interfaces/Menu\";\nimport { loadAllMenus } from \"../loaders/menu-loader\";\n\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.tz.setDefault(\"Asia/Ho_Chi_Minh\");\n\ntype ModelFactoryElm = {\n  instance: () => object;\n  path: string;\n  module: string;\n  key: string;\n  timestamp: string;\n};\n\ninterface ModelInstanceOptions {\n  projectRoot?: string;\n}\n\n/**\n * Model Instance Manager\n * - Loads model factories defined in module.json files\n * - Exposes menu factories\n */\nexport class ModelInstance {\n  private readonly projectRoot: string;\n  private readonly modelFactories = new Map<string, ModelFactoryElm>();\n  private readonly menuFactories: MenuFactoryElm[] = [];\n\n  private constructor(projectRoot: string) {\n    this.projectRoot = projectRoot;\n  }\n\n  static async create(\n    options: ModelInstanceOptions = {},\n  ): Promise<ModelInstance> {\n    const instance = new ModelInstance(options.projectRoot ?? process.cwd());\n\n    await instance.init();\n\n    return instance;\n  }\n\n  getModel<T extends object>(modelId: string): T | undefined {\n    const factoryElm = this.modelFactories.get(modelId);\n\n    if (!factoryElm) {\n      return undefined;\n    }\n\n    try {\n      console.log(\n        \"Log load model: \",\n        modelId,\n        \"created at: \",\n        factoryElm.timestamp,\n      );\n      const instance = factoryElm.instance();\n\n      if (instance && typeof instance === \"object\") {\n        return instance as T;\n      }\n    } catch (error) {\n      console.error(\n        `Failed to instantiate model \"${modelId}\"${factoryElm.path ? ` from ${factoryElm.path}` : \"\"}:`,\n        error,\n      );\n    }\n\n    return undefined;\n  }\n\n  getAllModels(): ModelFactoryElm[] {\n    return Array.from(this.modelFactories.values());\n  }\n\n  getMenuFactories(): MenuFactoryElm[] {\n    return this.menuFactories;\n  }\n\n  async reloadModel(modelId: string): Promise<boolean> {\n    const factoryElm = this.modelFactories.get(modelId);\n\n    if (!factoryElm) {\n      console.warn(`Model \"${modelId}\" is not registered.`);\n\n      return false;\n    }\n\n    const moduleJsonPaths = this.collectModuleJsonPaths();\n    let modelPath: string | null = null;\n    let folderName: string = factoryElm.module;\n\n    for (const moduleJsonPath of moduleJsonPaths) {\n      const folderMdlRoot = this.resolveModuleName(moduleJsonPath);\n      const currentFolderName =\n        folderMdlRoot === \"module-base\"\n          ? \"base\"\n          : (folderMdlRoot ?? \"unknown-module\");\n\n      if (currentFolderName === factoryElm.module) {\n        const pathToModelFile = join(\"server\", \"models\", factoryElm.path);\n        const fullModelPath = join(dirname(moduleJsonPath), pathToModelFile);\n\n        if (existsSync(fullModelPath)) {\n          modelPath = fullModelPath;\n          folderName = currentFolderName;\n          break;\n        }\n      }\n    }\n\n    if (!modelPath) {\n      console.error(\n        `Failed to find model file for \"${modelId}\" in module \"${factoryElm.module}\"`,\n      );\n\n      return false;\n    }\n\n    try {\n      const mod = await import(this.toImportPath(modelPath));\n      const ModelClass = mod?.default;\n\n      if (!ModelClass) {\n        throw new Error(\"Missing default export\");\n      }\n\n      const factory = () => new ModelClass();\n\n      this.registerOneModel(modelId, folderName, factory, factoryElm.path);\n\n      return true;\n    } catch (error) {\n      console.error(\n        `Failed to reload model \"${modelId}\"${factoryElm.path ? ` from ${factoryElm.path}` : \"\"}:`,\n        error,\n      );\n\n      return false;\n    }\n  }\n\n  private async init(): Promise<void> {\n    await this.registerModels();\n    await this.registerMenuStatic();\n  }\n\n  private async registerModels(): Promise<void> {\n    console.log(\"Registering models...\");\n\n    const moduleJsonPaths = this.collectModuleJsonPaths();\n    let loadedCount = 0;\n    let errorCount = 0;\n\n    for (const moduleJsonPath of moduleJsonPaths) {\n      const moduleDefinition = this.safeReadJson<{\n        models?: Record<string, string>;\n      }>(moduleJsonPath);\n      const configuredModels = moduleDefinition?.models;\n\n      if (!configuredModels) continue;\n\n      for (const [modelId, fileName] of Object.entries(configuredModels)) {\n        const pathToModelFile = join(\"server\", \"models\", fileName);\n        const modelPath = join(dirname(moduleJsonPath), pathToModelFile);\n        const folderMdlRoot = this.resolveModuleName(moduleJsonPath);\n\n        const folderName =\n          folderMdlRoot === \"module-base\"\n            ? \"base\"\n            : (folderMdlRoot ?? \"unknown-module\");\n\n        try {\n          const mod = await import(this.toImportPath(modelPath));\n          const ModelClass = mod?.default;\n\n          if (!ModelClass) {\n            throw new Error(\"Missing default export\");\n          }\n\n          const factory = () => new ModelClass();\n\n          this.registerOneModel(modelId, folderName, factory, fileName);\n          loadedCount++;\n        } catch (error) {\n          errorCount++;\n          console.error(\n            `Failed to load model \"${modelId}\" from ${modelPath}:`,\n            error,\n          );\n        }\n      }\n    }\n\n    console.log(\n      `Model registry: ${loadedCount} loaded${errorCount ? `, ${errorCount} errors` : \"\"}`,\n    );\n  }\n\n  private collectModuleJsonPaths(): string[] {\n    const paths: string[] = [];\n\n    const baseModuleJson = join(this.projectRoot, \"module-base\", \"module.json\");\n\n    if (existsSync(baseModuleJson)) {\n      paths.push(baseModuleJson);\n    }\n\n    const modulesRoot = join(this.projectRoot, \"modules\");\n\n    for (const dir of this.safeReadDir(modulesRoot)) {\n      const moduleJson = join(modulesRoot, dir, \"module.json\");\n\n      if (existsSync(moduleJson)) {\n        paths.push(moduleJson);\n      }\n    }\n\n    return paths;\n  }\n\n  private safeReadDir(dirPath: string): string[] {\n    if (!existsSync(dirPath)) return [];\n\n    return readdirSync(dirPath, { withFileTypes: true })\n      .filter((entry) => entry.isDirectory())\n      .map((entry) => entry.name);\n  }\n\n  private safeReadJson<T>(filePath: string): T | null {\n    try {\n      const raw = readFileSync(filePath, \"utf8\");\n\n      return JSON.parse(raw) as T;\n    } catch (error) {\n      console.error(`Failed to parse JSON from ${filePath}:`, error);\n\n      return null;\n    }\n  }\n\n  private toImportPath(targetPath: string): string {\n    const relativePath = relative(this.projectRoot, targetPath).replace(\n      /\\\\/g,\n      \"/\",\n    );\n\n    return `@/${relativePath}`;\n  }\n\n  private registerOneModel(\n    modelId: string,\n    moduleName: string,\n    factory: () => object,\n    sourcePath: string,\n  ): void {\n    const entry: ModelFactoryElm = {\n      instance: factory,\n      path: sourcePath,\n      module: moduleName,\n      key: modelId,\n      timestamp: dayjs().toISOString(),\n    };\n\n    this.modelFactories.set(modelId, entry);\n\n    try {\n      factory();\n    } catch (error) {\n      console.error(\n        `Model \"${modelId}\" threw during initialization${sourcePath ? ` from ${sourcePath}` : \"\"}:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  private resolveModuleName(moduleJsonPath: string): string {\n    const moduleDir = dirname(moduleJsonPath);\n    const relativeModuleDir = relative(this.projectRoot, moduleDir).replace(\n      /\\\\/g,\n      \"/\",\n    );\n\n    if (!relativeModuleDir || relativeModuleDir === \".\") {\n      return \"root\";\n    }\n\n    const segments = relativeModuleDir.split(\"/\").filter(Boolean);\n\n    return segments.pop() ?? relativeModuleDir;\n  }\n\n  private registerMenuStatic(): void {\n    console.log(\"Registering menus...\");\n    const menus = loadAllMenus();\n\n    for (const menu of menus) {\n      this.menuFactories.push(menu);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/RuntimeContext.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":166,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":166,"endColumn":20,"suggestions":[{"fix":{"range":[5042,5083],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":20,"suggestions":[{"fix":{"range":[6227,6297],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":209,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":209,"endColumn":20,"suggestions":[{"fix":{"range":[6349,6472],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/runtime/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.administrative-unit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.country.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.currency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.dynamic-entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.guideline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.news.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.payment-method.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.payment-term.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.permission.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.role-permissions-default.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.role.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.shipping-method.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.shipping-term.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.tax-rate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.user-permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.user-roles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/base.user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/stores/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/stores/rate-limit-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/JSONResponse.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/auth-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/csrf-token.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":115,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createHmac, randomBytes } from \"crypto\";\n\nimport { CSRF_CONFIG } from \"@base/server/config\";\n\n/**\n * CSRF token configuration\n */\nexport interface CsrfTokenConfig {\n  /**\n   * Secret key for token generation\n   * @default process.env.CSRF_SECRET || 'csrf-secret-key-change-in-production'\n   */\n  secret?: string;\n  /**\n   * Token length in bytes\n   * @default 32\n   */\n  tokenLength?: number;\n  /**\n   * Token expiration time in milliseconds\n   * @default 24 * 60 * 60 * 1000 (24 hours)\n   */\n  expirationMs?: number;\n}\n\n/**\n * Default CSRF configuration\n */\nconst defaultConfig: Required<CsrfTokenConfig> = {\n  secret: CSRF_CONFIG.secret,\n  tokenLength: CSRF_CONFIG.tokenLength,\n  expirationMs: CSRF_CONFIG.expirationMs,\n};\n\n/**\n * Generate a random CSRF token\n */\nexport function generateCsrfToken(config: CsrfTokenConfig = {}): string {\n  const finalConfig = { ...defaultConfig, ...config };\n\n  return randomBytes(finalConfig.tokenLength).toString(\"hex\");\n}\n\n/**\n * Create a signed CSRF token with expiration\n */\nexport function createSignedCsrfToken(config: CsrfTokenConfig = {}): {\n  token: string;\n  signedToken: string;\n  expiresAt: number;\n} {\n  const finalConfig = { ...defaultConfig, ...config };\n  const token = generateCsrfToken(finalConfig);\n  const expiresAt = Date.now() + finalConfig.expirationMs;\n\n  // Create signature: HMAC(token + expiresAt)\n  const data = `${token}:${expiresAt}`;\n  const signature = createHmac(\"sha256\", finalConfig.secret)\n    .update(data)\n    .digest(\"hex\");\n\n  // Return token:signature:expiresAt\n  const signedToken = `${token}:${signature}:${expiresAt}`;\n\n  return {\n    token,\n    signedToken,\n    expiresAt,\n  };\n}\n\n/**\n * Verify a signed CSRF token\n */\nexport function verifyCsrfToken(\n  signedToken: string,\n  config: CsrfTokenConfig = {},\n): {\n  valid: boolean;\n  expired: boolean;\n  token?: string;\n} {\n  const finalConfig = { ...defaultConfig, ...config };\n\n  try {\n    const parts = signedToken.split(\":\");\n\n    if (parts.length !== 3) {\n      return { valid: false, expired: false };\n    }\n\n    const [token, signature, expiresAtStr] = parts;\n    const expiresAt = parseInt(expiresAtStr, 10);\n\n    // Check expiration\n    if (Date.now() > expiresAt) {\n      return { valid: false, expired: true };\n    }\n\n    // Verify signature\n    const data = `${token}:${expiresAt}`;\n    const expectedSignature = createHmac(\"sha256\", finalConfig.secret)\n      .update(data)\n      .digest(\"hex\");\n\n    if (signature !== expectedSignature) {\n      return { valid: false, expired: false };\n    }\n\n    return {\n      valid: true,\n      expired: false,\n      token,\n    };\n  } catch (error) {\n    return { valid: false, expired: false };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/get-module-names.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/getModuleQueryByModel.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":18,"suggestions":[{"fix":{"range":[1162,1217],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RuntimeContext } from \"../runtime/RuntimeContext\";\n\nimport { JSONResponse } from \"./JSONResponse\";\n\ntype GetModuleQueryByModelProps = {\n  model: string;\n  modelMethod: string;\n  params?: Record<string, any>;\n};\nconst getModuleQueryByModel = async (props: GetModuleQueryByModelProps) => {\n  const { model, modelMethod, params } = props ?? {};\n  const modelKey = model;\n\n  // validate model key and method\n  if (!modelKey) {\n    return JSONResponse({ status: 400, message: \"MODEL IS REQUIRED\" });\n  }\n  if (!modelMethod) {\n    return JSONResponse({ status: 400, message: \"METHOD ARE REQUIRED\" });\n  }\n  // get model instance\n  const modelInstance = await RuntimeContext.getModelInstanceBy(modelKey);\n\n  // validate model\n  if (!modelInstance) {\n    return JSONResponse({ status: 500, message: \"MODEL NOT FOUND\" });\n  }\n  const method = (modelInstance as any)[modelMethod] as (\n    params?: Record<string, any>,\n  ) => Promise<any>;\n\n  if (!method) {\n    return JSONResponse({ status: 500, message: \"METHOD NOT FOUND\" });\n  }\n  try {\n    const result = await method(params);\n\n    return JSONResponse({ status: 200, data: result });\n  } catch (error) {\n    console.error(\"Error in getModuleQueryByModel\", error);\n\n    return JSONResponse({\n      status: 500,\n      message: \"ERROR IN METHOD\",\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n};\n\nexport default getModuleQueryByModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/initializeRuntime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/request-monitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/security-logger.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":55,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":55,"endColumn":20,"suggestions":[{"fix":{"range":[1441,1466],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":57,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":57,"endColumn":19,"suggestions":[{"fix":{"range":[1513,1537],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":18,"suggestions":[{"fix":{"range":[1557,1580],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":18,"suggestions":[{"fix":{"range":[2043,2101],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":113,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":113,"endColumn":20,"suggestions":[{"fix":{"range":[2617,2675],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":143,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":143,"endColumn":18,"suggestions":[{"fix":{"range":[3173,3232],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":170,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":170,"endColumn":18,"suggestions":[{"fix":{"range":[3683,3747],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":194,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":194,"endColumn":18,"suggestions":[{"fix":{"range":[4144,4200],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Security Logger Utility\n *\n * Provides structured logging for security-related events:\n * - Authentication failures\n * - Authorization failures\n * - Suspicious requests\n * - Rate limit violations\n */\n\nimport { getLogModel, type LogEntry } from \"../models/Logs/LogModel\";\nimport { LogSeverity, LogType } from \"../models/Logs/LogTypes\";\n\n/**\n * Format security log entry (for console output)\n */\nfunction formatSecurityLog(entry: LogEntry): string {\n  const { timestamp, type, severity, message, metadata } = entry;\n\n  const metadataStr = Object.entries(metadata)\n    .filter(([_, value]) => value !== undefined && value !== null)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .join(\" \");\n\n  return `[SECURITY] [${severity.toUpperCase()}] [${type}] ${timestamp} ${message} ${metadataStr}`;\n}\n\n/**\n * Write log entry using LogModel\n */\nasync function writeLog(\n  type: LogType,\n  severity: LogSeverity,\n  message: string,\n  metadata: Record<string, unknown> = {},\n): Promise<void> {\n  const entry: LogEntry = {\n    timestamp: new Date().toISOString(),\n    type,\n    severity,\n    message,\n    metadata,\n  };\n\n  // Write using LogModel\n  const logModel = getLogModel();\n\n  await logModel.write(entry);\n\n  // Also output to console for development/debugging\n  if (process.env.NODE_ENV === \"development\") {\n    const formatted = formatSecurityLog(entry);\n\n    if (severity === \"high\" || severity === \"critical\") {\n      console.error(formatted);\n    } else if (severity === \"medium\") {\n      console.warn(formatted);\n    } else {\n      console.log(formatted);\n    }\n  }\n}\n\n/**\n * Log authentication failure\n */\nexport function logAuthFailure(\n  reason: string,\n  metadata: {\n    ip?: string;\n    userAgent?: string;\n    path?: string;\n    method?: string;\n    username?: string;\n    userId?: string;\n    [key: string]: unknown;\n  } = {},\n): void {\n  writeLog(\n    LogType.AUTH_FAILURE,\n    LogSeverity.HIGH,\n    `Authentication failure: ${reason}`,\n    {\n      ...metadata,\n      reason,\n    },\n  ).catch((error) => {\n    console.error(\"Failed to write auth failure log:\", error);\n  });\n}\n\n/**\n * Log authentication success (for audit trail)\n */\nexport function logAuthSuccess(metadata: {\n  ip?: string;\n  userAgent?: string;\n  path?: string;\n  userId: string;\n  username: string;\n}): void {\n  // Only log in development or if explicitly enabled\n  if (\n    process.env.LOG_AUTH_SUCCESS === \"true\" ||\n    process.env.NODE_ENV === \"development\"\n  ) {\n    writeLog(\n      LogType.AUTH_SUCCESS,\n      LogSeverity.LOW,\n      \"Authentication successful\",\n      metadata,\n    ).catch((error) => {\n      console.error(\"Failed to write auth success log:\", error);\n    });\n  }\n}\n\n/**\n * Log authorization failure\n */\nexport function logAuthzFailure(\n  reason: string,\n  metadata: {\n    ip?: string;\n    userAgent?: string;\n    path?: string;\n    method?: string;\n    userId?: string;\n    username?: string;\n    requiredPermission?: string;\n    [key: string]: unknown;\n  } = {},\n): void {\n  writeLog(\n    LogType.AUTHZ_FAILURE,\n    LogSeverity.HIGH,\n    `Authorization failure: ${reason}`,\n    {\n      ...metadata,\n      reason,\n    },\n  ).catch((error) => {\n    console.error(\"Failed to write authz failure log:\", error);\n  });\n}\n\n/**\n * Log suspicious request\n */\nexport function logSuspiciousRequest(\n  reason: string,\n  metadata: {\n    ip?: string;\n    userAgent?: string;\n    path?: string;\n    method?: string;\n    userId?: string;\n    [key: string]: unknown;\n  } = {},\n): void {\n  writeLog(\n    LogType.SUSPICIOUS_REQUEST,\n    LogSeverity.MEDIUM,\n    `Suspicious request detected: ${reason}`,\n    {\n      ...metadata,\n      reason,\n    },\n  ).catch((error) => {\n    console.error(\"Failed to write suspicious request log:\", error);\n  });\n}\n\n/**\n * Log rate limit violation\n */\nexport function logRateLimitViolation(\n  metadata: {\n    ip?: string;\n    userAgent?: string;\n    path?: string;\n    method?: string;\n    limit?: number;\n    window?: number;\n    [key: string]: unknown;\n  } = {},\n): void {\n  writeLog(\n    LogType.RATE_LIMIT,\n    LogSeverity.MEDIUM,\n    \"Rate limit exceeded\",\n    metadata,\n  ).catch((error) => {\n    console.error(\"Failed to write rate limit log:\", error);\n  });\n}\n\n/**\n * Get client IP from request\n * Supports both NextRequest and objects with headers property\n */\nexport function getClientIp(request: {\n  headers: Headers | { get: (key: string) => string | null };\n}): string {\n  const headers = request.headers;\n  const forwarded = headers.get(\"x-forwarded-for\");\n\n  if (forwarded) {\n    return forwarded.split(\",\")[0].trim();\n  }\n  const realIp = headers.get(\"x-real-ip\");\n\n  if (realIp) {\n    return realIp;\n  }\n\n  return \"unknown\";\n}\n\n/**\n * Get user agent from request\n * Supports both NextRequest and objects with headers property\n */\nexport function getUserAgent(request: {\n  headers: Headers | { get: (key: string) => string | null };\n}): string {\n  const headers = request.headers;\n\n  return headers.get(\"user-agent\") || \"unknown\";\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/utils/xss-protection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/schemas/common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/schemas/jsonrpc.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/schemas/product.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/server/validation/validateModelName.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/interface/FilterInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/interface/ListInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/interface/Locale.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/interface/SearchInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/module-base/shared/interface/SortInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/interface/Customer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/interface/MasterData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/interface/SalesOrder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/interface/SalesOrderB2B.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/interface/SalesOrderB2C.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Customers/CustomerCompaniesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { CustomerCompany } from \"../../interface/Customer\";\n\ntype CustomerCompanyRow = CustomerCompany & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function CustomerCompaniesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<CustomerCompanyRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: \"Code\",\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/b2b-sales/customers/companies/view/${row.id}`}\n            >\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: \"Company Name\",\n      },\n      {\n        key: \"taxId\",\n        label: \"Tax ID\",\n      },\n      {\n        key: \"phone\",\n        label: \"Phone\",\n      },\n      {\n        key: \"email\",\n        label: \"Email\",\n      },\n      {\n        key: \"isActive\",\n        label: \"Status\",\n        render: (_, row) => (\n          <Chip\n            color={row.isActive ? \"success\" : \"danger\"}\n            size=\"sm\"\n            variant=\"flat\"\n          >\n            {row.isActive ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"createdAt\",\n        label: \"Created\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2b-sales/customers/companies/view/${row.id}`;\n          const editLink = `/workspace/modules/b2b-sales/customers/companies/edit/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: \"Edit\",\n                  href: editLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<CustomerCompanyRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Company\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2b-sales/customers/companies/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2b-sales-customer-company\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Customers/CustomerCompanyCreatePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Customers/CustomerCompanyEditPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Customers/CustomerCompanyViewPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Deliveries/CreateDeliveryPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Deliveries/DeliveriesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\ntype DeliveryRow = {\n  id: string;\n  orderType: string;\n  orderId: string;\n  warehouseId?: string | null;\n  deliveryDate?: number | string | null;\n  reference?: string | null;\n  status: string;\n  createdAt?: number | string | null;\n};\n\nexport default function DeliveriesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<DeliveryRow>[]>(\n    () => [\n      {\n        key: \"reference\",\n        label: \"Reference\",\n        render: (value, row) => {\n          if (!row?.id) return value || \"-\";\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/b2b-sales/deliveries/view/${row.id}`}\n            >\n              {value || row.id.substring(0, 8)}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"orderType\",\n        label: \"Order Type\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"B2B\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"deliveryDate\",\n        label: \"Delivery Date\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"status\",\n        label: \"Status\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"createdAt\",\n        label: \"Created\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2b-sales/deliveries/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<DeliveryRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Delivery\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2b-sales/deliveries/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2b-sales-delivery\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Orders/SalesOrderB2BCreatePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Orders/SalesOrderB2BEditPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Orders/SalesOrderB2BViewPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/pages/Orders/SalesOrdersB2BListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":23,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { SalesOrderB2B } from \"../../interface/SalesOrderB2B\";\n\ntype SalesOrderB2BRow = SalesOrderB2B & {\n  expectedDate?: number | string | null;\n  createdAt?: number | string | null;\n};\n\nexport default function SalesOrdersB2BListPage(): React.ReactNode {\n  const t = useTranslations(\"sale.ordersB2B.list\");\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<SalesOrderB2BRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: \"Code\",\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/b2b-sales/view/${row.id}`}>\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"companyName\",\n        label: \"Company Name\",\n      },\n      {\n        key: \"status\",\n        label: \"Status\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"expectedDate\",\n        label: \"Expected Date\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"grandTotal\",\n        label: \"Total Amount\",\n        render: (_, row) =>\n          new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: row.currency || \"USD\",\n          }).format(Number(row.grandTotal ?? 0)),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2b-sales/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<SalesOrderB2BRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Order\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2b-sales/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2b-sales-order\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/services/CustomerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/services/DeliveryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/services/SalesOrderB2BService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/client/services/SalesOrderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Customer/CustomerCompanyViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_customer_companies } from \"../../schemas\";\n\nclass CustomerCompanyViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_customer_companies,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_customer_companies,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_customer_companies.id, sort: true }],\n      [\"code\", { column: sale_b2c_tb_customer_companies.code, sort: true }],\n      [\"name\", { column: sale_b2c_tb_customer_companies.name, sort: true }],\n      [\"taxId\", { column: sale_b2c_tb_customer_companies.taxId, sort: true }],\n      [\"phone\", { column: sale_b2c_tb_customer_companies.phone, sort: true }],\n      [\"email\", { column: sale_b2c_tb_customer_companies.email, sort: true }],\n      [\n        \"isActive\",\n        { column: sale_b2c_tb_customer_companies.isActive, sort: true },\n      ],\n      [\n        \"createdAt\",\n        { column: sale_b2c_tb_customer_companies.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: sale_b2c_tb_customer_companies.updatedAt, sort: true },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.code, text),\n      ],\n      [\n        \"name\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.name, text),\n      ],\n      [\n        \"taxId\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.taxId, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    taxId: row.taxId ?? undefined,\n    address: row.address ?? undefined,\n    phone: row.phone ?? undefined,\n    email: row.email ?? undefined,\n    website: row.website ?? undefined,\n    contactPerson: row.contactPerson ?? undefined,\n    creditLimit: row.creditLimit ?? undefined,\n    paymentTermsId: row.paymentTermsId ?? undefined,\n    isActive: row.isActive,\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default CustomerCompanyViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Customer/CustomerIndividualViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_customers } from \"../../schemas\";\n\nclass CustomerIndividualViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_customers,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_customers,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_customers.id, sort: true }],\n      [\"code\", { column: sale_b2c_tb_customers.code, sort: true }],\n      [\"firstName\", { column: sale_b2c_tb_customers.firstName, sort: true }],\n      [\"lastName\", { column: sale_b2c_tb_customers.lastName, sort: true }],\n      [\"phone\", { column: sale_b2c_tb_customers.phone, sort: true }],\n      [\"email\", { column: sale_b2c_tb_customers.email, sort: true }],\n      [\"isActive\", { column: sale_b2c_tb_customers.isActive, sort: true }],\n      [\"createdAt\", { column: sale_b2c_tb_customers.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2c_tb_customers.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(sale_b2c_tb_customers.code, text)],\n      [\n        \"firstName\",\n        (text: string) => ilike(sale_b2c_tb_customers.firstName, text),\n      ],\n      [\n        \"lastName\",\n        (text: string) => ilike(sale_b2c_tb_customers.lastName, text),\n      ],\n      [\"phone\", (text: string) => ilike(sale_b2c_tb_customers.phone, text)],\n      [\"email\", (text: string) => ilike(sale_b2c_tb_customers.email, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    firstName: row.firstName,\n    lastName: row.lastName,\n    phone: row.phone ?? undefined,\n    email: row.email ?? undefined,\n    address: row.address ?? undefined,\n    dateOfBirth: row.dateOfBirth?.getTime(),\n    gender: row.gender ?? undefined,\n    isActive: row.isActive,\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default CustomerIndividualViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Customer/CustomerModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":40,"fix":{"range":[365,365],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type {\n  CreateCustomerCompanyInput,\n  CreateCustomerIndividualInput,\n  UpdateCustomerCompanyInput,\n  UpdateCustomerIndividualInput,\n} from \"../../models/interfaces/Customer\";\nimport type {\n  NewSaleB2cTbCustomer,\n  NewSaleB2cTbCustomerCompany,\n  SaleB2cTbCustomer,\n  SaleB2cTbCustomerCompany,\n} from \"../../schemas\";\n\nimport { desc, eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\n\nimport {\n  sale_b2c_tb_customer_companies,\n  sale_b2c_tb_customers,\n} from \"../../schemas\";\n\nexport default class CustomerModel {\n  private companyModel: BaseModel<typeof sale_b2c_tb_customer_companies>;\n  private individualModel: BaseModel<typeof sale_b2c_tb_customers>;\n\n  constructor() {\n    this.companyModel = new BaseModel(sale_b2c_tb_customer_companies);\n    this.individualModel = new BaseModel(sale_b2c_tb_customers);\n  }\n\n  // Company methods\n  listCompanies = async (): Promise<SaleB2cTbCustomerCompany[]> => {\n    const db = await RuntimeContext.getDbConnect();\n\n    return db\n      .select()\n      .from(sale_b2c_tb_customer_companies)\n      .orderBy(desc(sale_b2c_tb_customer_companies.createdAt));\n  };\n\n  getCompanyById = async (\n    id: string,\n  ): Promise<SaleB2cTbCustomerCompany | null> => {\n    const db = await RuntimeContext.getDbConnect();\n    const [company] = await db\n      .select()\n      .from(sale_b2c_tb_customer_companies)\n      .where(eq(sale_b2c_tb_customer_companies.id, id))\n      .limit(1);\n\n    return company ?? null;\n  };\n\n  createCompany = async (input: CreateCustomerCompanyInput) => {\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `CUST-COMP-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    const payload: NewSaleB2cTbCustomerCompany = {\n      code: generatedCode,\n      name: input.name.trim(),\n      taxId: input.taxId,\n      address: input.address,\n      phone: input.phone,\n      email: input.email,\n      website: input.website,\n      contactPerson: input.contactPerson,\n      creditLimit: input.creditLimit?.toString(),\n      paymentTermsId: input.paymentTermsId,\n      isActive: input.isActive ?? true,\n      notes: input.notes,\n      createdBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [company] = await db\n      .insert(sale_b2c_tb_customer_companies)\n      .values(payload)\n      .returning();\n\n    return company;\n  };\n\n  updateCompany = async (input: UpdateCustomerCompanyInput) => {\n    const now = new Date();\n    const updatePayload: Partial<NewSaleB2cTbCustomerCompany> = {\n      name: input.name?.trim(),\n      taxId: input.taxId,\n      address: input.address,\n      phone: input.phone,\n      email: input.email,\n      website: input.website,\n      contactPerson: input.contactPerson,\n      creditLimit: input.creditLimit?.toString(),\n      paymentTermsId: input.paymentTermsId,\n      isActive: input.isActive,\n      notes: input.notes,\n      updatedAt: now,\n      updatedBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [updated] = await db\n      .update(sale_b2c_tb_customer_companies)\n      .set(updatePayload)\n      .where(eq(sale_b2c_tb_customer_companies.id, input.id))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Customer company not found\");\n    }\n\n    return updated;\n  };\n\n  // Individual methods\n  listIndividuals = async (): Promise<SaleB2cTbCustomer[]> => {\n    const db = await RuntimeContext.getDbConnect();\n\n    return db\n      .select()\n      .from(sale_b2c_tb_customers)\n      .orderBy(desc(sale_b2c_tb_customers.createdAt));\n  };\n\n  getIndividualById = async (id: string): Promise<SaleB2cTbCustomer | null> => {\n    const db = await RuntimeContext.getDbConnect();\n    const [individual] = await db\n      .select()\n      .from(sale_b2c_tb_customers)\n      .where(eq(sale_b2c_tb_customers.id, id))\n      .limit(1);\n\n    return individual ?? null;\n  };\n\n  createIndividual = async (input: CreateCustomerIndividualInput) => {\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `CUST-IND-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    const payload: NewSaleB2cTbCustomer = {\n      code: generatedCode,\n      firstName: input.firstName.trim(),\n      lastName: input.lastName.trim(),\n      phone: input.phone,\n      email: input.email,\n      address: input.address,\n      dateOfBirth: input.dateOfBirth ? new Date(input.dateOfBirth) : undefined,\n      gender: input.gender,\n      isActive: input.isActive ?? true,\n      notes: input.notes,\n      createdBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [individual] = await db\n      .insert(sale_b2c_tb_customers)\n      .values(payload)\n      .returning();\n\n    return individual;\n  };\n\n  updateIndividual = async (input: UpdateCustomerIndividualInput) => {\n    const now = new Date();\n    const updatePayload: Partial<NewSaleB2cTbCustomer> = {\n      firstName: input.firstName?.trim(),\n      lastName: input.lastName?.trim(),\n      phone: input.phone,\n      email: input.email,\n      address: input.address,\n      dateOfBirth: input.dateOfBirth ? new Date(input.dateOfBirth) : undefined,\n      gender: input.gender,\n      isActive: input.isActive,\n      notes: input.notes,\n      updatedAt: now,\n      updatedBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [updated] = await db\n      .update(sale_b2c_tb_customers)\n      .set(updatePayload)\n      .where(eq(sale_b2c_tb_customers.id, input.id))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Customer individual not found\");\n    }\n\n    return updated;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Customer/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Delivery/DeliveryModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[197,197],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'order' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":77,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type StockModel from \"@mdl/stock/server/models/Stock/StockModel\";\nimport type {\n  NewSaleB2bTbDelivery,\n  NewSaleB2bTbDeliveryLine,\n} from \"../../schemas\";\n\nimport { eq } from \"drizzle-orm\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  sale_b2c_tb_order_lines,\n  sale_b2c_tb_orders,\n} from \"@mdl/b2c-sales/server/schemas\";\n\nimport {\n  sale_b2b_tb_deliveries,\n  sale_b2b_tb_delivery_lines,\n  sale_b2b_tb_order_lines,\n  sale_b2b_tb_orders,\n} from \"../../schemas\";\n\nexport interface CreateDeliveryInput {\n  orderType: \"B2B\" | \"B2C\";\n  orderId: string;\n  warehouseId: string;\n  deliveryDate: string;\n  reference?: string;\n  note?: string;\n  lines: Array<{\n    lineId: string;\n    quantity: number;\n  }>;\n  userId?: string;\n}\n\nexport default class DeliveryModel extends BaseModel<\n  typeof sale_b2b_tb_deliveries\n> {\n  constructor() {\n    super(sale_b2b_tb_deliveries);\n  }\n\n  create = async (input: CreateDeliveryInput) => {\n    const stockModel =\n      await RuntimeContext.getModelInstanceBy<StockModel>(\"stock\");\n\n    if (!stockModel) {\n      throw new Error(\"Stock model is not registered\");\n    }\n\n    // Get order to validate\n    let order: any;\n    let orderCode: string;\n\n    if (input.orderType === \"B2B\") {\n      const [b2bOrder] = await this.db\n        .select()\n        .from(sale_b2b_tb_orders)\n        .where(eq(sale_b2b_tb_orders.id, input.orderId))\n        .limit(1);\n\n      if (!b2bOrder) {\n        throw new Error(\"Order not found\");\n      }\n      order = b2bOrder;\n      orderCode = b2bOrder.code;\n    } else {\n      const [b2cOrder] = await this.db\n        .select()\n        .from(sale_b2c_tb_orders)\n        .where(eq(sale_b2c_tb_orders.id, input.orderId))\n        .limit(1);\n\n      if (!b2cOrder) {\n        throw new Error(\"Order not found\");\n      }\n      order = b2cOrder;\n      orderCode = b2cOrder.code;\n    }\n\n    // Get order lines\n    const lineTable =\n      input.orderType === \"B2B\"\n        ? sale_b2b_tb_order_lines\n        : sale_b2c_tb_order_lines;\n    const orderLines = await this.db\n      .select()\n      .from(lineTable)\n      .where(eq(lineTable.orderId, input.orderId));\n\n    const linesById = new Map();\n\n    for (const line of orderLines) {\n      linesById.set(line.id, line);\n    }\n\n    const deliveryDate = new Date(input.deliveryDate);\n    const now = new Date();\n\n    return this.db.transaction(async (tx) => {\n      // Create delivery record\n      const deliveryPayload: NewSaleB2bTbDelivery = {\n        orderType: input.orderType,\n        orderId: input.orderId,\n        warehouseId: input.warehouseId,\n        deliveryDate: deliveryDate,\n        reference: input.reference,\n        note: input.note,\n        status: \"draft\",\n        createdBy: input.userId,\n      };\n\n      const [delivery] = await tx\n        .insert(sale_b2b_tb_deliveries)\n        .values(deliveryPayload)\n        .returning();\n\n      // Process delivery lines and create stock moves\n      for (const deliveryLine of input.lines) {\n        const orderLine = linesById.get(deliveryLine.lineId);\n\n        if (!orderLine) {\n          throw new Error(`Order line ${deliveryLine.lineId} not found`);\n        }\n\n        const quantity = Number(deliveryLine.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const alreadyDelivered = Number(orderLine.quantityDelivered ?? 0);\n        const orderedQty = Number(orderLine.quantityOrdered ?? 0);\n        const nextDelivered = alreadyDelivered + quantity;\n\n        if (nextDelivered - orderedQty > 0.0001) {\n          throw new Error(\n            `Cannot deliver more than ordered for product ${orderLine.productId}`,\n          );\n        }\n\n        // Create delivery line\n        const deliveryLinePayload: NewSaleB2bTbDeliveryLine = {\n          deliveryId: delivery.id,\n          orderType: input.orderType,\n          orderLineId: deliveryLine.lineId,\n          quantity: quantity.toString(),\n        };\n\n        await tx.insert(sale_b2b_tb_delivery_lines).values(deliveryLinePayload);\n\n        // Update order line delivered quantity\n        await tx\n          .update(lineTable)\n          .set({\n            quantityDelivered: nextDelivered.toString(),\n            updatedAt: now,\n          })\n          .where(eq(lineTable.id, deliveryLine.lineId));\n\n        // Create stock move (outbound)\n        await stockModel.issueStock({\n          productId: orderLine.productId,\n          warehouseId: input.warehouseId,\n          quantity,\n          reference: input.reference || `DELIVERY:${orderCode}`,\n          note: input.note,\n          userId: input.userId,\n        });\n      }\n\n      // Update delivery status to completed\n      await tx\n        .update(sale_b2b_tb_deliveries)\n        .set({\n          status: \"completed\",\n          updatedAt: now,\n        })\n        .where(eq(sale_b2b_tb_deliveries.id, delivery.id));\n\n      return delivery;\n    });\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Delivery/DeliveryViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2b_tb_deliveries } from \"../../schemas\";\n\nclass DeliveryViewListModel extends BaseViewListModel<\n  typeof sale_b2b_tb_deliveries,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2b_tb_deliveries,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2b_tb_deliveries.id, sort: true }],\n      [\"orderType\", { column: sale_b2b_tb_deliveries.orderType, sort: true }],\n      [\"orderId\", { column: sale_b2b_tb_deliveries.orderId, sort: true }],\n      [\n        \"warehouseId\",\n        { column: sale_b2b_tb_deliveries.warehouseId, sort: true },\n      ],\n      [\n        \"deliveryDate\",\n        { column: sale_b2b_tb_deliveries.deliveryDate, sort: true },\n      ],\n      [\"reference\", { column: sale_b2b_tb_deliveries.reference, sort: true }],\n      [\"status\", { column: sale_b2b_tb_deliveries.status, sort: true }],\n      [\"createdAt\", { column: sale_b2b_tb_deliveries.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2b_tb_deliveries.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"reference\",\n        (text: string) => ilike(sale_b2b_tb_deliveries.reference, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    orderType: row.orderType,\n    orderId: row.orderId,\n    warehouseId: row.warehouseId ?? undefined,\n    deliveryDate: row.deliveryDate?.getTime(),\n    reference: row.reference ?? undefined,\n    note: row.note ?? undefined,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n    createdBy: row.createdBy ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default DeliveryViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Delivery/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Sale/SalesOrderB2BModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":45,"fix":{"range":[377,377],"text":"\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":104,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":104,"endColumn":19,"suggestions":[{"fix":{"range":[2735,2787],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type StockModel from \"@mdl/stock/server/models/Stock/StockModel\";\nimport type {\n  CreateSalesOrderB2BInput,\n  DeliverSalesOrderB2BInput,\n  SalesOrderB2BStatus,\n  UpdateSalesOrderB2BInput,\n} from \"../interfaces/SalesOrderB2B\";\nimport type {\n  NewSaleB2bTbOrder,\n  SaleB2bTbOrder,\n  SaleB2bTbOrderLine,\n} from \"../../schemas\";\n\nimport { desc, eq, sql } from \"drizzle-orm\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  base_tb_currencies,\n  base_tb_currencies_exchange_rate,\n} from \"@base/server/schemas\";\n\nimport {\n  sale_b2c_tb_currency_rates,\n  sale_b2b_tb_orders,\n  sale_b2b_tb_order_lines,\n} from \"../../schemas\";\n\nexport default class SalesOrderB2BModel extends BaseModel<\n  typeof sale_b2b_tb_orders\n> {\n  constructor() {\n    super(sale_b2b_tb_orders);\n  }\n\n  list = async (): Promise<SaleB2bTbOrder[]> => {\n    return this.db\n      .select()\n      .from(sale_b2b_tb_orders)\n      .orderBy(desc(sale_b2b_tb_orders.createdAt));\n  };\n\n  getById = async (id: string) => {\n    const [order] = await this.db\n      .select()\n      .from(sale_b2b_tb_orders)\n      .where(eq(sale_b2b_tb_orders.id, id))\n      .limit(1);\n\n    if (!order) {\n      return null;\n    }\n    const lines = await this.db\n      .select()\n      .from(sale_b2b_tb_order_lines)\n      .where(eq(sale_b2b_tb_order_lines.orderId, order.id));\n\n    return { order, lines };\n  };\n\n  create = async (input: CreateSalesOrderB2BInput) => {\n    if (!input.lines?.length) {\n      throw new Error(\"Sales order requires at least one line\");\n    }\n\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `SO-B2B-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    // Get currency rate\n    const currency = input.currency ?? \"USD\";\n    let currencyRate: number | undefined;\n\n    try {\n      const [currencyRecord] = await this.db\n        .select()\n        .from(base_tb_currencies)\n        .where(eq(base_tb_currencies.code, currency))\n        .limit(1);\n\n      if (currencyRecord) {\n        const [latestRate] = await this.db\n          .select()\n          .from(base_tb_currencies_exchange_rate)\n          .where(\n            eq(base_tb_currencies_exchange_rate.currencyId, currencyRecord.id),\n          )\n          .orderBy(desc(base_tb_currencies_exchange_rate.rateDate))\n          .limit(1);\n\n        if (latestRate?.exchangeRate) {\n          currencyRate = Number(latestRate.exchangeRate);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to get currency rate:\", error);\n    }\n\n    return this.db.transaction(async (tx) => {\n      let subtotal = 0;\n      let totalDiscount = input.totalDiscount ?? 0;\n      let totalTax = input.totalTax ?? 0;\n      const shippingFee = input.shippingFee ?? 0;\n\n      // Calculate line totals\n      const lineData: Array<{\n        productId: string;\n        quantity: number;\n        unitPrice: number;\n        description?: string;\n        lineDiscount: number;\n        taxRate: number;\n        lineSubtotal: number;\n        lineTax: number;\n        lineTotal: number;\n      }> = [];\n\n      for (const line of input.lines) {\n        const quantity = Number(line.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const unitPrice = Number(line.unitPrice ?? 0);\n        const lineDiscount = Number(line.lineDiscount ?? 0);\n        const taxRate = Number(line.taxRate ?? 0);\n\n        const lineSubtotal = quantity * unitPrice;\n        const lineTax = ((lineSubtotal - lineDiscount) * taxRate) / 100;\n        const lineTotal = lineSubtotal - lineDiscount + lineTax;\n\n        subtotal += lineSubtotal;\n        totalTax += lineTax;\n\n        lineData.push({\n          productId: line.productId,\n          quantity,\n          unitPrice,\n          description: line.description,\n          lineDiscount,\n          taxRate,\n          lineSubtotal,\n          lineTax,\n          lineTotal,\n        });\n      }\n\n      const grandTotal = subtotal - totalDiscount + totalTax + shippingFee;\n\n      const orderPayload: NewSaleB2bTbOrder = {\n        code: generatedCode,\n        companyName: input.companyName.trim(),\n        taxId: input.taxId,\n        contactPerson: input.contactPerson,\n        contactPhone: input.contactPhone,\n        contactEmail: input.contactEmail,\n        companyAddress: input.companyAddress,\n        paymentTermsId: input.paymentTermsId,\n        creditLimit: input.creditLimit?.toString(),\n        invoiceRequired: input.invoiceRequired ?? true,\n        shippingMethodId: input.shippingMethodId,\n        shippingTermsId: input.shippingTermsId,\n        status: \"draft\",\n        expectedDate: input.expectedDate\n          ? new Date(input.expectedDate)\n          : undefined,\n        warehouseId: input.warehouseId,\n        currency: currency,\n        currencyRate: currencyRate?.toString(),\n        notes: input.notes,\n        subtotal: subtotal.toString(),\n        totalDiscount: totalDiscount.toString(),\n        totalTax: totalTax.toString(),\n        shippingFee: shippingFee.toString(),\n        grandTotal: grandTotal.toString(),\n        totalAmount: grandTotal.toString(),\n        createdBy: input.userId,\n      };\n\n      const [order] = await tx\n        .insert(sale_b2b_tb_orders)\n        .values(orderPayload)\n        .returning();\n\n      // Save currency rate snapshot\n      if (currencyRate) {\n        await tx.insert(sale_b2c_tb_currency_rates).values({\n          orderType: \"B2B\",\n          orderId: order.id,\n          currencyCode: currency,\n          exchangeRate: currencyRate.toString(),\n          rateDate: now,\n          source: \"api\",\n        });\n      }\n\n      // Insert lines\n      for (const line of lineData) {\n        await tx.insert(sale_b2b_tb_order_lines).values({\n          orderId: order.id,\n          productId: line.productId,\n          description: line.description,\n          quantityOrdered: line.quantity.toString(),\n          quantityDelivered: \"0\",\n          unitPrice: line.unitPrice.toString(),\n          lineDiscount: line.lineDiscount.toString(),\n          taxRate: line.taxRate.toString(),\n          lineTax: line.lineTax.toString(),\n          lineSubtotal: line.lineSubtotal.toString(),\n          lineTotal: line.lineTotal.toString(),\n        });\n      }\n\n      await tx\n        .update(sale_b2b_tb_orders)\n        .set({\n          updatedAt: now,\n        })\n        .where(eq(sale_b2b_tb_orders.id, order.id));\n\n      const result = await this.getById(order.id);\n\n      if (!result) {\n        throw new Error(\"Failed to load sales order after creation\");\n      }\n\n      return result;\n    });\n  };\n\n  update = async (input: UpdateSalesOrderB2BInput) => {\n    const orderData = await this.getById(input.id);\n\n    if (!orderData) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    if (!input.lines?.length) {\n      throw new Error(\"Sales order requires at least one line\");\n    }\n\n    const now = new Date();\n    let subtotal = 0;\n    let totalDiscount =\n      input.totalDiscount ?? Number(orderData.order.totalDiscount);\n    let totalTax = input.totalTax ?? Number(orderData.order.totalTax);\n    const shippingFee =\n      input.shippingFee ?? Number(orderData.order.shippingFee);\n\n    // Calculate line totals\n    const lineData: Array<{\n      productId: string;\n      quantity: number;\n      unitPrice: number;\n      description?: string;\n      lineDiscount: number;\n      taxRate: number;\n      lineSubtotal: number;\n      lineTax: number;\n      lineTotal: number;\n    }> = [];\n\n    for (const line of input.lines) {\n      const quantity = Number(line.quantity ?? 0);\n\n      if (quantity <= 0) continue;\n\n      const unitPrice = Number(line.unitPrice ?? 0);\n      const lineDiscount = Number(line.lineDiscount ?? 0);\n      const taxRate = Number(line.taxRate ?? 0);\n\n      const lineSubtotal = quantity * unitPrice;\n      const lineTax = ((lineSubtotal - lineDiscount) * taxRate) / 100;\n      const lineTotal = lineSubtotal - lineDiscount + lineTax;\n\n      subtotal += lineSubtotal;\n      totalTax += lineTax;\n\n      lineData.push({\n        productId: line.productId,\n        quantity,\n        unitPrice,\n        description: line.description,\n        lineDiscount,\n        taxRate,\n        lineSubtotal,\n        lineTax,\n        lineTotal,\n      });\n    }\n\n    const grandTotal = subtotal - totalDiscount + totalTax + shippingFee;\n\n    return this.db.transaction(async (tx) => {\n      // Update order\n      const updatePayload: Partial<NewSaleB2bTbOrder> = {\n        companyName: input.companyName?.trim(),\n        taxId: input.taxId,\n        contactPerson: input.contactPerson,\n        contactPhone: input.contactPhone,\n        contactEmail: input.contactEmail,\n        companyAddress: input.companyAddress,\n        paymentTermsId: input.paymentTermsId,\n        creditLimit: input.creditLimit?.toString(),\n        invoiceRequired: input.invoiceRequired,\n        shippingMethodId: input.shippingMethodId,\n        shippingTermsId: input.shippingTermsId,\n        expectedDate: input.expectedDate\n          ? new Date(input.expectedDate)\n          : undefined,\n        warehouseId: input.warehouseId,\n        currency: input.currency,\n        notes: input.notes,\n        subtotal: subtotal.toString(),\n        totalDiscount: totalDiscount.toString(),\n        totalTax: totalTax.toString(),\n        shippingFee: shippingFee.toString(),\n        grandTotal: grandTotal.toString(),\n        totalAmount: grandTotal.toString(),\n        updatedAt: now,\n      };\n\n      await tx\n        .update(sale_b2b_tb_orders)\n        .set(updatePayload)\n        .where(eq(sale_b2b_tb_orders.id, input.id));\n\n      // Delete existing lines\n      await tx\n        .delete(sale_b2b_tb_order_lines)\n        .where(eq(sale_b2b_tb_order_lines.orderId, input.id));\n\n      // Insert new lines\n      for (const line of lineData) {\n        await tx.insert(sale_b2b_tb_order_lines).values({\n          orderId: input.id,\n          productId: line.productId,\n          description: line.description,\n          quantityOrdered: line.quantity.toString(),\n          quantityDelivered: \"0\",\n          unitPrice: line.unitPrice.toString(),\n          lineDiscount: line.lineDiscount.toString(),\n          taxRate: line.taxRate.toString(),\n          lineTax: line.lineTax.toString(),\n          lineSubtotal: line.lineSubtotal.toString(),\n          lineTotal: line.lineTotal.toString(),\n        });\n      }\n\n      return this.getById(input.id);\n    });\n  };\n\n  send = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(sale_b2b_tb_orders)\n      .set({\n        status: \"sent\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(sale_b2b_tb_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    return updated;\n  };\n\n  deliver = async (input: DeliverSalesOrderB2BInput) => {\n    const stockModel =\n      await RuntimeContext.getModelInstanceBy<StockModel>(\"stock\");\n\n    if (!stockModel) {\n      throw new Error(\"Stock model is not registered\");\n    }\n\n    const orderData = await this.getById(input.orderId);\n\n    if (!orderData) {\n      throw new Error(\"Sales order not found\");\n    }\n    const { order, lines } = orderData;\n\n    const defaultWarehouseId =\n      input.warehouseId ?? order.warehouseId ?? undefined;\n\n    if (!defaultWarehouseId) {\n      throw new Error(\"Warehouse is required to deliver sales order\");\n    }\n\n    const linesById = new Map<string, SaleB2bTbOrderLine>();\n\n    for (const line of lines) {\n      linesById.set(line.id, line);\n    }\n\n    const now = new Date();\n\n    await this.db.transaction(async (tx) => {\n      for (const deliveredLine of input.lines) {\n        const line = linesById.get(deliveredLine.lineId);\n\n        if (!line) {\n          throw new Error(`Sales order line ${deliveredLine.lineId} not found`);\n        }\n\n        const quantity = Number(deliveredLine.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const alreadyDelivered = Number(line.quantityDelivered ?? 0);\n        const orderedQty = Number(line.quantityOrdered ?? 0);\n        const nextDelivered = alreadyDelivered + quantity;\n\n        if (nextDelivered - orderedQty > 0.0001) {\n          throw new Error(\n            `Cannot deliver more than ordered for product ${line.productId}`,\n          );\n        }\n\n        await tx\n          .update(sale_b2b_tb_order_lines)\n          .set({\n            quantityDelivered: nextDelivered.toString(),\n            updatedAt: now,\n          })\n          .where(eq(sale_b2b_tb_order_lines.id, line.id));\n\n        await stockModel.issueStock({\n          productId: line.productId,\n          warehouseId: defaultWarehouseId,\n          quantity,\n          reference: `SO-B2B:${order.code}`,\n          note: input.note,\n          userId: input.userId,\n        });\n      }\n\n      const [sumRow] = await tx\n        .select({\n          undeliveredCount: sql`\n            count(*) FILTER (\n              WHERE ${sale_b2b_tb_order_lines.quantityOrdered} > ${sale_b2b_tb_order_lines.quantityDelivered}\n            )\n          `,\n        })\n        .from(sale_b2b_tb_order_lines)\n        .where(eq(sale_b2b_tb_order_lines.orderId, order.id));\n\n      const status: SalesOrderB2BStatus =\n        Number(sumRow?.undeliveredCount ?? 0) === 0 ? \"delivered\" : \"sent\";\n\n      await tx\n        .update(sale_b2b_tb_orders)\n        .set({\n          status,\n          warehouseId: defaultWarehouseId,\n          updatedAt: now,\n        })\n        .where(eq(sale_b2b_tb_orders.id, order.id));\n    });\n\n    return this.getById(order.id);\n  };\n\n  cancel = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(sale_b2b_tb_orders)\n      .set({\n        status: \"cancelled\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(sale_b2b_tb_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    return updated;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Sale/SalesOrderB2BViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2b_tb_orders } from \"../../schemas\";\n\nclass SalesOrderB2BViewListModel extends BaseViewListModel<\n  typeof sale_b2b_tb_orders,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2b_tb_orders,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2b_tb_orders.id, sort: true }],\n      [\"code\", { column: sale_b2b_tb_orders.code, sort: true }],\n      [\"companyName\", { column: sale_b2b_tb_orders.companyName, sort: true }],\n      [\"status\", { column: sale_b2b_tb_orders.status, sort: true }],\n      [\"warehouseId\", { column: sale_b2b_tb_orders.warehouseId, sort: true }],\n      [\"expectedDate\", { column: sale_b2b_tb_orders.expectedDate, sort: true }],\n      [\"grandTotal\", { column: sale_b2b_tb_orders.grandTotal, sort: true }],\n      [\"totalAmount\", { column: sale_b2b_tb_orders.totalAmount, sort: true }],\n      [\"currency\", { column: sale_b2b_tb_orders.currency, sort: true }],\n      [\"notes\", { column: sale_b2b_tb_orders.notes, sort: false }],\n      [\"createdAt\", { column: sale_b2b_tb_orders.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2b_tb_orders.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(sale_b2b_tb_orders.code, text)],\n      [\n        \"companyName\",\n        (text: string) => ilike(sale_b2b_tb_orders.companyName, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    companyName: row.companyName,\n    status: row.status,\n    warehouseId: row.warehouseId ?? undefined,\n    expectedDate: row.expectedDate?.getTime(),\n    grandTotal: row.grandTotal ?? \"0\",\n    totalAmount: row.totalAmount ?? \"0\",\n    currency: row.currency ?? \"USD\",\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default SalesOrderB2BViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/Sale/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/interfaces/Customer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/interfaces/MasterData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/interfaces/SalesOrderB2B.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/models/interfaces/SalesOrderB2C.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/b2b-sales.currency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/b2b-sales.customer.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":30,"fix":{"range":[144,144],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_payment_terms } from \"@base/server/schemas/base.payment-term\";\n\nimport { mdlSaleB2bSchema } from \"./schema\";\n\n// Customer Companies (B2B customers)\nexport const sale_b2c_tb_customer_companies = mdlSaleB2bSchema.table(\n  \"customers\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    name: varchar(\"name\", { length: 256 }).notNull(),\n    taxId: varchar(\"tax_id\", { length: 50 }),\n    address: text(\"address\"),\n    phone: varchar(\"phone\", { length: 20 }),\n    email: varchar(\"email\", { length: 255 }),\n    website: varchar(\"website\", { length: 255 }),\n    contactPerson: varchar(\"contact_person\", { length: 128 }),\n    creditLimit: numeric(\"credit_limit\", { precision: 14, scale: 2 }),\n    paymentTermsId: uuid(\"payment_terms_id\").references(\n      () => base_tb_payment_terms.id,\n      { onDelete: \"set null\" },\n    ),\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"customers_code_idx\").on(table.code),\n    index(\"customers_name_idx\").on(table.name),\n    index(\"customers_tax_id_idx\").on(table.taxId),\n    index(\"customers_active_idx\").on(table.isActive),\n  ],\n);\n\nexport type SaleB2cTbCustomerCompany =\n  typeof sale_b2c_tb_customer_companies.$inferSelect;\nexport type NewSaleB2cTbCustomerCompany =\n  typeof sale_b2c_tb_customer_companies.$inferInsert;\n\n// Customer Individuals (B2C customers) - Note: This should be in b2c-sales module\nexport const sale_b2c_tb_customers = mdlSaleB2bSchema.table(\n  \"customer_individuals\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    firstName: varchar(\"first_name\", { length: 128 }).notNull(),\n    lastName: varchar(\"last_name\", { length: 128 }).notNull(),\n    phone: varchar(\"phone\", { length: 20 }),\n    email: varchar(\"email\", { length: 255 }),\n    address: text(\"address\"),\n    dateOfBirth: timestamp(\"date_of_birth\", { withTimezone: true }),\n    gender: varchar(\"gender\", { length: 10 }), // 'male', 'female', 'other'\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"customer_individuals_code_idx\").on(table.code),\n    index(\"customer_individuals_name_idx\").on(table.firstName, table.lastName),\n    index(\"customer_individuals_phone_idx\").on(table.phone),\n    index(\"customer_individuals_email_idx\").on(table.email),\n    index(\"customer_individuals_active_idx\").on(table.isActive),\n  ],\n);\n\nexport type SaleB2cTbCustomer = typeof sale_b2c_tb_customers.$inferSelect;\nexport type NewSaleB2cTbCustomer = typeof sale_b2c_tb_customers.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/b2b-sales.delivery.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":87,"fix":{"range":[86,86],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/stock/server/schemas/stock.warehouse` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":87,"fix":{"range":[0,221],"text":"import { sql } from \"drizzle-orm\";\nimport {\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\nimport { sql } from \"drizzle-orm\";\nimport {\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { mdlSaleB2bSchema } from \"./schema\";\n\n// Sales Order Delivery - Track deliveries from orders (warehouse receipts)\nexport const sale_b2b_tb_deliveries = mdlSaleB2bSchema.table(\n  \"deliveries\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    orderType: varchar(\"order_type\", { length: 10 }).notNull(), // 'B2B' | 'B2C'\n    orderId: uuid(\"order_id\").notNull(),\n    warehouseId: uuid(\"warehouse_id\")\n      .notNull()\n      .references(() => stock_tb_stock_warehouses.id, { onDelete: \"restrict\" }),\n    deliveryDate: timestamp(\"delivery_date\", { withTimezone: true }).notNull(),\n    reference: varchar(\"reference\", { length: 128 }), // Reference number for the delivery\n    note: text(\"note\"),\n    status: varchar(\"status\", { length: 20 }).notNull().default(\"draft\"), // draft, completed, cancelled\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"deliveries_order_idx\").on(table.orderType, table.orderId),\n    index(\"deliveries_warehouse_idx\").on(table.warehouseId),\n    index(\"deliveries_date_idx\").on(table.deliveryDate),\n    index(\"deliveries_status_idx\").on(table.status),\n  ],\n);\n\nexport type SaleB2bTbDelivery = typeof sale_b2b_tb_deliveries.$inferSelect;\nexport type NewSaleB2bTbDelivery = typeof sale_b2b_tb_deliveries.$inferInsert;\n\n// Delivery Lines - Track which order lines are delivered\nexport const sale_b2b_tb_delivery_lines = mdlSaleB2bSchema.table(\n  \"delivery_lines\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    deliveryId: uuid(\"delivery_id\")\n      .notNull()\n      .references(() => sale_b2b_tb_deliveries.id, { onDelete: \"cascade\" }),\n    orderType: varchar(\"order_type\", { length: 10 }).notNull(), // 'B2B' | 'B2C'\n    orderLineId: uuid(\"order_line_id\").notNull(), // Reference to order line (B2B or B2C)\n    quantity: numeric(\"quantity\", { precision: 14, scale: 2 }).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => [\n    index(\"delivery_lines_delivery_idx\").on(table.deliveryId),\n    index(\"delivery_lines_order_line_idx\").on(\n      table.orderType,\n      table.orderLineId,\n    ),\n  ],\n);\n\nexport type SaleB2bTbDeliveryLine =\n  typeof sale_b2b_tb_delivery_lines.$inferSelect;\nexport type NewSaleB2bTbDeliveryLine =\n  typeof sale_b2b_tb_delivery_lines.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/b2b-sales.order-line.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":80,"fix":{"range":[114,114],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport { index, numeric, timestamp, uuid, varchar } from \"drizzle-orm/pg-core\";\nimport { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\n\nimport { mdlSaleB2bSchema } from \"./schema\";\nimport { sale_b2b_tb_orders } from \"./b2b-sales.order\";\n\nexport const sale_b2b_tb_order_lines = mdlSaleB2bSchema.table(\n  \"order_lines\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    orderId: uuid(\"order_id\")\n      .notNull()\n      .references(() => sale_b2b_tb_orders.id, { onDelete: \"cascade\" }),\n    productId: uuid(\"product_id\")\n      .notNull()\n      .references(() => product_tb_product_masters.id, {\n        onDelete: \"restrict\",\n      }),\n    description: varchar(\"description\", { length: 256 }),\n    quantityOrdered: numeric(\"quantity_ordered\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    quantityDelivered: numeric(\"quantity_delivered\", {\n      precision: 14,\n      scale: 2,\n    })\n      .notNull()\n      .default(\"0\"),\n    unitPrice: numeric(\"unit_price\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n\n    // Pricing fields\n    lineDiscount: numeric(\"line_discount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Fixed amount discount\n    taxRate: numeric(\"tax_rate\", { precision: 5, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Tax rate percentage\n    lineTax: numeric(\"line_tax\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Calculated tax amount\n    lineSubtotal: numeric(\"line_subtotal\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // quantity * unitPrice\n    lineTotal: numeric(\"line_total\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // lineSubtotal - lineDiscount + lineTax\n\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => [\n    index(\"order_lines_order_idx\").on(table.orderId),\n    index(\"order_lines_product_idx\").on(table.productId),\n  ],\n);\n\nexport type SaleB2bTbOrderLine = typeof sale_b2b_tb_order_lines.$inferSelect;\nexport type NewSaleB2bTbOrderLine = typeof sale_b2b_tb_order_lines.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/b2b-sales.order.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":82,"fix":{"range":[247,247],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/schemas/base.payment-term`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":35,"fix":{"range":[0,283],"text":"import { sql } from \"drizzle-orm\";\nimport { base_tb_payment_terms } from \"@base/server/schemas/base.payment-term\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":30,"fix":{"range":[392,392],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/server/schemas/base.payment-term`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":30,"fix":{"range":[0,393],"text":"import {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_payment_terms } from \"@base/server/schemas/base.payment-term\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\nimport { sql } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { base_tb_payment_terms } from \"@base/server/schemas/base.payment-term\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\nimport { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\n\nimport { mdlSaleB2bSchema } from \"./schema\";\n\nexport const sale_b2b_tb_orders = mdlSaleB2bSchema.table(\n  \"orders\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    status: varchar(\"status\", { length: 20 }).notNull().default(\"draft\"),\n\n    // B2B specific customer info\n    companyName: varchar(\"company_name\", { length: 256 }).notNull(),\n    taxId: varchar(\"tax_id\", { length: 50 }),\n    contactPerson: varchar(\"contact_person\", { length: 128 }),\n    contactPhone: varchar(\"contact_phone\", { length: 20 }),\n    contactEmail: varchar(\"contact_email\", { length: 255 }),\n    companyAddress: text(\"company_address\"),\n\n    // Business fields\n    paymentTermsId: uuid(\"payment_terms_id\").references(\n      () => base_tb_payment_terms.id,\n      { onDelete: \"set null\" },\n    ),\n    creditLimit: numeric(\"credit_limit\", { precision: 14, scale: 2 }),\n    invoiceRequired: boolean(\"invoice_required\").default(true).notNull(),\n    shippingMethodId: uuid(\"shipping_method_id\").references(\n      () => base_tb_shipping_methods.id,\n      { onDelete: \"set null\" },\n    ),\n    shippingTermsId: uuid(\"shipping_terms_id\").references(\n      () => base_tb_shipping_terms.id,\n      { onDelete: \"set null\" },\n    ),\n\n    // Common fields\n    warehouseId: uuid(\"warehouse_id\").references(\n      () => stock_tb_stock_warehouses.id,\n      { onDelete: \"set null\" },\n    ),\n    expectedDate: timestamp(\"expected_date\", { withTimezone: true }),\n\n    // Pricing fields\n    subtotal: numeric(\"subtotal\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalDiscount: numeric(\"total_discount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalTax: numeric(\"total_tax\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    shippingFee: numeric(\"shipping_fee\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    grandTotal: numeric(\"grand_total\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalAmount: numeric(\"total_amount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Alias for grandTotal for compatibility\n    currency: varchar(\"currency\", { length: 8 }).default(\"USD\"),\n    currencyRate: numeric(\"currency_rate\", { precision: 14, scale: 6 }),\n\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"orders_code_idx\").on(table.code),\n    index(\"orders_company_idx\").on(table.companyName),\n    index(\"orders_status_idx\").on(table.status),\n    index(\"orders_warehouse_idx\").on(table.warehouseId),\n    index(\"orders_expected_idx\").on(table.expectedDate),\n    index(\"orders_created_idx\").on(table.createdAt),\n  ],\n);\n\nexport type SaleB2bTbOrder = typeof sale_b2b_tb_orders.$inferSelect;\nexport type NewSaleB2bTbOrder = typeof sale_b2b_tb_orders.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2b-sales/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/interface/Customer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/interface/MasterData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/interface/SalesOrder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/interface/SalesOrderB2B.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/interface/SalesOrderB2C.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Customers/CustomerIndividualCreatePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Customers/CustomerIndividualEditPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Customers/CustomerIndividualViewPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Customers/CustomerIndividualsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { CustomerIndividual } from \"../../interface/Customer\";\n\ntype CustomerIndividualRow = CustomerIndividual & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function CustomerIndividualsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<CustomerIndividualRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: \"Code\",\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/b2c-sales/customers/individuals/view/${row.id}`}\n            >\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"firstName\",\n        label: \"First Name\",\n      },\n      {\n        key: \"lastName\",\n        label: \"Last Name\",\n        render: (_, row) => `${row.firstName} ${row.lastName}`,\n      },\n      {\n        key: \"phone\",\n        label: \"Phone\",\n      },\n      {\n        key: \"email\",\n        label: \"Email\",\n      },\n      {\n        key: \"isActive\",\n        label: \"Status\",\n        render: (_, row) => (\n          <Chip\n            color={row.isActive ? \"success\" : \"danger\"}\n            size=\"sm\"\n            variant=\"flat\"\n          >\n            {row.isActive ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"createdAt\",\n        label: \"Created\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2c-sales/customers/individuals/view/${row.id}`;\n          const editLink = `/workspace/modules/b2c-sales/customers/individuals/edit/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: \"Edit\",\n                  href: editLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<CustomerIndividualRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Individual\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2c-sales/customers/individuals/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2c-sales-customer-individual\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Deliveries/CreateDeliveryPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Deliveries/DeliveriesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\ntype DeliveryRow = {\n  id: string;\n  orderType: string;\n  orderId: string;\n  warehouseId?: string | null;\n  deliveryDate?: number | string | null;\n  reference?: string | null;\n  status: string;\n  createdAt?: number | string | null;\n};\n\nexport default function DeliveriesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<DeliveryRow>[]>(\n    () => [\n      {\n        key: \"reference\",\n        label: \"Reference\",\n        render: (value, row) => {\n          if (!row?.id) return value || \"-\";\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/b2c-sales/deliveries/view/${row.id}`}\n            >\n              {value || row.id.substring(0, 8)}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"orderType\",\n        label: \"Order Type\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"B2B\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"deliveryDate\",\n        label: \"Delivery Date\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"status\",\n        label: \"Status\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"createdAt\",\n        label: \"Created\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2c-sales/deliveries/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<DeliveryRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Delivery\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2c-sales/deliveries/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2c-sales-delivery\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/SalesOrderB2CCreatePage/SalesOrderB2CCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'orderDate' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport { salesOrderB2CService } from \"../../../services/SalesOrderB2CService\";\nimport SalesOrderB2CForm, {\n  type SalesOrderB2CFormValues,\n} from \"../components/SalesOrderB2BForm/SalesOrderB2CForm\";\nimport { SalesOrderB2BFormProvider } from \"../contexts/SalesOrderB2BFormContext\";\n\ntype SalesOrderB2CCreatePageClientProps = {\n  currency: string;\n  customerName: string;\n  orderDate: string;\n};\n\nexport default function SalesOrderB2CCreatePageClient({\n  currency,\n  customerName,\n  orderDate,\n}: SalesOrderB2CCreatePageClientProps): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n\n  const {\n    handleSubmit: submitOrder,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof salesOrderB2CService.create>[0],\n    { order: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await salesOrderB2CService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreateOrder\"));\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"b2c-sales-orders\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/b2c-sales/view/${data.order.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: SalesOrderB2CFormValues) => {\n    const payload = {\n      customerName: values.customerName.trim(),\n      priceListId: values.priceListId?.trim() || undefined,\n      deliveryAddress: values.deliveryAddress?.trim() || undefined,\n      paymentMethodId: values.paymentMethodId?.trim() || undefined,\n      shippingMethodId: values.shippingMethodId?.trim() || undefined,\n      shippingTermsId: values.shippingTermsId?.trim() || undefined,\n      requireInvoice: values.requireInvoice || false,\n      warehouseId: values.warehouseId?.trim() || undefined,\n      expectedDate: values.expectedDate?.trim() || undefined,\n      currency: currency,\n      notes: values.notes?.trim() || undefined,\n      totalDiscount: values.totalDiscount\n        ? Number(values.totalDiscount)\n        : undefined,\n      totalTax: values.totalTax ? Number(values.totalTax) : undefined,\n      shippingFee: values.shippingFee ? Number(values.shippingFee) : undefined,\n      lines: values.lines\n        .map((line) => ({\n          productId: line.productId.trim(),\n          unitId: line.unitId?.trim() || undefined,\n          quantity: Number(line.quantity),\n          unitPrice: line.unitPrice ? Number(line.unitPrice) : undefined,\n          description: line.description?.trim() || undefined,\n          lineDiscount: line.lineDiscount\n            ? Number(line.lineDiscount)\n            : undefined,\n          taxRate: line.taxRate ? Number(line.taxRate) : undefined,\n        }))\n        .filter((line) => line.productId && line.quantity > 0),\n    };\n\n    await submitOrder(payload);\n  };\n\n  return (\n    <SalesOrderB2BFormProvider page=\"create\">\n      <SalesOrderB2CForm\n        defaultValues={{\n          currency,\n          customerName,\n        }}\n        isSubmitting={isPending}\n        submitError={submitError}\n        onCancel={() => router.push(\"/workspace/modules/b2c-sales\")}\n        onSubmit={handleSubmit}\n      />\n    </SalesOrderB2BFormProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/SalesOrderB2CCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/SalesOrderB2CEditPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/SalesOrderB2CViewPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/SalesOrdersB2CListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { SalesOrderB2C } from \"../../interface/SalesOrderB2C\";\n\ntype SalesOrderB2CRow = SalesOrderB2C & {\n  expectedDate?: number | string | null;\n  createdAt?: number | string | null;\n  completedAt?: number | string | null;\n};\n\nexport default function SalesOrdersB2CListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"b2cSales.order.create.labels.list\");\n\n  const columns = useMemo<DataTableColumn<SalesOrderB2CRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/b2c-sales/view/${row.id}`}>\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"customerName\",\n        label: t(\"customerName\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"expectedDate\",\n        label: t(\"expectedDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"completedAt\",\n        label: t(\"completedAt\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"grandTotal\",\n        label: t(\"totalAmount\"),\n        render: (_, row) =>\n          new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: row.currency || \"USD\",\n          }).format(Number(row.grandTotal ?? 0)),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2c-sales/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<SalesOrderB2CRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"newOrder\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2c-sales/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2c-sales-order\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/CustomerInfoSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":34,"fix":{"range":[171,171],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":34,"fix":{"range":[15,522],"text":"import { Button } from \"@heroui/button\";\nimport { Checkbox, useDisclosure } from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { RefreshCwIcon } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo } from \"react\";\nimport { Control, Controller, useWatch } from \"react-hook-form\";\nimport {\n  DataTable,\n  DataTableColumn,\n  IBaseInput,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":41,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DataTable,\n  DataTableColumn,\n  IBaseInput,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Checkbox, useDisclosure } from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { RefreshCwIcon } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo } from \"react\";\nimport { Control, Controller, useWatch } from \"react-hook-form\";\n\nimport {\n  customerService,\n  type CustomerIndividualDto,\n} from \"../../../../services/CustomerService\";\n\ninterface CustomerInfoSectionProps {\n  control: Control<any>;\n  setValue: any;\n  selectedCustomer: CustomerIndividualDto | null;\n  setSelectedCustomer: (customer: CustomerIndividualDto | null) => void;\n  errors?: any;\n}\n\nconst DEFAULT_CUSTOMER_NAME = \"Khách lẻ\";\n\nexport default function CustomerInfoSection({\n  control,\n  setValue,\n  selectedCustomer,\n  setSelectedCustomer,\n  errors,\n}: CustomerInfoSectionProps) {\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n  const {\n    isOpen: isCustomerModalOpen,\n    onOpen: onCustomerModalOpen,\n    onClose: onCustomerModalClose,\n  } = useDisclosure();\n  const watchedCustomerName =\n    useWatch({ control, name: \"customerName\" }) || DEFAULT_CUSTOMER_NAME;\n  const isCustomerNotDefault = watchedCustomerName !== DEFAULT_CUSTOMER_NAME;\n\n  const customersQuery = useQuery({\n    queryKey: [\"customer-individuals\"],\n    queryFn: async () => {\n      const response = await customerService.listIndividuals();\n\n      return response.data ?? [];\n    },\n    enabled: isCustomerModalOpen,\n  });\n\n  const handleResetCustomer = useCallback(() => {\n    setValue(\"customerName\", DEFAULT_CUSTOMER_NAME);\n    setSelectedCustomer(null);\n  }, [setValue, setSelectedCustomer]);\n\n  const handleSelectCustomer = useCallback(\n    (customer: CustomerIndividualDto) => {\n      const fullName = `${customer.firstName} ${customer.lastName}`.trim();\n\n      setValue(\"customerName\", fullName);\n      setSelectedCustomer(customer);\n      onCustomerModalClose();\n    },\n    [setValue, setSelectedCustomer, onCustomerModalClose],\n  );\n\n  const customerColumns = useMemo<DataTableColumn<CustomerIndividualDto>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"code\"),\n      },\n      {\n        key: \"name\",\n        label: t(\"name\"),\n        render: (_, row) => `${row.firstName} ${row.lastName}`,\n      },\n      {\n        key: \"phone\",\n        label: t(\"phone\"),\n      },\n      {\n        key: \"actions\",\n        label: t(\"actions\"),\n        render: (_, row) => (\n          <Button\n            color=\"primary\"\n            size=\"sm\"\n            onPress={() => handleSelectCustomer(row)}\n          >\n            Chọn\n          </Button>\n        ),\n      },\n    ],\n    [handleSelectCustomer],\n  );\n\n  return (\n    <>\n      <div>\n        <h2 className=\"text-base font-semibold mb-2\">{t(\"customerInfo\")}</h2>\n        <div className=\" flex flex-col space-y-3\">\n          <div>\n            <Controller\n              control={control}\n              name=\"requireInvoice\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value}\n                  size=\"sm\"\n                  onValueChange={field.onChange}\n                >\n                  {t(\"requireInvoice\")}\n                </Checkbox>\n              )}\n            />\n          </div>\n\n          <div className=\"flex gap-2 justify-between items-end\">\n            <div className=\"flex-1\">\n              <Controller\n                control={control}\n                name=\"customerName\"\n                render={({ field, fieldState }) => (\n                  <div className=\"space-y-1\">\n                    <div className=\"flex gap-2\">\n                      <IBaseInput\n                        {...field}\n                        isRequired\n                        className=\"flex-1\"\n                        endContent={\n                          isCustomerNotDefault ? (\n                            <RefreshCwIcon\n                              className=\"text-primary cursor-pointer hover:text-orange-500\"\n                              size={16}\n                              onClick={handleResetCustomer}\n                            />\n                          ) : null\n                        }\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label={t(\"customerName\")}\n                        size=\"sm\"\n                        value={field.value}\n                        onValueChange={field.onChange}\n                      />\n                    </div>\n                  </div>\n                )}\n              />\n              {selectedCustomer?.phone && (\n                <p className=\"text-xs text-default-500\">\n                  Số điện thoại: {selectedCustomer.phone}\n                </p>\n              )}\n            </div>\n            <Button\n              color=\"primary\"\n              size=\"sm\"\n              variant=\"solid\"\n              onPress={onCustomerModalOpen}\n            >\n              {t(\"selectCustomer\")}\n            </Button>\n          </div>\n        </div>\n      </div>\n\n      {/* Customer Selection Modal */}\n      <Modal\n        isOpen={isCustomerModalOpen}\n        scrollBehavior=\"inside\"\n        size=\"3xl\"\n        onClose={onCustomerModalClose}\n      >\n        <ModalContent>\n          <ModalHeader>{t(\"selectCustomer\")}</ModalHeader>\n          <ModalBody>\n            <DataTable\n              columns={customerColumns}\n              dataSource={customersQuery.data ?? []}\n              loading={customersQuery.isLoading}\n              pagination={{ pageSize: 10, page: 1 }}\n              rowKey=\"id\"\n            />\n          </ModalBody>\n          <ModalFooter>\n            <Button variant=\"light\" onPress={onCustomerModalClose}>\n              {t(\"close\")}\n            </Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/DeliveryInfoSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[117,117],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[15,218],"text":"import { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\n\nimport { useSalesOrderB2BForm } from \"../../contexts/SalesOrderB2BFormContext\";\n\ninterface DeliveryInfoSectionProps {\n  control: Control<any>;\n  isShippingOtherThanPickup: boolean;\n  errors?: any;\n}\n\nexport default function DeliveryInfoSection({\n  control,\n  isShippingOtherThanPickup,\n  errors,\n}: DeliveryInfoSectionProps) {\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n  const { page } = useSalesOrderB2BForm();\n\n  return (\n    <div>\n      <h2 className=\"text-base font-semibold mb-2\">{t(\"deliveryInfo\")}</h2>\n      <div className=\"grid gap-2 md:grid-cols-2\">\n        <Controller\n          control={control}\n          name=\"paymentMethodId\"\n          render={({ field, fieldState }) => (\n            <IBaseSingleSelectAsync\n              isRequired\n              callWhen=\"mount\"\n              defaultParams={{ filters: { type: [\"b2c\", \"all\"] } }}\n              errorMessage={fieldState.error?.message}\n              isInvalid={fieldState.invalid}\n              label={t(\"paymentMethod\")}\n              model=\"payment-method\"\n              selectedKey={field.value}\n              size=\"sm\"\n              onSelectionChange={(key) => {\n                field.onChange(key || undefined);\n              }}\n              onTheFirstFetchSuccess={(data) => {\n                if (page === \"create\") {\n                  if (!field.value && data?.data?.length > 0) {\n                    // Prefer payment method with value 'CASH' if present; else fallback\n                    const cashItem = data.data.find(\n                      (item: any) => item.code === \"CASH\",\n                    );\n\n                    if (cashItem) {\n                      field.onChange(cashItem.value);\n                    } else {\n                      field.onChange(data?.data[0].value);\n                    }\n                  }\n                }\n              }}\n            />\n          )}\n        />\n        <Controller\n          control={control}\n          name=\"shippingMethodId\"\n          render={({ field, fieldState }) => (\n            <IBaseSingleSelectAsync\n              isRequired\n              callWhen=\"mount\"\n              defaultParams={{ filters: { type: [\"b2c\", \"all\"] } }}\n              errorMessage={fieldState.error?.message}\n              isInvalid={fieldState.invalid}\n              label={t(\"shippingMethod\")}\n              model=\"shipping-method\"\n              selectedKey={field.value}\n              size=\"sm\"\n              onSelectionChange={(key) => {\n                field.onChange(key || undefined);\n              }}\n              onTheFirstFetchSuccess={(data) => {\n                if (page === \"create\") {\n                  if (!field.value && data?.data?.length > 0) {\n                    // find pickup value in data.data\n                    const pickupValue = data.data.find(\n                      (item: any) => item.code === \"pickup\",\n                    );\n\n                    if (pickupValue) {\n                      field.onChange(pickupValue.value);\n                    } else {\n                      field.onChange(data.data[0].value);\n                    }\n                  }\n                }\n              }}\n            />\n          )}\n        />\n        {isShippingOtherThanPickup && (\n          <>\n            <Controller\n              control={control}\n              name=\"deliveryAddress\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={\n                    fieldState.error?.message ||\n                    (isShippingOtherThanPickup && !field.value?.trim()\n                      ? t(\"shippingAddressRequired\")\n                      : undefined)\n                  }\n                  isInvalid={\n                    fieldState.invalid ||\n                    (isShippingOtherThanPickup && !field.value?.trim())\n                  }\n                  isRequired={isShippingOtherThanPickup}\n                  label={t(\"shippingAddress\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n              rules={{\n                required: isShippingOtherThanPickup\n                  ? t(\"shippingAddressRequired\")\n                  : false,\n              }}\n            />\n            <Controller\n              control={control}\n              name=\"shippingFee\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  allowNegative={false}\n                  decimalPlaces={2}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"shippingFee\")}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ? Number(field.value) : 0}\n                  onValueChange={(val) =>\n                    field.onChange(val?.toString() ?? \"0\")\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"expectedDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"deliveryDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/GeneralInfoSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":66,"fix":{"range":[80,80],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":66,"fix":{"range":[15,181],"text":"import { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\nimport { IBaseSingleSelectAsync } from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { IBaseSingleSelectAsync } from \"@base/client/components\";\nimport { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\n\nimport { useSalesOrderB2BForm } from \"../../contexts/SalesOrderB2BFormContext\";\n\ninterface GeneralInfoSectionProps {\n  control: Control<any>;\n  createdAt?: string;\n  currency?: string;\n}\n\nexport default function GeneralInfoSection({\n  control,\n  createdAt,\n  currency,\n}: GeneralInfoSectionProps) {\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n  const { page } = useSalesOrderB2BForm();\n\n  return (\n    <div>\n      <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n      <div className=\"text-sm text-default-700 py-2 text-bold mb-3\">\n        {t(\"createdAt\")}: {createdAt || \"—\"}, {t(\"currency\")}: {currency}\n      </div>\n\n      <div className=\"grid gap-2 md:grid-cols-3\">\n        {/* Pricing */}\n        <Controller\n          control={control}\n          name=\"priceListId\"\n          render={({ field, fieldState }) => (\n            <IBaseSingleSelectAsync\n              isRequired\n              callWhen=\"mount\"\n              errorMessage={fieldState.error?.message}\n              isInvalid={fieldState.invalid}\n              label={t(\"pricing\")}\n              model=\"b2c-sales-price-list\"\n              selectedKey={field.value}\n              size=\"sm\"\n              onSelectionChange={(key) => {\n                field.onChange(key || undefined);\n              }}\n              onTheFirstFetchSuccess={(data) => {\n                if (page === \"create\") {\n                  if (!field.value && data?.data?.length > 0) {\n                    field.onChange(data.data[0].value);\n                  }\n                }\n              }}\n            />\n          )}\n        />\n\n        <Controller\n          control={control}\n          name=\"warehouseId\"\n          render={({ field, fieldState }) => (\n            <IBaseSingleSelectAsync\n              isRequired\n              callWhen=\"mount\"\n              errorMessage={fieldState.error?.message}\n              isInvalid={fieldState.invalid}\n              label={t(\"warehouse\")}\n              model=\"b2c-sales-warehouse\"\n              selectedKey={field.value}\n              onSelectionChange={(key) => {\n                field.onChange(key || undefined);\n              }}\n              onTheFirstFetchSuccess={(data) => {\n                if (page === \"create\") {\n                  if (!field.value && data?.data?.length > 0) {\n                    field.onChange(data.data[0].value);\n                  }\n                }\n              }}\n            />\n          )}\n        />\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/OrderLinesSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,516],"text":"import ClientHttpService from \"@base/client/services/ClientHttpService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Trash2 } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useEffect, useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":73,"fix":{"range":[217,217],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services/ClientHttpService` import should occur after import of `react-hook-form`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":73,"fix":{"range":[145,516],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Trash2 } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useEffect, useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\nimport ClientHttpService from \"@base/client/services/ClientHttpService\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uomOptions' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":47,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":13},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":22,"suggestions":[{"fix":{"range":[2931,2975],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'line' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":137,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport ClientHttpService from \"@base/client/services/ClientHttpService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Trash2 } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useEffect, useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\n\nimport { ProductMasterFeatures } from \"@mdl/product/client/interface/Product\";\n\ninterface OrderLinesSectionProps {\n  control: Control<any>;\n  fields: any[];\n  append: (line: any) => void;\n  remove: (index: number) => void;\n  watchedLines: any[];\n  watchedCurrency: string;\n  watchedPriceListId?: string;\n  taxRateOptions: SelectItemOption[];\n  taxRatesQuery: { isLoading: boolean };\n  uomOptions: SelectItemOption[];\n  errors?: any;\n  defaultLine: any;\n  setValue: UseFormSetValue<any>;\n}\n\nconst pricingService = new ClientHttpService(\"/api/base/price-lists\");\n\nexport default function OrderLinesSection({\n  control,\n  fields,\n  append,\n  remove,\n  watchedLines,\n  watchedCurrency,\n  watchedPriceListId,\n  taxRateOptions,\n  taxRatesQuery,\n  uomOptions,\n  errors,\n  defaultLine,\n  setValue,\n}: OrderLinesSectionProps) {\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n  const DEFAULT_CURRENCY = \"VND\";\n\n  // Auto-calculate price when product, quantity, or priceListId changes\n  useEffect(() => {\n    if (!watchedPriceListId) return;\n\n    watchedLines.forEach(async (line, index) => {\n      const productId = line.productId;\n      const quantity = Number(line.quantity) || 0;\n\n      if (!productId || quantity <= 0) return;\n\n      try {\n        // Call calculate-price API\n        // Note: productId is assumed to be variantId, we'll need productMasterId too\n        // For now, we'll use productId as both variantId and masterId\n        const response = await pricingService.post<{\n          data: {\n            unitPrice: number;\n            basePrice: number;\n            discountAmount: number;\n            finalPrice: number;\n            priceSource: string;\n          };\n        }>(\"/calculate-price\", {\n          productVariantId: productId,\n          productMasterId: productId, // TODO: Get actual masterId from product\n          quantity,\n          priceListId: watchedPriceListId,\n        });\n\n        if (response?.data) {\n          const priceData = response.data;\n          // Only auto-fill if unitPrice is not manually set or is 0\n          const currentPrice = Number(line.unitPrice) || 0;\n\n          if (currentPrice === 0 || currentPrice === 1) {\n            setValue(\n              `lines.${index}.unitPrice`,\n              priceData.finalPrice.toString(),\n            );\n          }\n        }\n      } catch (error) {\n        // Silently fail - user can enter price manually\n        console.error(\"Không thể tính giá:\", error);\n      }\n    });\n  }, [watchedPriceListId, watchedLines, setValue]);\n\n  // Calculate line totals for each line\n  const lineTotals = useMemo(() => {\n    return watchedLines.map((line) => {\n      const quantity = Number(line.quantity) || 0;\n      const unitPrice = Number(line.unitPrice) || 0;\n      const lineDiscount = Number(line.lineDiscount) || 0;\n      const taxRate = Number(line.taxRate) || 0;\n      const lineSubtotal = quantity * unitPrice;\n      const amount = lineSubtotal - lineDiscount; // Amount after discount\n      const lineTax = (amount * taxRate) / 100;\n      const lineTotal = amount + lineTax;\n\n      return {\n        lineSubtotal,\n        lineDiscount,\n        amount,\n        lineTax,\n        lineTotal,\n      };\n    });\n  }, [watchedLines]);\n\n  const formatCurrency = (value: number) => {\n    return new Intl.NumberFormat(undefined, {\n      style: \"currency\",\n      currency: watchedCurrency || DEFAULT_CURRENCY,\n    }).format(value);\n  };\n\n  return (\n    <div className=\"space-y-3\">\n      <h2 className=\"text-base font-semibold mb-2\">{t(\"orderLines\")}</h2>\n\n      {fields.map((fieldItem, index) => {\n        const line = watchedLines[index];\n        const totals = lineTotals[index] || {\n          lineSubtotal: 0,\n          lineDiscount: 0,\n          amount: 0,\n          lineTax: 0,\n          lineTotal: 0,\n        };\n\n        return (\n          <Card key={fieldItem.id} className=\"border border-content3/40\">\n            <CardBody className=\"p-3 space-y-2\">\n              {/* Header with line number and remove button */}\n              <div className=\"flex items-center justify-between pb-1\">\n                <h3 className=\"text-xs font-medium text-default-500\">\n                  {t(\"line\")} {index + 1}\n                </h3>\n                <Button\n                  isIconOnly\n                  aria-label={t(\"removeLine\")}\n                  className=\"min-w-6 h-6\"\n                  color=\"danger\"\n                  isDisabled={fields.length === 1}\n                  size=\"sm\"\n                  variant=\"light\"\n                  onPress={() => remove(index)}\n                >\n                  <Trash2 size={14} />\n                </Button>\n              </div>\n\n              {/* Input Fields */}\n              <div className=\"grid gap-2 grid-cols-1 md:grid-cols-3 lg:flex\">\n                {/* Product - flex-grow on lg, full width on md */}\n                <div className=\"md:col-span-3 lg:flex-1 lg:min-w-[200px]\">\n                  <Controller\n                    control={control}\n                    name={`lines.${index}.productId`}\n                    render={({ field, fieldState }) => (\n                      <IBaseSingleSelectAsync\n                        isRequired\n                        defaultParams={{\n                          filters: {\n                            isActive: true,\n                            features: [ProductMasterFeatures.SALE],\n                          },\n                        }}\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label={t(\"product\")}\n                        model=\"product.dropdown\"\n                        selectedKey={field.value}\n                        size=\"sm\"\n                        onRenderOption={(item: any) => {\n                          return (\n                            <div className=\"flex flex-col igap-2\">\n                              <div>{item.localizedLabel}</div>\n                              <div className=\"text-xs text-default-500\">\n                                SKU: {item.sku} - Barcode: {item.barcode}\n                              </div>\n                            </div>\n                          );\n                        }}\n                        onSelectionChange={(key) => {\n                          field.onChange(key || undefined);\n                        }}\n                      />\n                    )}\n                  />\n                </div>\n\n                {/* Quantity - fixed width on lg */}\n                <div className=\"md:col-span-1 lg:w-[120px] lg:flex-shrink-0\">\n                  <Controller\n                    control={control}\n                    name={`lines.${index}.quantity`}\n                    render={({ field, fieldState }) => (\n                      <IBaseInputNumber\n                        isRequired\n                        allowNegative={false}\n                        decimalPlaces={2}\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label={t(\"quantity\")}\n                        max={5000}\n                        min={0}\n                        size=\"sm\"\n                        value={field.value ? Number(field.value) : null}\n                        onValueChange={(val) =>\n                          field.onChange(val?.toString() ?? \"\")\n                        }\n                      />\n                    )}\n                  />\n                </div>\n\n                {/* Unit Price - fixed width on lg */}\n                <div className=\"md:col-span-1 lg:w-[160px] lg:flex-shrink-0\">\n                  <Controller\n                    control={control}\n                    name={`lines.${index}.unitPrice`}\n                    render={({ field, fieldState }) => (\n                      <IBaseInputNumber\n                        allowNegative={false}\n                        decimalPlaces={2}\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label={t(\"unitPrice\")}\n                        max={100000000}\n                        min={0}\n                        size=\"sm\"\n                        value={field.value ? Number(field.value) : null}\n                        onValueChange={(val) =>\n                          field.onChange(val?.toString() ?? \"\")\n                        }\n                      />\n                    )}\n                  />\n                </div>\n\n                {/* Discount - fixed width on lg */}\n                <div className=\"md:col-span-1 lg:w-[200px] lg:flex-shrink-0\">\n                  <Controller\n                    control={control}\n                    name={`lines.${index}.lineDiscount`}\n                    render={({ field, fieldState }) => {\n                      const line = watchedLines[index];\n                      const quantity = Number(line?.quantity) || 0;\n                      const unitPrice = Number(line?.unitPrice) || 0;\n                      const maxDiscount = quantity * unitPrice;\n                      const currentDiscount = Number(field.value) || 0;\n                      const isDiscountExceeded = currentDiscount > maxDiscount;\n\n                      return (\n                        <IBaseInputNumber\n                          allowNegative={false}\n                          decimalPlaces={2}\n                          errorMessage={\n                            fieldState.error?.message ||\n                            (isDiscountExceeded\n                              ? t(\"errors.discountExceeded\", {\n                                  max: maxDiscount.toLocaleString(),\n                                })\n                              : undefined)\n                          }\n                          isInvalid={fieldState.invalid || isDiscountExceeded}\n                          label={t(\"discount\")}\n                          max={maxDiscount}\n                          min={0}\n                          size=\"sm\"\n                          value={field.value ? Number(field.value) : null}\n                          onValueChange={(val) =>\n                            field.onChange(val?.toString() ?? \"\")\n                          }\n                        />\n                      );\n                    }}\n                  />\n                </div>\n\n                {/* Tax Rate - fixed width on lg */}\n                <div className=\"md:col-span-1 lg:w-[150px] lg:flex-shrink-0\">\n                  <Controller\n                    control={control}\n                    name={`lines.${index}.taxRate`}\n                    render={({ field, fieldState }) => (\n                      <IBaseSingleSelect\n                        errorMessage={fieldState.error?.message}\n                        isDisabled={taxRatesQuery.isLoading}\n                        isInvalid={fieldState.invalid}\n                        items={taxRateOptions}\n                        label={t(\"taxRate\")}\n                        selectedKey={field.value}\n                        size=\"sm\"\n                        onSelectionChange={(key) => {\n                          field.onChange(key || \"0\");\n                        }}\n                      />\n                    )}\n                  />\n                </div>\n              </div>\n\n              <Divider className=\"my-1\" />\n\n              {/* Line Summary */}\n              <div className=\"bg-content2 rounded-lg py-1 px-2\">\n                <div className=\"grid grid-cols-4 gap-2 text-xs\">\n                  <div>\n                    <span className=\"text-default-500 text-xs\">\n                      {t(\"subtotal\")}:\n                    </span>\n                    <p className=\"font-medium text-sm\">\n                      {formatCurrency(totals.lineSubtotal)}\n                    </p>\n                  </div>\n                  <div>\n                    <span className=\"text-default-500 text-xs\">\n                      {t(\"discount\")}:\n                    </span>\n                    <p className=\"font-medium text-sm text-danger\">\n                      -{formatCurrency(totals.lineDiscount)}\n                    </p>\n                  </div>\n                  <div>\n                    <span className=\"text-default-500 text-xs\">\n                      {t(\"taxAmount\")}:\n                    </span>\n                    <p className=\"font-medium text-sm\">\n                      {formatCurrency(totals.lineTax)}\n                    </p>\n                  </div>\n                  <div className=\"text-right\">\n                    <span className=\"text-default-500 text-xs\">\n                      {t(\"total\")}:\n                    </span>\n                    <p className=\"font-semibold text-primary text-base\">\n                      {formatCurrency(totals.lineTotal)}\n                    </p>\n                  </div>\n                </div>\n              </div>\n            </CardBody>\n          </Card>\n        );\n      })}\n\n      <div className=\"flex justify-end\">\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          variant=\"solid\"\n          onPress={() => append(defaultLine)}\n        >\n          {t(\"addLine\")}\n        </Button>\n      </div>\n\n      {errors?.lines?.message ? (\n        <p className=\"text-sm text-danger-600\">\n          {errors.lines.message as string}\n        </p>\n      ) : null}\n\n      {fields.length === 0 && (\n        <div className=\"text-center py-8 text-default-500\">\n          {t(\"noOrderLines\")}\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/OrderTotalsSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[74,74],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[15,216],"text":"import { Divider } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\nimport { IBaseInputNumber } from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { IBaseInputNumber } from \"@base/client/components\";\nimport { Divider } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { Control, Controller } from \"react-hook-form\";\n\ninterface OrderTotalsSectionProps {\n  control: Control<any>;\n  calculatedTotals: {\n    subtotal: number;\n    totalLineDiscount: number;\n    totalLineTax: number;\n    orderDiscount: number;\n    orderTax: number;\n    shipping: number;\n    grandTotal: number;\n  };\n  watchedCurrency: string;\n  isShippingOtherThanPickup: boolean;\n  errors?: any;\n}\n\nconst DEFAULT_CURRENCY = \"VND\";\n\nexport default function OrderTotalsSection({\n  control,\n  calculatedTotals,\n  watchedCurrency,\n  isShippingOtherThanPickup,\n  errors,\n}: OrderTotalsSectionProps) {\n  const t = useTranslations(\"b2cSales.order.create.labels\");\n  const formatCurrency = (value: number) => {\n    return new Intl.NumberFormat(undefined, {\n      style: \"currency\",\n      currency: watchedCurrency || DEFAULT_CURRENCY,\n    }).format(value);\n  };\n\n  return (\n    <div>\n      <h2 className=\"text-base font-semibold mb-2\">{t(\"orderTotals\")}</h2>\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        {/* Left Column: Order Discount, Tax and Details */}\n        <div className=\"space-y-3\">\n          <div className=\"grid gap-2\">\n            <Controller\n              control={control}\n              name=\"totalDiscount\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  allowNegative={false}\n                  decimalPlaces={2}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"orderDiscount\")}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ? Number(field.value) : 0}\n                  onValueChange={(val) =>\n                    field.onChange(val?.toString() ?? \"0\")\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"totalTax\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  allowNegative={false}\n                  decimalPlaces={2}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"orderTax\")}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ? Number(field.value) : 0}\n                  onValueChange={(val) =>\n                    field.onChange(val?.toString() ?? \"0\")\n                  }\n                />\n              )}\n            />\n          </div>\n        </div>\n\n        {/* Right Column: Summary */}\n        <div className=\"flex flex-col justify-center\">\n          <div className=\"p-4 bg-content2 rounded-lg border-l-4 border-primary space-y-1\">\n            <div className=\"flex justify-between items-center\">\n              <span className=\"text-sm text-default-600\">{t(\"subtotal\")}:</span>\n              <span className=\"text-lg font-semibold\">\n                {formatCurrency(calculatedTotals.subtotal)}\n              </span>\n            </div>\n            {/* Details Breakdown */}\n            <div className=\"flex justify-between text-xs text-default-500\">\n              <span>{t(\"lineDiscounts\")}:</span>\n              <span>{formatCurrency(calculatedTotals.totalLineDiscount)}</span>\n            </div>\n            <div className=\"flex justify-between text-xs text-default-500\">\n              <span>{t(\"orderDiscount\")}:</span>\n              <span>{formatCurrency(calculatedTotals.orderDiscount)}</span>\n            </div>\n            <div className=\"flex justify-between text-xs text-default-500\">\n              <span>{t(\"lineTaxes\")}:</span>\n              <span>{formatCurrency(calculatedTotals.totalLineTax)}</span>\n            </div>\n            <div className=\"flex justify-between text-xs text-default-500\">\n              <span>{t(\"orderTax\")}:</span>\n              <span>{formatCurrency(calculatedTotals.orderTax)}</span>\n            </div>\n            {isShippingOtherThanPickup && (\n              <div className=\"flex justify-between text-xs text-default-500\">\n                <span>{t(\"shippingFee\")}:</span>\n                <span>{formatCurrency(calculatedTotals.shipping)}</span>\n              </div>\n            )}\n            <Divider />\n            <div className=\"flex justify-between items-center\">\n              <span className=\"text-base font-semibold\">\n                {t(\"grandTotal\")}:\n              </span>\n              <span className=\"text-2xl font-bold text-primary\">\n                {formatCurrency(calculatedTotals.grandTotal)}\n              </span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/components/SalesOrderB2BForm/SalesOrderB2CForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":60,"fix":{"range":[170,170],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `@heroui/react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":60,"fix":{"range":[111,701],"text":"import { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo, useState } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  paymentMethodService,\n  shippingMethodService,\n  shippingTermService,\n  taxRateService,\n} from \"@base/client/services\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { SelectItemOption } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":26,"fix":{"range":[470,470],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":32,"fix":{"range":[601,601],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/services` import should occur after import of `@heroui/react`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":32,"fix":{"range":[471,701],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport {\n  paymentMethodService,\n  shippingMethodService,\n  shippingTermService,\n  taxRateService,\n} from \"@base/client/services\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":23,"column":1,"nodeType":"ImportDeclaration","endLine":23,"endColumn":58,"fix":{"range":[700,700],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getValues' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":67,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'warehousesQuery' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":134,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shippingTermsQuery' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":166,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'defaultPaymentMethod' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":194,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":6,"source":"\"use client\";\n\nimport type { SalesOrderB2CFormValues } from \"../../validation/createSalesOrderB2CValidation\";\n\nimport { SelectItemOption } from \"@base/client/components\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo, useState } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  paymentMethodService,\n  shippingMethodService,\n  shippingTermService,\n  taxRateService,\n} from \"@base/client/services\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport UnitOfMeasureService from \"@mdl/product/client/services/UnitOfMeasureService\";\nimport StockService from \"@mdl/stock/client/services/StockService\";\n\nimport { type CustomerIndividualDto } from \"../../../../services/CustomerService\";\nimport { createSalesOrderB2CValidation } from \"../../validation/createSalesOrderB2CValidation\";\n\nimport CustomerInfoSection from \"./CustomerInfoSection\";\nimport DeliveryInfoSection from \"./DeliveryInfoSection\";\nimport GeneralInfoSection from \"./GeneralInfoSection\";\nimport OrderLinesSection from \"./OrderLinesSection\";\nimport OrderTotalsSection from \"./OrderTotalsSection\";\n\n// Re-export for backward compatibility\nexport type { SalesOrderB2CFormValues };\n\ninterface SalesOrderB2CFormProps {\n  onSubmit: (values: SalesOrderB2CFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<SalesOrderB2CFormValues>;\n}\n\nexport default function SalesOrderB2CForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: SalesOrderB2CFormProps) {\n  const t = useTranslations(\"b2cSales.order.create.validation\");\n  const tLabels = useTranslations(\"b2cSales.order.create.labels\");\n  const [selectedCustomer, setSelectedCustomer] =\n    useState<CustomerIndividualDto | null>(null);\n\n  // Create validation schemas with translation\n  const validation = useMemo(() => createSalesOrderB2CValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    watch,\n    setValue,\n    getValues,\n    formState: { errors },\n  } = useForm<SalesOrderB2CFormValues>({\n    resolver: valibotResolver(validation.salesOrderB2CFormSchema) as any,\n    defaultValues: {\n      lines: [validation.defaultLine],\n      ...defaultValues,\n    },\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: \"lines\",\n  });\n\n  const watchedLines = watch(\"lines\");\n  const watchedPriceListId = watch(\"priceListId\");\n  const watchedCurrency = watch(\"currency\");\n  const watchedShippingMethodId = watch(\"shippingMethodId\");\n  const watchedTotalDiscount = watch(\"totalDiscount\") || \"0\";\n  const watchedTotalTax = watch(\"totalTax\") || \"0\";\n  const watchedShippingFee = watch(\"shippingFee\") || \"0\";\n\n  // Calculate totals\n  const calculatedTotals = useMemo(() => {\n    let subtotal = 0;\n    let totalLineDiscount = 0;\n    let totalLineTax = 0;\n\n    watchedLines.forEach((line) => {\n      const quantity = Number(line.quantity) || 0;\n      const unitPrice = Number(line.unitPrice) || 0;\n      const lineDiscount = Number(line.lineDiscount) || 0;\n      const taxRate = Number(line.taxRate) || 0;\n\n      const lineSubtotal = quantity * unitPrice;\n      const lineTax = ((lineSubtotal - lineDiscount) * taxRate) / 100;\n\n      subtotal += lineSubtotal;\n      totalLineDiscount += lineDiscount;\n      totalLineTax += lineTax;\n    });\n\n    const orderDiscount = Number(watchedTotalDiscount) || 0;\n    const orderTax = Number(watchedTotalTax) || 0;\n    const shipping = Number(watchedShippingFee) || 0;\n\n    const grandTotal =\n      subtotal -\n      totalLineDiscount -\n      orderDiscount +\n      totalLineTax +\n      orderTax +\n      shipping;\n\n    return {\n      subtotal,\n      totalLineDiscount,\n      totalLineTax,\n      orderDiscount,\n      orderTax,\n      shipping,\n      grandTotal,\n    };\n  }, [watchedLines, watchedTotalDiscount, watchedTotalTax, watchedShippingFee]);\n\n  // Load master data\n  const warehousesQuery = useQuery({\n    queryKey: [\"warehouses\"],\n    queryFn: async () => {\n      const response = await StockService.listWarehouses();\n\n      // Filter only internal warehouses\n      return (response.data ?? []).filter(\n        (wh) =>\n          wh.typeCode?.toUpperCase() === \"INTERNAL\" ||\n          wh.typeCode?.toUpperCase().includes(\"INTERNAL\"),\n      );\n    },\n  });\n\n  const paymentMethodsQuery = useQuery({\n    queryKey: [\"payment-methods-dropdown\"],\n    queryFn: async () => {\n      const response = await paymentMethodService.getOptionsDropdown();\n\n      return response.data ?? [];\n    },\n  });\n\n  const shippingMethodsQuery = useQuery({\n    queryKey: [\"shipping-methods-dropdown\"],\n    queryFn: async () => {\n      const response = await shippingMethodService.getOptionsDropdown();\n\n      return response.data ?? [];\n    },\n  });\n\n  const shippingTermsQuery = useQuery({\n    queryKey: [\"shipping-terms-dropdown\"],\n    queryFn: async () => {\n      const response = await shippingTermService.getOptionsDropdown();\n\n      return response.data ?? [];\n    },\n  });\n\n  const taxRatesQuery = useQuery({\n    queryKey: [\"tax-rates-dropdown\"],\n    queryFn: async () => {\n      const response = await taxRateService.getOptionsDropdown();\n\n      return response.data ?? [];\n    },\n  });\n\n  const uomQuery = useQuery({\n    queryKey: [\"units-of-measure\"],\n    queryFn: async () => {\n      const response = await UnitOfMeasureService.getList();\n\n      return response.data ?? [];\n    },\n  });\n\n  // Find default payment method (Cash/Tiền mặt)\n  const defaultPaymentMethod = useMemo(() => {\n    if (!paymentMethodsQuery.data) return undefined;\n\n    return paymentMethodsQuery.data.find(\n      (pm) =>\n        pm.code?.toLowerCase().includes(\"cash\") ||\n        (typeof pm.name === \"object\" &&\n          (pm.name.vi?.toLowerCase().includes(\"tiền mặt\") ||\n            pm.name.en?.toLowerCase().includes(\"cash\"))) ||\n        (typeof pm.name === \"string\" && pm.name.toLowerCase().includes(\"cash\")),\n    );\n  }, [paymentMethodsQuery.data]);\n\n  // Find default shipping method (Pickup/Tự nhận)\n  const defaultShippingMethod = useMemo(() => {\n    if (!shippingMethodsQuery.data) return undefined;\n\n    return shippingMethodsQuery.data.find(\n      (sm) =>\n        sm.code?.toLowerCase().includes(\"pickup\") ||\n        (typeof sm.name === \"object\" &&\n          (sm.name.vi?.toLowerCase().includes(\"tự nhận\") ||\n            sm.name.en?.toLowerCase().includes(\"pickup\"))) ||\n        (typeof sm.name === \"string\" &&\n          sm.name.toLowerCase().includes(\"pickup\")),\n    );\n  }, [shippingMethodsQuery.data]);\n\n  // Check if shipping method is not pickup\n  const isShippingOtherThanPickup = useMemo(() => {\n    if (!watchedShippingMethodId || !defaultShippingMethod) return false;\n\n    return watchedShippingMethodId !== defaultShippingMethod.value;\n  }, [watchedShippingMethodId, defaultShippingMethod]);\n\n  const onSubmitForm: SubmitHandler<SalesOrderB2CFormValues> = async (\n    values,\n  ) => {\n    // Validate delivery address if shipping is not pickup\n    if (isShippingOtherThanPickup && !values.deliveryAddress?.trim()) {\n      setValue(\"deliveryAddress\", \"\", { shouldValidate: true });\n\n      return;\n    }\n\n    await onSubmit(values);\n  };\n\n  // Format server time for display\n  const formattedCreatedAt = useMemo(() => {\n    const now = new Date();\n\n    return now.toLocaleString(\"vi-VN\", {\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n    });\n  }, []);\n\n  const taxRateOptions = useMemo<SelectItemOption[]>(\n    () =>\n      (taxRatesQuery.data ?? []).map((tr) => {\n        // Extract rate from name if available, otherwise use value\n        const rate = tr.rate || tr.name?.rate || \"\";\n        const label = rate ? `${tr.label} (${rate}%)` : tr.label;\n\n        return {\n          value: tr.value,\n          label,\n        };\n      }),\n    [taxRatesQuery.data],\n  );\n\n  const uomOptions = useMemo<SelectItemOption[]>(\n    () =>\n      (uomQuery.data ?? [])\n        .filter((uom) => uom.isActive)\n        .map((uom) => {\n          const name = (uom.name as any)?.vi || (uom.name as any)?.en || \"\";\n          const label = uom.symbol ? `${name} (${uom.symbol})` : name;\n\n          return {\n            value: uom.id,\n            label,\n          };\n        }),\n    [uomQuery.data],\n  );\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      {/* Action Buttons - Sticky */}\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tLabels(\"cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tLabels(\"createOrder\")}\n        </Button>\n      </div>\n\n      {/* Section: Thông tin chung */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <GeneralInfoSection\n            control={control}\n            createdAt={formattedCreatedAt}\n            currency={watchedCurrency}\n          />\n        </CardBody>\n      </Card>\n\n      {/* Section: Order Lines */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <OrderLinesSection\n            append={append}\n            control={control}\n            defaultLine={validation.defaultLine}\n            errors={errors}\n            fields={fields}\n            remove={remove}\n            setValue={setValue}\n            taxRateOptions={taxRateOptions}\n            taxRatesQuery={taxRatesQuery}\n            uomOptions={uomOptions}\n            watchedCurrency={watchedCurrency}\n            watchedLines={watchedLines}\n            watchedPriceListId={watchedPriceListId}\n          />\n        </CardBody>\n      </Card>\n\n      {/* Section: Thông tin giao hàng */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <DeliveryInfoSection\n            control={control}\n            errors={errors}\n            isShippingOtherThanPickup={isShippingOtherThanPickup}\n          />\n        </CardBody>\n      </Card>\n\n      {/* Order Totals */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <OrderTotalsSection\n            calculatedTotals={calculatedTotals}\n            control={control}\n            errors={errors}\n            isShippingOtherThanPickup={isShippingOtherThanPickup}\n            watchedCurrency={watchedCurrency}\n          />\n        </CardBody>\n      </Card>\n\n      {/* Section: Thông tin khách hàng */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <CustomerInfoSection\n            control={control}\n            errors={errors}\n            selectedCustomer={selectedCustomer}\n            setSelectedCustomer={setSelectedCustomer}\n            setValue={setValue}\n          />\n        </CardBody>\n      </Card>\n\n      {/* Notes */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <Controller\n            control={control}\n            name=\"notes\"\n            render={({ field, fieldState }) => (\n              <Textarea\n                {...field}\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label={tLabels(\"notes\")}\n                minRows={2}\n                size=\"sm\"\n                value={field.value ?? \"\"}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/contexts/SalesOrderB2BFormContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/validation/SalesOrderB2CCreateValid.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/Orders/validation/createSalesOrderB2CValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/PriceListB2CCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `valibot`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[15,470],"text":"import { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { array, object, optional, pipe, string, trim } from \"valibot\";\nimport { SelectItemOption } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":70,"fix":{"range":[144,144],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `valibot`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":70,"fix":{"range":[75,470],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { array, object, optional, pipe, string, trim } from \"valibot\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { SelectItemOption } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { array, object, optional, pipe, string, trim } from \"valibot\";\n\nimport {\n  priceListB2CService,\n  type CreatePriceListB2CParams,\n} from \"../../services/PriceListB2CService\";\n\nimport PriceListForm from \"./components/PriceListForm\";\n\nconst priceItemSchema = object({\n  productId: pipe(string(), trim()),\n  variantId: optional(pipe(string(), trim())),\n  unitPrice: pipe(string(), trim()),\n});\n\nconst priceListFormSchema = object({\n  code: pipe(string(), trim()),\n  name: object({\n    en: optional(pipe(string(), trim())),\n    vi: optional(pipe(string(), trim())),\n  }),\n  description: optional(pipe(string(), trim())),\n  type: pipe(string(), trim()),\n  status: pipe(string(), trim()),\n  priority: optional(pipe(string(), trim())),\n  currencyId: optional(pipe(string(), trim())),\n  validFrom: pipe(string(), trim()),\n  validTo: optional(pipe(string(), trim())),\n  isDefault: optional(string()),\n  applicableTo: object({\n    channels: optional(array(string())),\n    stores: optional(array(string())),\n    locations: optional(array(string())),\n    regions: optional(array(string())),\n    customerGroups: optional(array(string())),\n  }),\n  priceItems: optional(array(priceItemSchema)),\n});\n\ntype PriceListFormValues = {\n  code: string;\n  name: {\n    en?: string;\n    vi?: string;\n  };\n  description?: string;\n  type: string;\n  status: string;\n  priority?: string;\n  currencyId?: string;\n  validFrom: string;\n  validTo?: string;\n  isDefault?: string;\n  applicableTo: {\n    channels?: string[];\n    stores?: string[];\n    locations?: string[];\n    regions?: string[];\n    customerGroups?: string[];\n  };\n  priceItems?: Array<{\n    productId: string;\n    variantId?: string;\n    unitPrice: string;\n  }>;\n};\n\nexport default function PriceListB2CCreatePage(): React.ReactNode {\n  const router = useRouter();\n  const { mutate: createPriceList, isPending } = useCreateUpdate({\n    mutationFn: async (data: CreatePriceListB2CParams) => {\n      return await priceListB2CService.create(data);\n    },\n    onSuccess: () => {\n      router.push(\"/workspace/modules/b2c-sales/price-lists\");\n    },\n  });\n\n  const methods = useForm<PriceListFormValues>({\n    resolver: valibotResolver(priceListFormSchema) as any,\n    defaultValues: {\n      code: \"\",\n      name: {\n        en: \"\",\n        vi: \"\",\n      },\n      description: \"\",\n      type: \"standard\",\n      status: \"active\",\n      priority: \"0\",\n      currencyId: undefined,\n      validFrom: new Date().toISOString().split(\"T\")[0],\n      validTo: undefined,\n      isDefault: \"false\",\n      applicableTo: {\n        channels: undefined,\n        stores: undefined,\n        locations: undefined,\n        regions: undefined,\n        customerGroups: undefined,\n      },\n      priceItems: [],\n    },\n  });\n\n  const {\n    control,\n    setValue,\n    handleSubmit,\n    formState: { errors },\n  } = methods;\n\n  const onSubmit = (data: PriceListFormValues) => {\n    const applicableTo: any = {};\n\n    if (data.applicableTo.channels && data.applicableTo.channels.length > 0) {\n      applicableTo.channels = data.applicableTo.channels;\n    }\n    if (data.applicableTo.stores && data.applicableTo.stores.length > 0) {\n      applicableTo.stores = data.applicableTo.stores;\n    }\n    if (data.applicableTo.locations && data.applicableTo.locations.length > 0) {\n      applicableTo.locations = data.applicableTo.locations;\n    }\n    if (data.applicableTo.regions && data.applicableTo.regions.length > 0) {\n      applicableTo.regions = data.applicableTo.regions;\n    }\n    if (\n      data.applicableTo.customerGroups &&\n      data.applicableTo.customerGroups.length > 0\n    ) {\n      applicableTo.customerGroups = data.applicableTo.customerGroups;\n    }\n\n    const payload: CreatePriceListB2CParams = {\n      code: data.code,\n      name: {\n        en: data.name.en || \"\",\n        vi: data.name.vi || \"\",\n      },\n      description: data.description,\n      type: data.type as any,\n      status: data.status as any,\n      priority: data.priority ? parseInt(data.priority) : 0,\n      currencyId: data.currencyId,\n      validFrom: data.validFrom,\n      validTo: data.validTo || null,\n      isDefault: data.isDefault === \"true\",\n      applicableTo:\n        Object.keys(applicableTo).length > 0 ? applicableTo : undefined,\n    };\n\n    // Add price items if any\n    if (data.priceItems && data.priceItems.length > 0) {\n      // Note: Price items will be created separately via API\n      // For now, we'll just create the price list\n    }\n\n    createPriceList(payload);\n  };\n\n  const typeOptions: SelectItemOption[] = [\n    { value: \"standard\", label: \"Standard\" },\n    { value: \"promotion\", label: \"Promotion\" },\n    { value: \"seasonal\", label: \"Seasonal\" },\n    { value: \"flash_sale\", label: \"Flash Sale\" },\n  ];\n\n  const statusOptions: SelectItemOption[] = [\n    { value: \"draft\", label: \"Draft\" },\n    { value: \"active\", label: \"Active\" },\n  ];\n\n  // Sample options for applicableTo (should be loaded from API in real app)\n  const channelOptions: SelectItemOption[] = [\n    { value: \"online\", label: \"Online\" },\n    { value: \"offline\", label: \"Offline\" },\n    { value: \"mobile_app\", label: \"Mobile App\" },\n  ];\n\n  const locationOptions: SelectItemOption[] = [\n    { value: \"hcm\", label: \"Ho Chi Minh City\" },\n    { value: \"hn\", label: \"Hanoi\" },\n    { value: \"dn\", label: \"Da Nang\" },\n  ];\n\n  const regionOptions: SelectItemOption[] = [\n    { value: \"north\", label: \"North\" },\n    { value: \"south\", label: \"South\" },\n    { value: \"central\", label: \"Central\" },\n  ];\n\n  const customerGroupOptions: SelectItemOption[] = [\n    { value: \"vip\", label: \"VIP\" },\n    { value: \"regular\", label: \"Regular\" },\n  ];\n\n  const storeOptions: SelectItemOption[] = [];\n  const productOptions: SelectItemOption[] = [];\n\n  return (\n    <div className=\"space-y-4\">\n      <Card>\n        <CardBody>\n          <FormProvider {...methods}>\n            <form className=\"space-y-4\" onSubmit={handleSubmit(onSubmit)}>\n              <PriceListForm\n                brandOptions={[]}\n                categoryOptions={[]}\n                channelOptions={channelOptions}\n                control={control}\n                customerGroupOptions={customerGroupOptions}\n                errors={errors}\n                locationOptions={locationOptions}\n                productOptions={productOptions}\n                regionOptions={regionOptions}\n                setValue={setValue}\n                statusOptions={statusOptions}\n                storeOptions={storeOptions}\n                typeOptions={typeOptions}\n              />\n              <div className=\"flex gap-2 justify-end pt-4\">\n                <Button\n                  type=\"button\"\n                  variant=\"light\"\n                  onPress={() => router.back()}\n                >\n                  Cancel\n                </Button>\n                <Button color=\"primary\" isLoading={isPending} type=\"submit\">\n                  Create\n                </Button>\n              </div>\n            </form>\n          </FormProvider>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/PriceListB2CEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `valibot`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":60,"fix":{"range":[15,524],"text":"import { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { object, optional, pipe, string, trim } from \"valibot\";\nimport { SelectItemOption } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":70,"fix":{"range":[144,144],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `valibot`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":70,"fix":{"range":[75,524],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { object, optional, pipe, string, trim } from \"valibot\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { SelectItemOption } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useForm, FormProvider } from \"react-hook-form\";\nimport { object, optional, pipe, string, trim } from \"valibot\";\n\nimport {\n  priceListB2CService,\n  type UpdatePriceListB2CParams,\n} from \"../../services/PriceListB2CService\";\n\nimport PriceListForm from \"./components/PriceListForm\";\n\nconst priceListFormSchema = object({\n  code: pipe(string(), trim()),\n  nameEn: pipe(string(), trim()),\n  nameVi: pipe(string(), trim()),\n  description: optional(pipe(string(), trim())),\n  type: pipe(string(), trim()),\n  status: pipe(string(), trim()),\n  priority: optional(pipe(string(), trim())),\n  currencyId: optional(pipe(string(), trim())),\n  validFrom: pipe(string(), trim()),\n  validTo: optional(pipe(string(), trim())),\n  isDefault: optional(string()),\n  applicableTo: object({\n    channels: optional(string()),\n    stores: optional(string()),\n    locations: optional(string()),\n    regions: optional(string()),\n    customerGroups: optional(string()),\n  }),\n});\n\ntype PriceListFormValues = {\n  code: string;\n  nameEn: string;\n  nameVi: string;\n  description?: string;\n  type: string;\n  status: string;\n  priority?: string;\n  currencyId?: string;\n  validFrom: string;\n  validTo?: string;\n  isDefault?: string;\n  applicableTo: {\n    channels?: string;\n    stores?: string;\n    locations?: string;\n    regions?: string;\n    customerGroups?: string;\n  };\n};\n\nexport default function PriceListB2CEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n\n  const { data: priceList, isLoading } = useQuery({\n    queryKey: [\"price-list-b2c\", id],\n    queryFn: async () => {\n      const response = await priceListB2CService.getById(id);\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const { mutate: updatePriceList, isPending } = useCreateUpdate({\n    mutationFn: async (data: UpdatePriceListB2CParams) => {\n      return await priceListB2CService.update(data);\n    },\n    onSuccess: () => {\n      router.push(\"/workspace/modules/b2c-sales/price-lists\");\n    },\n  });\n\n  const name =\n    typeof priceList?.name === \"object\" ? priceList.name : { en: \"\", vi: \"\" };\n\n  const methods = useForm<PriceListFormValues>({\n    resolver: valibotResolver(priceListFormSchema) as any,\n    defaultValues: {\n      code: \"\",\n      nameEn: \"\",\n      nameVi: \"\",\n      description: \"\",\n      type: \"standard\",\n      status: \"active\",\n      priority: \"0\",\n      currencyId: undefined,\n      validFrom: new Date().toISOString().split(\"T\")[0],\n      validTo: undefined,\n      isDefault: \"false\",\n      applicableTo: {\n        channels: \"\",\n        stores: \"\",\n        locations: \"\",\n        regions: \"\",\n        customerGroups: \"\",\n      },\n    },\n  });\n\n  const {\n    control,\n    setValue,\n    handleSubmit,\n    formState: { errors },\n    reset,\n  } = methods;\n\n  // Reset form when priceList loads\n  if (priceList && !isLoading) {\n    const applicableTo = priceList.applicableTo || {};\n\n    reset({\n      code: priceList.code,\n      nameEn: name.en || \"\",\n      nameVi: name.vi || \"\",\n      description: priceList.description || \"\",\n      type: priceList.type,\n      status: priceList.status,\n      priority: String(priceList.priority),\n      currencyId: priceList.currencyId || undefined,\n      validFrom: priceList.validFrom\n        ? new Date(priceList.validFrom).toISOString().split(\"T\")[0]\n        : new Date().toISOString().split(\"T\")[0],\n      validTo: priceList.validTo\n        ? new Date(priceList.validTo).toISOString().split(\"T\")[0]\n        : undefined,\n      isDefault: priceList.isDefault ? \"true\" : \"false\",\n      applicableTo: {\n        channels: applicableTo.channels?.join(\", \") || \"\",\n        stores: applicableTo.stores?.join(\", \") || \"\",\n        locations: applicableTo.locations?.join(\", \") || \"\",\n        regions: applicableTo.regions?.join(\", \") || \"\",\n        customerGroups: applicableTo.customerGroups?.join(\", \") || \"\",\n      },\n    });\n  }\n\n  const onSubmit = (data: PriceListFormValues) => {\n    const applicableTo: any = {};\n\n    if (data.applicableTo.channels) {\n      applicableTo.channels = data.applicableTo.channels\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n    if (data.applicableTo.stores) {\n      applicableTo.stores = data.applicableTo.stores\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n    if (data.applicableTo.locations) {\n      applicableTo.locations = data.applicableTo.locations\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n    if (data.applicableTo.regions) {\n      applicableTo.regions = data.applicableTo.regions\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n    if (data.applicableTo.customerGroups) {\n      applicableTo.customerGroups = data.applicableTo.customerGroups\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n\n    updatePriceList({\n      id,\n      name: { en: data.nameEn, vi: data.nameVi },\n      description: data.description,\n      type: data.type as any,\n      status: data.status as any,\n      priority: data.priority ? parseInt(data.priority) : undefined,\n      currencyId: data.currencyId,\n      validFrom: data.validFrom,\n      validTo: data.validTo || null,\n      isDefault: data.isDefault === \"true\",\n      applicableTo,\n    });\n  };\n\n  const typeOptions: SelectItemOption[] = [\n    { value: \"standard\", label: \"Standard\" },\n    { value: \"promotion\", label: \"Promotion\" },\n    { value: \"seasonal\", label: \"Seasonal\" },\n    { value: \"flash_sale\", label: \"Flash Sale\" },\n  ];\n\n  const statusOptions: SelectItemOption[] = [\n    { value: \"draft\", label: \"Draft\" },\n    { value: \"active\", label: \"Active\" },\n    { value: \"inactive\", label: \"Inactive\" },\n    { value: \"expired\", label: \"Expired\" },\n  ];\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!priceList) {\n    return <div>Price list not found</div>;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <h1 className=\"text-2xl font-bold\">Edit Price List</h1>\n      <Card>\n        <CardBody>\n          <FormProvider {...methods}>\n            <form className=\"space-y-4\" onSubmit={handleSubmit(onSubmit)}>\n              <PriceListForm\n                control={control}\n                errors={errors}\n                isEdit={true}\n                setValue={setValue}\n                statusOptions={statusOptions}\n                typeOptions={typeOptions}\n              />\n              <div className=\"flex gap-2 justify-end\">\n                <Button\n                  type=\"button\"\n                  variant=\"light\"\n                  onPress={() => router.back()}\n                >\n                  Cancel\n                </Button>\n                <Button color=\"primary\" isLoading={isPending} type=\"submit\">\n                  Update\n                </Button>\n              </div>\n            </form>\n          </FormProvider>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/PriceListB2CViewPage.tsx","messages":[{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":46,"column":19,"nodeType":"JSXOpeningElement","endLine":46,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":50,"column":19,"nodeType":"JSXOpeningElement","endLine":50,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":54,"column":19,"nodeType":"JSXOpeningElement","endLine":54,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":58,"column":19,"nodeType":"JSXOpeningElement","endLine":58,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":62,"column":19,"nodeType":"JSXOpeningElement","endLine":62,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":66,"column":19,"nodeType":"JSXOpeningElement","endLine":66,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":70,"column":19,"nodeType":"JSXOpeningElement","endLine":70,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":80,"column":19,"nodeType":"JSXOpeningElement","endLine":80,"endColumn":60},{"ruleId":"jsx-a11y/label-has-associated-control","severity":2,"message":"A form label must be associated with a control.","line":85,"column":17,"nodeType":"JSXOpeningElement","endLine":85,"endColumn":58}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport { Card, CardBody, Tab, Tabs } from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams } from \"next/navigation\";\n\nimport { priceListB2CService } from \"../../services/PriceListB2CService\";\n\nexport default function PriceListB2CViewPage(): React.ReactNode {\n  const params = useParams();\n  const id = params.id as string;\n\n  const { data: priceList, isLoading } = useQuery({\n    queryKey: [\"price-list-b2c\", id],\n    queryFn: async () => {\n      const response = await priceListB2CService.getById(id);\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!priceList) {\n    return <div>Price list not found</div>;\n  }\n\n  const name =\n    typeof priceList.name === \"object\" ? priceList.name : { en: \"\", vi: \"\" };\n  const applicableTo = priceList.applicableTo || {};\n\n  return (\n    <div className=\"space-y-4\">\n      <h1 className=\"text-2xl font-bold\">\n        {name.vi || name.en || priceList.code}\n      </h1>\n      <Tabs>\n        <Tab key=\"info\" title=\"Information\">\n          <Card>\n            <CardBody className=\"space-y-4\">\n              <div className=\"grid gap-4 md:grid-cols-2\">\n                <div>\n                  <label className=\"text-sm font-semibold\">Code</label>\n                  <p>{priceList.code}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Type</label>\n                  <p className=\"capitalize\">{priceList.type}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Status</label>\n                  <p className=\"capitalize\">{priceList.status}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Priority</label>\n                  <p>{priceList.priority}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Is Default</label>\n                  <p>{priceList.isDefault ? \"Yes\" : \"No\"}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Valid From</label>\n                  <p>{new Date(priceList.validFrom).toLocaleDateString()}</p>\n                </div>\n                <div>\n                  <label className=\"text-sm font-semibold\">Valid To</label>\n                  <p>\n                    {priceList.validTo\n                      ? new Date(priceList.validTo).toLocaleDateString()\n                      : \"Forever\"}\n                  </p>\n                </div>\n              </div>\n              {priceList.description && (\n                <div>\n                  <label className=\"text-sm font-semibold\">Description</label>\n                  <p>{priceList.description}</p>\n                </div>\n              )}\n              <div>\n                <label className=\"text-sm font-semibold\">Applicable To</label>\n                <div className=\"mt-2 space-y-1\">\n                  {applicableTo.channels &&\n                    applicableTo.channels.length > 0 && (\n                      <p>\n                        <strong>Channels:</strong>{\" \"}\n                        {applicableTo.channels.join(\", \")}\n                      </p>\n                    )}\n                  {applicableTo.stores && applicableTo.stores.length > 0 && (\n                    <p>\n                      <strong>Stores:</strong> {applicableTo.stores.join(\", \")}\n                    </p>\n                  )}\n                  {applicableTo.locations &&\n                    applicableTo.locations.length > 0 && (\n                      <p>\n                        <strong>Locations:</strong>{\" \"}\n                        {applicableTo.locations.join(\", \")}\n                      </p>\n                    )}\n                  {applicableTo.regions && applicableTo.regions.length > 0 && (\n                    <p>\n                      <strong>Regions:</strong>{\" \"}\n                      {applicableTo.regions.join(\", \")}\n                    </p>\n                  )}\n                  {applicableTo.customerGroups &&\n                    applicableTo.customerGroups.length > 0 && (\n                      <p>\n                        <strong>Customer Groups:</strong>{\" \"}\n                        {applicableTo.customerGroups.join(\", \")}\n                      </p>\n                    )}\n                </div>\n              </div>\n            </CardBody>\n          </Card>\n        </Tab>\n        <Tab key=\"items\" title=\"Price List Items\">\n          <Card>\n            <CardBody>\n              <p className=\"text-gray-500\">\n                Price list items management will be implemented here.\n              </p>\n            </CardBody>\n          </Card>\n        </Tab>\n        <Tab key=\"rules\" title=\"Pricing Rules\">\n          <Card>\n            <CardBody>\n              <p className=\"text-gray-500\">\n                Pricing rules management will be implemented here.\n              </p>\n            </CardBody>\n          </Card>\n        </Tab>\n      </Tabs>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/PriceListsB2CListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { PriceListB2CDto } from \"../../services/PriceListB2CService\";\n\ntype PriceListB2CRow = PriceListB2CDto & {\n  validFrom?: number | string | null;\n  validTo?: number | string | null;\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function PriceListsB2CListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<PriceListB2CRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: \"Code\",\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/b2c-sales/price-lists/view/${row.id}`}\n            >\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: \"Name\",\n        render: (value) => {\n          if (typeof value === \"object\" && value !== null) {\n            return value.vi || value.en || \"\";\n          }\n\n          return value || \"\";\n        },\n      },\n      {\n        key: \"type\",\n        label: \"Type\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"standard\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"status\",\n        label: \"Status\",\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"isDefault\",\n        label: \"Default\",\n        render: (value) => (value ? \"Yes\" : \"No\"),\n      },\n      {\n        key: \"validFrom\",\n        label: \"Valid From\",\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"validTo\",\n        label: \"Valid To\",\n        render: (value) => (value ? formatDate(value) : \"Forever\"),\n      },\n      {\n        key: \"priority\",\n        label: \"Priority\",\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/b2c-sales/price-lists/view/${row.id}`;\n          const editLink = `/workspace/modules/b2c-sales/price-lists/edit/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: \"Edit\",\n                  href: editLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<PriceListB2CRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Price List\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/b2c-sales/price-lists/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"b2c-sales-price-list\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/components/ExplicitPricingTab.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[217,217],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[90,737],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport ProductService from \"@mdl/product/client/services/ProductService\";\nimport UnitOfMeasureService from \"@mdl/product/client/services/UnitOfMeasureService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Edit2, Plus, Trash2 } from \"lucide-react\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport {\n  Control,\n  useFieldArray,\n  useFormContext,\n  UseFormSetValue,\n  useWatch,\n} from \"react-hook-form\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTable,\n  IBaseInputSearch,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":48,"fix":{"range":[306,306],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/product/client/services/ProductService` import should occur after import of `react-hook-form`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":74,"fix":{"range":[307,737],"text":"import UnitOfMeasureService from \"@mdl/product/client/services/UnitOfMeasureService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Edit2, Plus, Trash2 } from \"lucide-react\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport {\n  Control,\n  useFieldArray,\n  useFormContext,\n  UseFormSetValue,\n  useWatch,\n} from \"react-hook-form\";\nimport ProductService from \"@mdl/product/client/services/ProductService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":86,"fix":{"range":[466,466],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/product/client/services/UnitOfMeasureService` import should occur after import of `react-hook-form`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":86,"fix":{"range":[381,737],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { Edit2, Plus, Trash2 } from \"lucide-react\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport {\n  Control,\n  useFieldArray,\n  useFormContext,\n  UseFormSetValue,\n  useWatch,\n} from \"react-hook-form\";\nimport UnitOfMeasureService from \"@mdl/product/client/services/UnitOfMeasureService\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":58,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setError' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":60,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":19},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":409,"column":44,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click &quot;Add Product\" to add one.\n        "},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click &ldquo;Add Product\" to add one.\n        "},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click &#34;Add Product\" to add one.\n        "},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click &rdquo;Add Product\" to add one.\n        "},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":409,"column":56,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click \"Add Product&quot; to add one.\n        "},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click \"Add Product&ldquo; to add one.\n        "},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click \"Add Product&#34; to add one.\n        "},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[11249,11327],"text":"\n          No explicit pricing items. Click \"Add Product&rdquo; to add one.\n        "},"desc":"Replace with `&rdquo;`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":6,"source":"\"use client\";\n\nimport type { DataTableColumnDefinition } from \"@base/client/components\";\n\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTable,\n  IBaseInputSearch,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport ProductService from \"@mdl/product/client/services/ProductService\";\nimport UnitOfMeasureService from \"@mdl/product/client/services/UnitOfMeasureService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Edit2, Plus, Trash2 } from \"lucide-react\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport {\n  Control,\n  useFieldArray,\n  useFormContext,\n  UseFormSetValue,\n  useWatch,\n} from \"react-hook-form\";\n\nimport PriceItemEditModal from \"./PriceItemEditModal\";\n\ninterface ExplicitPricingTabProps {\n  control: Control<any>;\n  setValue: UseFormSetValue<any>;\n  errors?: any;\n}\n\ninterface ProductVariantOption {\n  id: string;\n  name: string | { en?: string; vi?: string };\n  sku?: string;\n  saleUomId?: string;\n  baseUomId?: string;\n}\n\ninterface PriceItemRow {\n  id: string;\n  variantId: string;\n  variantName: string;\n  variantSku?: string;\n  uomId: string;\n  uomName: string;\n  minimumQuantity: string;\n  unitPrice: string;\n  index: number;\n  isDuplicate?: boolean;\n}\n\nexport default function ExplicitPricingTab({\n  control,\n  setValue,\n  errors,\n}: ExplicitPricingTabProps) {\n  const { setError } = useFormContext();\n  const {\n    fields: priceItemFields,\n    prepend: prependPriceItem,\n    remove: removePriceItem,\n  } = useFieldArray({\n    control,\n    name: \"priceItems\",\n  });\n\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [editingIndex, setEditingIndex] = useState<number | null>(null);\n\n  // Load products with sale feature\n  const productsQuery = useQuery({\n    queryKey: [\"products-with-sale-feature\"],\n    queryFn: async () => {\n      const response = await ProductService.getProductList({\n        page: 1,\n        pageSize: 1000,\n        filters: {\n          \"master.features.sale\": true,\n          \"master.isActive\": true,\n          \"variant.isActive\": true,\n        },\n      });\n\n      return response.data || [];\n    },\n  });\n\n  // Load UOMs\n  const uomQuery = useQuery({\n    queryKey: [\"uoms\"],\n    queryFn: async () => {\n      const response = await UnitOfMeasureService.getList();\n\n      return response.data || [];\n    },\n  });\n\n  // Build variant options from products\n  const variantOptions = useMemo<SelectItemOption[]>(() => {\n    if (!productsQuery.data) return [];\n\n    const variants: ProductVariantOption[] = [];\n\n    productsQuery.data.forEach((product: any) => {\n      if (product.variant) {\n        const variantName =\n          typeof product.variant.name === \"object\"\n            ? product.variant.name.vi ||\n              product.variant.name.en ||\n              product.variant.sku ||\n              product.variant.id\n            : product.variant.name || product.variant.sku || product.variant.id;\n\n        variants.push({\n          id: product.variant.id,\n          name: variantName,\n          sku: product.variant.sku,\n          saleUomId: product.variant.saleUomId,\n          baseUomId: product.variant.baseUomId,\n        });\n      }\n    });\n\n    return variants.map((variant) => ({\n      value: variant.id,\n      label: variant.sku\n        ? `${variant.name} (${variant.sku})`\n        : String(variant.name),\n      saleUomId:\n        typeof variant.saleUomId === \"string\" ? variant.saleUomId : undefined,\n      baseUomId:\n        typeof variant.baseUomId === \"string\" ? variant.baseUomId : undefined,\n    }));\n  }, [productsQuery.data]);\n\n  // Build UOM options\n  const uomOptions = useMemo<SelectItemOption[]>(() => {\n    if (!uomQuery.data) return [];\n\n    return uomQuery.data\n      .filter((uom) => uom.isActive)\n      .map((uom) => {\n        let name = \"\";\n\n        if (uom.name) {\n          if (typeof uom.name === \"object\" && uom.name !== null) {\n            const nameObj = uom.name as { vi?: string; en?: string };\n\n            name = nameObj.vi || nameObj.en || \"\";\n          } else if (typeof uom.name === \"string\") {\n            name = uom.name;\n          }\n        }\n        const label = uom.symbol ? `${name} (${uom.symbol})` : name;\n\n        return {\n          value: uom.id,\n          label,\n        };\n      });\n  }, [uomQuery.data]);\n\n  // Watch all priceItems\n  const watchedPriceItems = useWatch({\n    control,\n    name: \"priceItems\",\n  });\n\n  // Build table rows with search filter\n  const tableRows = useMemo<PriceItemRow[]>(() => {\n    if (!watchedPriceItems || !priceItemFields) return [];\n\n    const rows: PriceItemRow[] = priceItemFields.map((field, index) => {\n      const item = watchedPriceItems[index];\n\n      if (!item) return null as any;\n\n      const variant = variantOptions.find((v) => v.value === item.variantId);\n      const uom = uomOptions.find((u) => u.value === item.uomId);\n\n      const variantName = variant?.label || \"\";\n      const variantLabel =\n        typeof variant?.label === \"string\" ? variant.label : \"\";\n      const matchResult = variantLabel.match(/\\(([^)]+)\\)/);\n      const variantSku = matchResult?.[1] ?? \"\";\n      const uomName = uom?.label || \"\";\n\n      // Check for duplicate\n      const isDuplicate = watchedPriceItems.some(\n        (otherItem: any, otherIndex: number) =>\n          otherIndex !== index &&\n          otherItem.variantId === item.variantId &&\n          otherItem.minimumQuantity === item.minimumQuantity,\n      );\n\n      return {\n        id: field.id,\n        variantId: item.variantId || \"\",\n        variantName,\n        variantSku,\n        uomId: item.uomId || \"\",\n        uomName,\n        minimumQuantity: item.minimumQuantity || \"\",\n        unitPrice: item.unitPrice || \"\",\n        index,\n        isDuplicate,\n      };\n    });\n\n    // Filter by search term (name or code/SKU)\n    if (searchTerm.trim()) {\n      const searchLower = searchTerm.toLowerCase().trim();\n\n      return rows.filter((row) => {\n        if (!row) return false;\n        const nameMatch = row.variantName.toLowerCase().includes(searchLower);\n        const skuMatch = row.variantSku?.toLowerCase().includes(searchLower);\n\n        return nameMatch || skuMatch;\n      });\n    }\n\n    return rows.filter((row) => row !== null);\n  }, [\n    watchedPriceItems,\n    priceItemFields,\n    variantOptions,\n    uomOptions,\n    searchTerm,\n  ]);\n\n  // Get available UOMs for a selected variant\n  const getAvailableUomsForVariant = useCallback(\n    (variantId: string | undefined): SelectItemOption[] => {\n      if (!variantId) return [];\n\n      const variant = variantOptions.find((v) => v.value === variantId);\n\n      if (!variant) return [];\n\n      const availableUomIds: string[] = [];\n      const saleUomId =\n        typeof variant.saleUomId === \"string\" ? variant.saleUomId : undefined;\n      const baseUomId =\n        typeof variant.baseUomId === \"string\" ? variant.baseUomId : undefined;\n\n      if (saleUomId) {\n        availableUomIds.push(saleUomId);\n      }\n      if (baseUomId && baseUomId !== saleUomId) {\n        availableUomIds.push(baseUomId);\n      }\n\n      return uomOptions.filter((uom) =>\n        availableUomIds.includes(String(uom.value)),\n      );\n    },\n    [variantOptions, uomOptions],\n  );\n\n  // Get all tiers for a variant\n  const getVariantTiers = useCallback(\n    (variantId: string, excludeIndex: number) => {\n      if (!variantId) return [];\n\n      return watchedPriceItems\n        .filter(\n          (item: any, idx: number) =>\n            idx !== excludeIndex &&\n            item.variantId === variantId &&\n            item.minimumQuantity,\n        )\n        .map((item: any) => ({\n          minQty: Number(item.minimumQuantity) || 0,\n          price: Number(item.unitPrice) || 0,\n        }))\n        .sort(\n          (\n            a: { minQty: number; price: number },\n            b: { minQty: number; price: number },\n          ) => a.minQty - b.minQty,\n        );\n    },\n    [watchedPriceItems],\n  );\n\n  // Columns definition\n  const columns = useMemo<DataTableColumnDefinition<PriceItemRow>[]>(\n    () => [\n      {\n        key: \"variantName\",\n        label: \"Product (Variant)\",\n        minWidth: 200,\n        render: (_, row) => (\n          <div>\n            <div className=\"font-medium\">{row.variantName}</div>\n            {row.isDuplicate && (\n              <div className=\"text-xs text-warning-600 mt-0.5\">\n                Duplicate combination\n              </div>\n            )}\n          </div>\n        ),\n      },\n      {\n        key: \"uomName\",\n        label: \"UOM\",\n        minWidth: 120,\n        render: (_, row) => <div>{row.uomName || \"-\"}</div>,\n      },\n      {\n        key: \"minimumQuantity\",\n        label: \"Min. Quantity\",\n        minWidth: 120,\n        align: \"end\",\n        render: (_, row) => (\n          <div className=\"text-right\">{row.minimumQuantity || \"-\"}</div>\n        ),\n      },\n      {\n        key: \"unitPrice\",\n        label: \"Unit Price\",\n        minWidth: 150,\n        align: \"end\",\n        render: (_, row) => (\n          <div className=\"text-right font-medium\">\n            {row.unitPrice\n              ? `${Number(row.unitPrice).toLocaleString()} VND`\n              : \"-\"}\n          </div>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: \"Actions\",\n        align: \"end\",\n        minWidth: 100,\n        render: (_, row) => {\n          const tiers = getVariantTiers(row.variantId, row.index);\n\n          return (\n            <div className=\"flex items-center justify-end gap-2\">\n              {tiers.length > 0 && (\n                <div className=\"text-xs text-default-500\">\n                  {tiers.length} tier{tiers.length > 1 ? \"s\" : \"\"}\n                </div>\n              )}\n              <Button\n                isIconOnly\n                size=\"sm\"\n                variant=\"light\"\n                onPress={() => setEditingIndex(row.index)}\n              >\n                <Edit2 size={16} />\n              </Button>\n              <Button\n                isIconOnly\n                color=\"danger\"\n                size=\"sm\"\n                variant=\"light\"\n                onPress={() => removePriceItem(row.index)}\n              >\n                <Trash2 size={16} />\n              </Button>\n            </div>\n          );\n        },\n      },\n    ],\n    [getVariantTiers, removePriceItem],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"w-[500px]\">\n          <IBaseInputSearch\n            placeholder=\"Search by product name or code...\"\n            size=\"sm\"\n            value={searchTerm}\n            onValueChange={setSearchTerm}\n          />\n        </div>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          startContent={<Plus size={16} />}\n          variant=\"solid\"\n          onPress={() => {\n            prependPriceItem({\n              variantId: \"\",\n              uomId: \"\",\n              unitPrice: \"\",\n              minimumQuantity: \"\",\n            });\n            setEditingIndex(0);\n          }}\n        >\n          Add Product\n        </Button>\n      </div>\n\n      {/* DataTable */}\n      {priceItemFields.length === 0 ? (\n        <div className=\"text-sm text-default-500 py-8 text-center\">\n          No explicit pricing items. Click \"Add Product\" to add one.\n        </div>\n      ) : (\n        <Card>\n          <CardBody className=\"p-0\">\n            <DataTable<PriceItemRow>\n              columns={columns}\n              dataSource={tableRows}\n              emptyContent={\n                searchTerm\n                  ? \"No products found matching your search\"\n                  : \"No pricing items\"\n              }\n              loading={productsQuery.isLoading || uomQuery.isLoading}\n              pagination={false}\n              rowKey=\"id\"\n            />\n          </CardBody>\n        </Card>\n      )}\n\n      {/* Edit Modal */}\n      {editingIndex !== null && (\n        <PriceItemEditModal\n          control={control}\n          getAvailableUomsForVariant={getAvailableUomsForVariant}\n          index={editingIndex}\n          isLoading={productsQuery.isLoading}\n          isOpen={editingIndex !== null}\n          setValue={setValue}\n          uomOptions={uomOptions}\n          variantOptions={variantOptions}\n          watchedPriceItems={watchedPriceItems}\n          onClose={() => setEditingIndex(null)}\n        />\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/components/MainTab.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":72,"fix":{"range":[259,259],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":52,"fix":{"range":[15,312],"text":"import { Checkbox, Textarea } from \"@heroui/react\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSelect,\n  IBaseSingleSelect,\n  SelectItem,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react-hook-form` import should occur before import of `@base/client/components`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":55,"fix":{"range":[15,367],"text":"import { Control, Controller } from \"react-hook-form\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSelect,\n  IBaseSingleSelect,\n  SelectItem,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Checkbox, Textarea } from \"@heroui/react\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSelect,\n  IBaseSingleSelect,\n  SelectItem,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Checkbox, Textarea } from \"@heroui/react\";\nimport { Control, Controller } from \"react-hook-form\";\n\ninterface MainTabProps {\n  control: Control<any>;\n  errors?: any;\n  typeOptions: SelectItemOption[];\n  statusOptions: SelectItemOption[];\n  isEdit?: boolean;\n  channelOptions?: SelectItemOption[];\n  storeOptions?: SelectItemOption[];\n  locationOptions?: SelectItemOption[];\n  regionOptions?: SelectItemOption[];\n  customerGroupOptions?: SelectItemOption[];\n}\n\nexport default function MainTab({\n  control,\n  errors,\n  typeOptions,\n  statusOptions,\n  isEdit = false,\n  channelOptions = [],\n  storeOptions = [],\n  locationOptions = [],\n  regionOptions = [],\n  customerGroupOptions = [],\n}: MainTabProps) {\n  const getLocalizedText = useLocalizedText();\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Basic Information */}\n      <div>\n        <h3 className=\"text-sm font-semibold mb-4\">Basic Information</h3>\n        <div className=\"grid gap-4 md:grid-cols-3\">\n          <Controller\n            control={control}\n            name=\"name\"\n            render={({ field, fieldState }) => (\n              <IBaseInputMultipleLang\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Name\"\n                size=\"sm\"\n                value={field.value}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"code\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isDisabled={isEdit}\n                isInvalid={fieldState.invalid}\n                label=\"Code\"\n                size=\"sm\"\n                value={field.value}\n                onChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"type\"\n            render={({ field, fieldState }) => (\n              <IBaseSingleSelect\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                items={typeOptions}\n                label=\"Type\"\n                selectedKey={field.value}\n                size=\"sm\"\n                onSelectionChange={(key) => {\n                  field.onChange(key || \"\");\n                }}\n              />\n            )}\n          />\n        </div>\n        <div className=\"mt-4\">\n          <Controller\n            control={control}\n            name=\"description\"\n            render={({ field, fieldState }) => (\n              <Textarea\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Description\"\n                minRows={2}\n                size=\"sm\"\n                value={field.value || \"\"}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n        </div>\n      </div>\n\n      {/* Status & Priority */}\n      <div>\n        <h3 className=\"text-sm font-semibold mb-4\">Status & Priority</h3>\n        <div className=\"grid gap-4 md:grid-cols-3\">\n          <Controller\n            control={control}\n            name=\"status\"\n            render={({ field, fieldState }) => (\n              <IBaseSingleSelect\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                items={statusOptions}\n                label=\"Status\"\n                selectedKey={field.value}\n                size=\"sm\"\n                onSelectionChange={(key) => {\n                  field.onChange(key || \"\");\n                }}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"priority\"\n            render={({ field, fieldState }) => (\n              <IBaseInputNumber\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Priority\"\n                min={0}\n                size=\"sm\"\n                value={field.value ? Number(field.value) : 0}\n                onValueChange={(value) =>\n                  field.onChange(value?.toString() || \"0\")\n                }\n              />\n            )}\n          />\n          <div className=\"flex items-end\">\n            <Controller\n              control={control}\n              name=\"isDefault\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\" || field.value === true}\n                  size=\"sm\"\n                  onValueChange={(checked) =>\n                    field.onChange(checked ? \"true\" : \"false\")\n                  }\n                >\n                  Is Default\n                </Checkbox>\n              )}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Validity Period */}\n      <div>\n        <h3 className=\"text-sm font-semibold mb-4\">Validity Period</h3>\n        <div className=\"grid gap-4 md:grid-cols-3\">\n          <Controller\n            control={control}\n            name=\"validFrom\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Valid From\"\n                size=\"sm\"\n                type=\"date\"\n                value={field.value}\n                onChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"validTo\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Valid To (leave empty for forever - standard only)\"\n                size=\"sm\"\n                type=\"date\"\n                value={field.value}\n                onChange={field.onChange}\n              />\n            )}\n          />\n          <div />\n        </div>\n      </div>\n\n      {/* Applicable To */}\n      <div>\n        <h3 className=\"text-sm font-semibold mb-4\">Applicable To</h3>\n        <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n          <Controller\n            control={control}\n            name=\"applicableTo.channels\"\n            render={({ field, fieldState }) => (\n              <IBaseSelect\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Channels\"\n                selectedKeys={\n                  field.value\n                    ? new Set(\n                        Array.isArray(field.value)\n                          ? field.value\n                          : [field.value],\n                      )\n                    : new Set()\n                }\n                selectionMode=\"multiple\"\n                size=\"sm\"\n                onSelectionChange={(keys) => {\n                  const selectedArray = Array.from(keys);\n\n                  field.onChange(\n                    selectedArray.length > 0 ? selectedArray : undefined,\n                  );\n                }}\n              >\n                {channelOptions.map((option) => (\n                  <SelectItem\n                    key={option.value}\n                    textValue={\n                      typeof option.label === \"string\"\n                        ? option.label\n                        : getLocalizedText(option.label)\n                    }\n                  >\n                    {typeof option.label === \"string\"\n                      ? option.label\n                      : getLocalizedText(option.label)}\n                  </SelectItem>\n                ))}\n              </IBaseSelect>\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"applicableTo.stores\"\n            render={({ field, fieldState }) => (\n              <IBaseSelect\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Stores\"\n                selectedKeys={\n                  field.value\n                    ? new Set(\n                        Array.isArray(field.value)\n                          ? field.value\n                          : [field.value],\n                      )\n                    : new Set()\n                }\n                selectionMode=\"multiple\"\n                size=\"sm\"\n                onSelectionChange={(keys) => {\n                  const selectedArray = Array.from(keys);\n\n                  field.onChange(\n                    selectedArray.length > 0 ? selectedArray : undefined,\n                  );\n                }}\n              >\n                {storeOptions.map((option) => (\n                  <SelectItem\n                    key={option.value}\n                    textValue={\n                      typeof option.label === \"string\"\n                        ? option.label\n                        : getLocalizedText(option.label)\n                    }\n                  >\n                    {typeof option.label === \"string\"\n                      ? option.label\n                      : getLocalizedText(option.label)}\n                  </SelectItem>\n                ))}\n              </IBaseSelect>\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"applicableTo.locations\"\n            render={({ field, fieldState }) => (\n              <IBaseSelect\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Locations\"\n                selectedKeys={\n                  field.value\n                    ? new Set(\n                        Array.isArray(field.value)\n                          ? field.value\n                          : [field.value],\n                      )\n                    : new Set()\n                }\n                selectionMode=\"multiple\"\n                size=\"sm\"\n                onSelectionChange={(keys) => {\n                  const selectedArray = Array.from(keys);\n\n                  field.onChange(\n                    selectedArray.length > 0 ? selectedArray : undefined,\n                  );\n                }}\n              >\n                {locationOptions.map((option) => (\n                  <SelectItem\n                    key={option.value}\n                    textValue={\n                      typeof option.label === \"string\"\n                        ? option.label\n                        : getLocalizedText(option.label)\n                    }\n                  >\n                    {typeof option.label === \"string\"\n                      ? option.label\n                      : getLocalizedText(option.label)}\n                  </SelectItem>\n                ))}\n              </IBaseSelect>\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"applicableTo.regions\"\n            render={({ field, fieldState }) => (\n              <IBaseSelect\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Regions\"\n                selectedKeys={\n                  field.value\n                    ? new Set(\n                        Array.isArray(field.value)\n                          ? field.value\n                          : [field.value],\n                      )\n                    : new Set()\n                }\n                selectionMode=\"multiple\"\n                size=\"sm\"\n                onSelectionChange={(keys) => {\n                  const selectedArray = Array.from(keys);\n\n                  field.onChange(\n                    selectedArray.length > 0 ? selectedArray : undefined,\n                  );\n                }}\n              >\n                {regionOptions.map((option) => (\n                  <SelectItem\n                    key={option.value}\n                    textValue={\n                      typeof option.label === \"string\"\n                        ? option.label\n                        : getLocalizedText(option.label)\n                    }\n                  >\n                    {typeof option.label === \"string\"\n                      ? option.label\n                      : getLocalizedText(option.label)}\n                  </SelectItem>\n                ))}\n              </IBaseSelect>\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"applicableTo.customerGroups\"\n            render={({ field, fieldState }) => (\n              <IBaseSelect\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Customer Groups\"\n                selectedKeys={\n                  field.value\n                    ? new Set(\n                        Array.isArray(field.value)\n                          ? field.value\n                          : [field.value],\n                      )\n                    : new Set()\n                }\n                selectionMode=\"multiple\"\n                size=\"sm\"\n                onSelectionChange={(keys) => {\n                  const selectedArray = Array.from(keys);\n\n                  field.onChange(\n                    selectedArray.length > 0 ? selectedArray : undefined,\n                  );\n                }}\n              >\n                {customerGroupOptions.map((option) => (\n                  <SelectItem\n                    key={option.value}\n                    textValue={\n                      typeof option.label === \"string\"\n                        ? option.label\n                        : getLocalizedText(option.label)\n                    }\n                  >\n                    {typeof option.label === \"string\"\n                      ? option.label\n                      : getLocalizedText(option.label)}\n                  </SelectItem>\n                ))}\n              </IBaseSelect>\n            )}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/components/PriceItemEditModal.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[15,482],"text":"import { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button } from \"@heroui/button\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"@heroui/react\";\nimport { AlertCircle } from \"lucide-react\";\nimport { useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":72,"fix":{"range":[190,190],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `react-hook-form`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":72,"fix":{"range":[119,482],"text":"import { Button } from \"@heroui/button\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"@heroui/react\";\nimport { AlertCircle } from \"lucide-react\";\nimport { useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uomOptions' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":43,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button } from \"@heroui/button\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"@heroui/react\";\nimport { AlertCircle } from \"lucide-react\";\nimport { useMemo } from \"react\";\nimport { Control, Controller, UseFormSetValue } from \"react-hook-form\";\n\ninterface PriceItemEditModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  index: number;\n  control: Control<any>;\n  setValue: UseFormSetValue<any>;\n  variantOptions: SelectItemOption[];\n  uomOptions: SelectItemOption[];\n  getAvailableUomsForVariant: (\n    variantId: string | undefined,\n  ) => SelectItemOption[];\n  watchedPriceItems: any[];\n  isLoading?: boolean;\n}\n\nexport default function PriceItemEditModal({\n  isOpen,\n  onClose,\n  index,\n  control,\n  setValue,\n  variantOptions,\n  uomOptions,\n  getAvailableUomsForVariant,\n  watchedPriceItems,\n  isLoading = false,\n}: PriceItemEditModalProps) {\n  const getLocalizedText = useLocalizedText();\n  const currentItem = watchedPriceItems?.[index];\n  const variantId = currentItem?.variantId;\n  const minimumQuantity = currentItem?.minimumQuantity;\n  const availableUoms = getAvailableUomsForVariant(variantId);\n\n  // Check for duplicate\n  const isDuplicate = useMemo(() => {\n    if (!variantId || !minimumQuantity) return false;\n\n    return watchedPriceItems.some(\n      (item: any, idx: number) =>\n        idx !== index &&\n        item.variantId === variantId &&\n        item.minimumQuantity === minimumQuantity,\n    );\n  }, [variantId, minimumQuantity, watchedPriceItems, index]);\n\n  // Get variant name\n  const variantName = useMemo(() => {\n    if (!variantId) return \"\";\n    const variant = variantOptions.find((v) => v.value === variantId);\n\n    if (!variant) return \"\";\n\n    return typeof variant.label === \"string\"\n      ? variant.label\n      : getLocalizedText(variant.label);\n  }, [variantId, variantOptions, getLocalizedText]);\n\n  // Get all tiers for this variant\n  const variantTiers = useMemo(() => {\n    if (!variantId) return [];\n\n    return watchedPriceItems\n      .filter(\n        (item: any, idx: number) =>\n          idx !== index && item.variantId === variantId && item.minimumQuantity,\n      )\n      .map((item: any) => ({\n        minQty: Number(item.minimumQuantity) || 0,\n        price: Number(item.unitPrice) || 0,\n      }))\n      .sort((a, b) => a.minQty - b.minQty);\n  }, [variantId, watchedPriceItems, index]);\n\n  const handleVariantChange = (key: string) => {\n    if (key) {\n      const variant = variantOptions.find((v) => v.value === key);\n\n      if (variant) {\n        const saleUomId =\n          typeof variant.saleUomId === \"string\" ? variant.saleUomId : undefined;\n        const baseUomId =\n          typeof variant.baseUomId === \"string\" ? variant.baseUomId : undefined;\n        const uomId = saleUomId || baseUomId;\n\n        if (uomId) {\n          setValue(`priceItems.${index}.uomId`, uomId, {\n            shouldValidate: false,\n          });\n        }\n      }\n    } else {\n      setValue(`priceItems.${index}.uomId`, \"\", {\n        shouldValidate: false,\n      });\n    }\n  };\n\n  return (\n    <Modal\n      isOpen={isOpen}\n      placement=\"center\"\n      scrollBehavior=\"inside\"\n      size=\"2xl\"\n      onClose={onClose}\n    >\n      <ModalContent>\n        <ModalHeader className=\"flex flex-col gap-1\">\n          <h3 className=\"text-lg font-semibold\">Edit Price Item</h3>\n        </ModalHeader>\n        <ModalBody className=\"py-4\">\n          <div className=\"space-y-4\">\n            {/* Alerts */}\n            {isDuplicate && (\n              <div className=\"p-3 bg-warning-50 border border-warning-200 rounded-lg flex items-center gap-2 text-warning-700 text-sm\">\n                <AlertCircle size={16} />\n                <span>\n                  This variant + minimum quantity combination already exists\n                </span>\n              </div>\n            )}\n\n            {variantTiers.length > 0 && (\n              <div className=\"p-3 bg-default-50 border border-default-200 rounded-lg text-sm text-default-600\">\n                <div className=\"font-semibold mb-2\">\n                  {variantName} - Tiered Pricing:\n                </div>\n                <div className=\"flex flex-wrap gap-2\">\n                  {variantTiers.map((tier, idx) => (\n                    <span\n                      key={idx}\n                      className=\"px-2 py-1 bg-white rounded text-xs\"\n                    >\n                      {tier.minQty}+: {tier.price.toLocaleString()} VND\n                    </span>\n                  ))}\n                  {minimumQuantity && (\n                    <span className=\"px-2 py-1 bg-primary-100 text-primary-700 rounded font-semibold text-xs\">\n                      {minimumQuantity}+:{\" \"}\n                      {Number(currentItem?.unitPrice || 0).toLocaleString()} VND\n                      (current)\n                    </span>\n                  )}\n                </div>\n              </div>\n            )}\n\n            {/* Form Fields - Grid Layout */}\n            <div className=\"space-y-4\">\n              {/* Product Variant - Full Width */}\n              <Controller\n                control={control}\n                name={`priceItems.${index}.variantId`}\n                render={({ field, fieldState }) => (\n                  <IBaseSingleSelect\n                    isRequired\n                    errorMessage={\n                      fieldState.error?.message ||\n                      (isDuplicate\n                        ? \"This variant + minimum quantity combination already exists\"\n                        : undefined)\n                    }\n                    isInvalid={fieldState.invalid || isDuplicate}\n                    isLoading={isLoading}\n                    items={variantOptions}\n                    label=\"Product (Variant)\"\n                    searchPlaceholder=\"Search product variant...\"\n                    selectedKey={field.value}\n                    size=\"sm\"\n                    onSelectionChange={(key) => {\n                      field.onChange(key || \"\");\n                      handleVariantChange(key || \"\");\n                    }}\n                  />\n                )}\n              />\n\n              {/* UOM - Full Width */}\n              <Controller\n                control={control}\n                name={`priceItems.${index}.uomId`}\n                render={({ field: uomField, fieldState: uomFieldState }) => (\n                  <IBaseSingleSelect\n                    isRequired\n                    errorMessage={uomFieldState.error?.message}\n                    isDisabled={!variantId || availableUoms.length === 0}\n                    isInvalid={uomFieldState.invalid}\n                    items={availableUoms}\n                    label=\"UOM\"\n                    selectedKey={uomField.value}\n                    size=\"sm\"\n                    onSelectionChange={(key) => {\n                      uomField.onChange(key || \"\");\n                    }}\n                  />\n                )}\n              />\n\n              {/* Quantity and Unit Price - Same Row */}\n              <div className=\"grid grid-cols-1 gap-4 md:grid-cols-2\">\n                <Controller\n                  control={control}\n                  name={`priceItems.${index}.minimumQuantity`}\n                  render={({ field, fieldState }) => (\n                    <IBaseInputNumber\n                      isRequired\n                      errorMessage={fieldState.error?.message}\n                      isInvalid={fieldState.invalid || isDuplicate}\n                      label=\"Minimum Quantity\"\n                      min={1}\n                      size=\"sm\"\n                      value={field.value ? Number(field.value) : undefined}\n                      onValueChange={(value) =>\n                        field.onChange(value?.toString() || \"\")\n                      }\n                    />\n                  )}\n                  rules={{\n                    required: \"Minimum quantity is required\",\n                    validate: (value) => {\n                      if (!value) return true;\n                      const numValue = Number(value);\n\n                      if (numValue < 1)\n                        return \"Minimum quantity must be at least 1\";\n                      // Check duplicate\n                      const duplicate = watchedPriceItems.some(\n                        (item: any, idx: number) =>\n                          idx !== index &&\n                          item.variantId === variantId &&\n                          item.minimumQuantity === value,\n                      );\n\n                      if (duplicate) {\n                        return \"This variant + minimum quantity combination already exists\";\n                      }\n\n                      return true;\n                    },\n                  }}\n                />\n\n                <Controller\n                  control={control}\n                  name={`priceItems.${index}.unitPrice`}\n                  render={({ field, fieldState }) => (\n                    <IBaseInputNumber\n                      isRequired\n                      errorMessage={fieldState.error?.message}\n                      isInvalid={fieldState.invalid}\n                      label=\"Unit Price (VND)\"\n                      min={0}\n                      size=\"sm\"\n                      value={field.value ? Number(field.value) : undefined}\n                      onValueChange={(value) =>\n                        field.onChange(value?.toString() || \"\")\n                      }\n                    />\n                  )}\n                />\n              </div>\n            </div>\n          </div>\n        </ModalBody>\n        <ModalFooter>\n          <Button variant=\"light\" onPress={onClose}>\n            Cancel\n          </Button>\n          <Button color=\"primary\" onPress={onClose}>\n            Save\n          </Button>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/components/PriceListForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":76,"fix":{"range":[90,90],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react-hook-form` import should occur before import of `@base/client/components`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":60,"fix":{"range":[15,151],"text":"import { Control, UseFormSetValue } from \"react-hook-form\";\nimport { IBaseTabs, SelectItemOption, Tab } from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'productOptions' is assigned a value but never used. Allowed unused args must match /^_.*?$/u.","line":42,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { IBaseTabs, SelectItemOption, Tab } from \"@base/client/components\";\nimport { Control, UseFormSetValue } from \"react-hook-form\";\n\nimport ExplicitPricingTab from \"./ExplicitPricingTab\";\nimport MainTab from \"./MainTab\";\nimport RulesAndConditionsTab from \"./RulesAndConditionsTab\";\n\ninterface PriceListFormProps {\n  control: Control<any>;\n  setValue: UseFormSetValue<any>;\n  errors?: any;\n  typeOptions: SelectItemOption[];\n  statusOptions: SelectItemOption[];\n  isEdit?: boolean;\n  // Options for applicableTo selects\n  channelOptions?: SelectItemOption[];\n  storeOptions?: SelectItemOption[];\n  locationOptions?: SelectItemOption[];\n  regionOptions?: SelectItemOption[];\n  customerGroupOptions?: SelectItemOption[];\n  // Options for explicit pricing\n  productOptions?: SelectItemOption[];\n  // Options for rules\n  categoryOptions?: SelectItemOption[];\n  brandOptions?: SelectItemOption[];\n}\n\nexport default function PriceListForm({\n  control,\n  setValue,\n  errors,\n  typeOptions,\n  statusOptions,\n  isEdit = false,\n  channelOptions = [],\n  storeOptions = [],\n  locationOptions = [],\n  regionOptions = [],\n  customerGroupOptions = [],\n  productOptions = [],\n  categoryOptions = [],\n  brandOptions = [],\n}: PriceListFormProps) {\n  return (\n    <IBaseTabs\n      aria-label=\"Price List Form Tabs\"\n      classNames={{\n        tab: \"max-w-[200px]\",\n        tabContent: \"truncate\",\n      }}\n      color=\"primary\"\n    >\n      <Tab key=\"main\" title=\"Main\">\n        <MainTab\n          channelOptions={channelOptions}\n          control={control}\n          customerGroupOptions={customerGroupOptions}\n          errors={errors}\n          isEdit={isEdit}\n          locationOptions={locationOptions}\n          regionOptions={regionOptions}\n          statusOptions={statusOptions}\n          storeOptions={storeOptions}\n          typeOptions={typeOptions}\n        />\n      </Tab>\n\n      <Tab key=\"rules\" title=\"Rules and Conditions\">\n        <RulesAndConditionsTab\n          brandOptions={brandOptions}\n          categoryOptions={categoryOptions}\n          control={control}\n          errors={errors}\n        />\n      </Tab>\n\n      <Tab key=\"pricing\" title=\"Explicit Pricing\">\n        <ExplicitPricingTab\n          control={control}\n          errors={errors}\n          setValue={setValue}\n        />\n      </Tab>\n    </IBaseTabs>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/pages/PriceLists/components/RulesAndConditionsTab.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[112,112],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `lucide-react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[15,327],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox } from \"@heroui/react\";\nimport { Control, Controller, useFieldArray } from \"react-hook-form\";\nimport { Plus, Trash2 } from \"lucide-react\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":9},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":67,"column":35,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click &quot;Add Rule\" to add one.\n        "},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click &ldquo;Add Rule\" to add one.\n        "},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click &#34;Add Rule\" to add one.\n        "},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click &rdquo;Add Rule\" to add one.\n        "},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":67,"column":44,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click \"Add Rule&quot; to add one.\n        "},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click \"Add Rule&ldquo; to add one.\n        "},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click \"Add Rule&#34; to add one.\n        "},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[1727,1793],"text":"\n          No pricing rules. Click \"Add Rule&rdquo; to add one.\n        "},"desc":"Replace with `&rdquo;`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox } from \"@heroui/react\";\nimport { Control, Controller, useFieldArray } from \"react-hook-form\";\nimport { Plus, Trash2 } from \"lucide-react\";\n\ninterface RulesAndConditionsTabProps {\n  control: Control<any>;\n  errors?: any;\n  categoryOptions?: SelectItemOption[];\n  brandOptions?: SelectItemOption[];\n}\n\nexport default function RulesAndConditionsTab({\n  control,\n  errors,\n  categoryOptions = [],\n  brandOptions = [],\n}: RulesAndConditionsTabProps) {\n  const {\n    fields: ruleFields,\n    append: appendRule,\n    remove: removeRule,\n  } = useFieldArray({\n    control,\n    name: \"pricingRules\",\n  });\n\n  const ruleMethodOptions: SelectItemOption[] = [\n    { value: \"fixed\", label: \"Fixed Price\" },\n    { value: \"percentage\", label: \"Percentage Discount\" },\n    { value: \"formula\", label: \"Formula\" },\n    { value: \"tiered\", label: \"Tiered Pricing\" },\n  ];\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"text-sm font-semibold\">Pricing Rules</h3>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          startContent={<Plus size={16} />}\n          variant=\"flat\"\n          onPress={() =>\n            appendRule({\n              name: \"\",\n              method: \"fixed\",\n              value: \"\",\n              conditions: {},\n              applyToExceptions: false,\n            })\n          }\n        >\n          Add Rule\n        </Button>\n      </div>\n\n      {ruleFields.length === 0 ? (\n        <div className=\"text-sm text-default-500 py-4 text-center\">\n          No pricing rules. Click \"Add Rule\" to add one.\n        </div>\n      ) : (\n        <div className=\"space-y-3\">\n          {ruleFields.map((field, index) => (\n            <Card key={field.id} className=\"p-4\">\n              <CardBody className=\"p-0 space-y-4\">\n                <div className=\"grid gap-4 md:grid-cols-2\">\n                  <Controller\n                    control={control}\n                    name={`pricingRules.${index}.name`}\n                    render={({ field, fieldState }) => (\n                      <IBaseInput\n                        isRequired\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label=\"Rule Name\"\n                        size=\"sm\"\n                        value={field.value}\n                        onChange={field.onChange}\n                      />\n                    )}\n                  />\n                  <Controller\n                    control={control}\n                    name={`pricingRules.${index}.method`}\n                    render={({ field, fieldState }) => (\n                      <IBaseSingleSelect\n                        isRequired\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        items={ruleMethodOptions}\n                        label=\"Method\"\n                        selectedKey={field.value}\n                        size=\"sm\"\n                        onSelectionChange={(key) => {\n                          field.onChange(key || \"\");\n                        }}\n                      />\n                    )}\n                  />\n                </div>\n\n                <div className=\"grid gap-4 md:grid-cols-2\">\n                  <Controller\n                    control={control}\n                    name={`pricingRules.${index}.value`}\n                    render={({ field, fieldState }) => (\n                      <IBaseInput\n                        isRequired\n                        errorMessage={fieldState.error?.message}\n                        isInvalid={fieldState.invalid}\n                        label=\"Value\"\n                        placeholder=\"Enter value or formula\"\n                        size=\"sm\"\n                        type=\"number\"\n                        value={field.value}\n                        onChange={field.onChange}\n                      />\n                    )}\n                  />\n                  <div className=\"flex items-end\">\n                    <Controller\n                      control={control}\n                      name={`pricingRules.${index}.applyToExceptions`}\n                      render={({ field }) => (\n                        <Checkbox\n                          isSelected={field.value === true}\n                          size=\"sm\"\n                          onValueChange={field.onChange}\n                        >\n                          Apply to Exceptions\n                        </Checkbox>\n                      )}\n                    />\n                  </div>\n                </div>\n\n                <div>\n                  <h4 className=\"text-xs font-medium mb-2\">Conditions</h4>\n                  <div className=\"grid gap-4 md:grid-cols-2\">\n                    <Controller\n                      control={control}\n                      name={`pricingRules.${index}.conditions.categories`}\n                      render={({ field }) => (\n                        <IBaseSingleSelect\n                          items={categoryOptions}\n                          label=\"Categories\"\n                          selectedKey={field.value}\n                          size=\"sm\"\n                          onSelectionChange={(key) => {\n                            field.onChange(key || undefined);\n                          }}\n                        />\n                      )}\n                    />\n                    <Controller\n                      control={control}\n                      name={`pricingRules.${index}.conditions.brands`}\n                      render={({ field }) => (\n                        <IBaseSingleSelect\n                          items={brandOptions}\n                          label=\"Brands\"\n                          selectedKey={field.value}\n                          size=\"sm\"\n                          onSelectionChange={(key) => {\n                            field.onChange(key || undefined);\n                          }}\n                        />\n                      )}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"flex justify-end\">\n                  <Button\n                    color=\"danger\"\n                    size=\"sm\"\n                    startContent={<Trash2 size={16} />}\n                    variant=\"light\"\n                    onPress={() => removeRule(index)}\n                  >\n                    Remove\n                  </Button>\n                </div>\n              </CardBody>\n            </Card>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/services/CustomerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/services/DeliveryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/services/PriceListB2CService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/services/SalesOrderB2CService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/client/services/SalesOrderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Customer/CustomerCompanyViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_customer_companies } from \"../../schemas\";\n\nclass CustomerCompanyViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_customer_companies,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_customer_companies,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_customer_companies.id, sort: true }],\n      [\"code\", { column: sale_b2c_tb_customer_companies.code, sort: true }],\n      [\"name\", { column: sale_b2c_tb_customer_companies.name, sort: true }],\n      [\"taxId\", { column: sale_b2c_tb_customer_companies.taxId, sort: true }],\n      [\"phone\", { column: sale_b2c_tb_customer_companies.phone, sort: true }],\n      [\"email\", { column: sale_b2c_tb_customer_companies.email, sort: true }],\n      [\n        \"isActive\",\n        { column: sale_b2c_tb_customer_companies.isActive, sort: true },\n      ],\n      [\n        \"createdAt\",\n        { column: sale_b2c_tb_customer_companies.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: sale_b2c_tb_customer_companies.updatedAt, sort: true },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.code, text),\n      ],\n      [\n        \"name\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.name, text),\n      ],\n      [\n        \"taxId\",\n        (text: string) => ilike(sale_b2c_tb_customer_companies.taxId, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    taxId: row.taxId ?? undefined,\n    address: row.address ?? undefined,\n    phone: row.phone ?? undefined,\n    email: row.email ?? undefined,\n    website: row.website ?? undefined,\n    contactPerson: row.contactPerson ?? undefined,\n    creditLimit: row.creditLimit ?? undefined,\n    paymentTermsId: row.paymentTermsId ?? undefined,\n    isActive: row.isActive,\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default CustomerCompanyViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Customer/CustomerIndividualViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_customers } from \"../../schemas\";\n\nclass CustomerIndividualViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_customers,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_customers,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_customers.id, sort: true }],\n      [\"code\", { column: sale_b2c_tb_customers.code, sort: true }],\n      [\"firstName\", { column: sale_b2c_tb_customers.firstName, sort: true }],\n      [\"lastName\", { column: sale_b2c_tb_customers.lastName, sort: true }],\n      [\"phone\", { column: sale_b2c_tb_customers.phone, sort: true }],\n      [\"email\", { column: sale_b2c_tb_customers.email, sort: true }],\n      [\"isActive\", { column: sale_b2c_tb_customers.isActive, sort: true }],\n      [\"createdAt\", { column: sale_b2c_tb_customers.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2c_tb_customers.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(sale_b2c_tb_customers.code, text)],\n      [\n        \"firstName\",\n        (text: string) => ilike(sale_b2c_tb_customers.firstName, text),\n      ],\n      [\n        \"lastName\",\n        (text: string) => ilike(sale_b2c_tb_customers.lastName, text),\n      ],\n      [\"phone\", (text: string) => ilike(sale_b2c_tb_customers.phone, text)],\n      [\"email\", (text: string) => ilike(sale_b2c_tb_customers.email, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    firstName: row.firstName,\n    lastName: row.lastName,\n    phone: row.phone ?? undefined,\n    email: row.email ?? undefined,\n    address: row.address ?? undefined,\n    dateOfBirth: row.dateOfBirth?.getTime(),\n    gender: row.gender ?? undefined,\n    isActive: row.isActive,\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default CustomerIndividualViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Customer/CustomerModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":40,"fix":{"range":[365,365],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type {\n  CreateCustomerCompanyInput,\n  CreateCustomerIndividualInput,\n  UpdateCustomerCompanyInput,\n  UpdateCustomerIndividualInput,\n} from \"../../models/interfaces/Customer\";\nimport type {\n  NewSaleB2cTbCustomer,\n  NewSaleB2cTbCustomerCompany,\n  SaleB2cTbCustomer,\n  SaleB2cTbCustomerCompany,\n} from \"../../schemas\";\n\nimport { desc, eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\n\nimport {\n  sale_b2c_tb_customer_companies,\n  sale_b2c_tb_customers,\n} from \"../../schemas\";\n\nexport default class CustomerModel {\n  private companyModel: BaseModel<typeof sale_b2c_tb_customer_companies>;\n  private individualModel: BaseModel<typeof sale_b2c_tb_customers>;\n\n  constructor() {\n    this.companyModel = new BaseModel(sale_b2c_tb_customer_companies);\n    this.individualModel = new BaseModel(sale_b2c_tb_customers);\n  }\n\n  // Company methods\n  listCompanies = async (): Promise<SaleB2cTbCustomerCompany[]> => {\n    const db = await RuntimeContext.getDbConnect();\n\n    return db\n      .select()\n      .from(sale_b2c_tb_customer_companies)\n      .orderBy(desc(sale_b2c_tb_customer_companies.createdAt));\n  };\n\n  getCompanyById = async (\n    id: string,\n  ): Promise<SaleB2cTbCustomerCompany | null> => {\n    const db = await RuntimeContext.getDbConnect();\n    const [company] = await db\n      .select()\n      .from(sale_b2c_tb_customer_companies)\n      .where(eq(sale_b2c_tb_customer_companies.id, id))\n      .limit(1);\n\n    return company ?? null;\n  };\n\n  createCompany = async (input: CreateCustomerCompanyInput) => {\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `CUST-COMP-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    const payload: NewSaleB2cTbCustomerCompany = {\n      code: generatedCode,\n      name: input.name.trim(),\n      taxId: input.taxId,\n      address: input.address,\n      phone: input.phone,\n      email: input.email,\n      website: input.website,\n      contactPerson: input.contactPerson,\n      creditLimit: input.creditLimit?.toString(),\n      paymentTermsId: input.paymentTermsId,\n      isActive: input.isActive ?? true,\n      notes: input.notes,\n      createdBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [company] = await db\n      .insert(sale_b2c_tb_customer_companies)\n      .values(payload)\n      .returning();\n\n    return company;\n  };\n\n  updateCompany = async (input: UpdateCustomerCompanyInput) => {\n    const now = new Date();\n    const updatePayload: Partial<NewSaleB2cTbCustomerCompany> = {\n      name: input.name?.trim(),\n      taxId: input.taxId,\n      address: input.address,\n      phone: input.phone,\n      email: input.email,\n      website: input.website,\n      contactPerson: input.contactPerson,\n      creditLimit: input.creditLimit?.toString(),\n      paymentTermsId: input.paymentTermsId,\n      isActive: input.isActive,\n      notes: input.notes,\n      updatedAt: now,\n      updatedBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [updated] = await db\n      .update(sale_b2c_tb_customer_companies)\n      .set(updatePayload)\n      .where(eq(sale_b2c_tb_customer_companies.id, input.id))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Customer company not found\");\n    }\n\n    return updated;\n  };\n\n  // Individual methods\n  listIndividuals = async (): Promise<SaleB2cTbCustomer[]> => {\n    const db = await RuntimeContext.getDbConnect();\n\n    return db\n      .select()\n      .from(sale_b2c_tb_customers)\n      .orderBy(desc(sale_b2c_tb_customers.createdAt));\n  };\n\n  getIndividualById = async (id: string): Promise<SaleB2cTbCustomer | null> => {\n    const db = await RuntimeContext.getDbConnect();\n    const [individual] = await db\n      .select()\n      .from(sale_b2c_tb_customers)\n      .where(eq(sale_b2c_tb_customers.id, id))\n      .limit(1);\n\n    return individual ?? null;\n  };\n\n  createIndividual = async (input: CreateCustomerIndividualInput) => {\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `CUST-IND-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    const payload: NewSaleB2cTbCustomer = {\n      code: generatedCode,\n      firstName: input.firstName.trim(),\n      lastName: input.lastName.trim(),\n      phone: input.phone,\n      email: input.email,\n      address: input.address,\n      dateOfBirth: input.dateOfBirth ? new Date(input.dateOfBirth) : undefined,\n      gender: input.gender,\n      isActive: input.isActive ?? true,\n      notes: input.notes,\n      createdBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [individual] = await db\n      .insert(sale_b2c_tb_customers)\n      .values(payload)\n      .returning();\n\n    return individual;\n  };\n\n  updateIndividual = async (input: UpdateCustomerIndividualInput) => {\n    const now = new Date();\n    const updatePayload: Partial<NewSaleB2cTbCustomer> = {\n      firstName: input.firstName?.trim(),\n      lastName: input.lastName?.trim(),\n      phone: input.phone,\n      email: input.email,\n      address: input.address,\n      dateOfBirth: input.dateOfBirth ? new Date(input.dateOfBirth) : undefined,\n      gender: input.gender,\n      isActive: input.isActive,\n      notes: input.notes,\n      updatedAt: now,\n      updatedBy: input.userId,\n    };\n\n    const db = await RuntimeContext.getDbConnect();\n    const [updated] = await db\n      .update(sale_b2c_tb_customers)\n      .set(updatePayload)\n      .where(eq(sale_b2c_tb_customers.id, input.id))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Customer individual not found\");\n    }\n\n    return updated;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Customer/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Delivery/DeliveryModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[197,197],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'order' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":77,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type StockModel from \"@mdl/stock/server/models/Stock/StockModel\";\nimport type {\n  NewSaleB2cTbDelivery,\n  NewSaleB2cTbDeliveryLine,\n} from \"../../schemas\";\n\nimport { eq } from \"drizzle-orm\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  sale_b2b_tb_orders,\n  sale_b2b_tb_order_lines,\n} from \"@mdl/b2b-sales/server/schemas\";\n\nimport {\n  sale_b2c_tb_orders,\n  sale_b2c_tb_deliveries,\n  sale_b2c_tb_delivery_lines,\n  sale_b2c_tb_order_lines,\n} from \"../../schemas\";\n\nexport interface CreateDeliveryInput {\n  orderType: \"B2B\" | \"B2C\";\n  orderId: string;\n  warehouseId: string;\n  deliveryDate: string;\n  reference?: string;\n  note?: string;\n  lines: Array<{\n    lineId: string;\n    quantity: number;\n  }>;\n  userId?: string;\n}\n\nexport default class DeliveryModel extends BaseModel<\n  typeof sale_b2c_tb_deliveries\n> {\n  constructor() {\n    super(sale_b2c_tb_deliveries);\n  }\n\n  create = async (input: CreateDeliveryInput) => {\n    const stockModel =\n      await RuntimeContext.getModelInstanceBy<StockModel>(\"stock\");\n\n    if (!stockModel) {\n      throw new Error(\"Stock model is not registered\");\n    }\n\n    // Get order to validate\n    let order: any;\n    let orderCode: string;\n\n    if (input.orderType === \"B2B\") {\n      const [b2bOrder] = await this.db\n        .select()\n        .from(sale_b2b_tb_orders)\n        .where(eq(sale_b2b_tb_orders.id, input.orderId))\n        .limit(1);\n\n      if (!b2bOrder) {\n        throw new Error(\"Order not found\");\n      }\n      order = b2bOrder;\n      orderCode = b2bOrder.code;\n    } else {\n      const [b2cOrder] = await this.db\n        .select()\n        .from(sale_b2c_tb_orders)\n        .where(eq(sale_b2c_tb_orders.id, input.orderId))\n        .limit(1);\n\n      if (!b2cOrder) {\n        throw new Error(\"Order not found\");\n      }\n      order = b2cOrder;\n      orderCode = b2cOrder.code;\n    }\n\n    // Get order lines\n    const lineTable =\n      input.orderType === \"B2B\"\n        ? sale_b2b_tb_order_lines\n        : sale_b2c_tb_order_lines;\n    const orderLines = await this.db\n      .select()\n      .from(lineTable)\n      .where(eq(lineTable.orderId, input.orderId));\n\n    const linesById = new Map();\n\n    for (const line of orderLines) {\n      linesById.set(line.id, line);\n    }\n\n    const deliveryDate = new Date(input.deliveryDate);\n    const now = new Date();\n\n    return this.db.transaction(async (tx) => {\n      // Create delivery record\n      const deliveryPayload: NewSaleB2cTbDelivery = {\n        orderType: input.orderType,\n        orderId: input.orderId,\n        warehouseId: input.warehouseId,\n        deliveryDate: deliveryDate,\n        reference: input.reference,\n        note: input.note,\n        status: \"draft\",\n        createdBy: input.userId,\n      };\n\n      const [delivery] = await tx\n        .insert(sale_b2c_tb_deliveries)\n        .values(deliveryPayload)\n        .returning();\n\n      // Process delivery lines and create stock moves\n      for (const deliveryLine of input.lines) {\n        const orderLine = linesById.get(deliveryLine.lineId);\n\n        if (!orderLine) {\n          throw new Error(`Order line ${deliveryLine.lineId} not found`);\n        }\n\n        const quantity = Number(deliveryLine.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const alreadyDelivered = Number(orderLine.quantityDelivered ?? 0);\n        const orderedQty = Number(orderLine.quantityOrdered ?? 0);\n        const nextDelivered = alreadyDelivered + quantity;\n\n        if (nextDelivered - orderedQty > 0.0001) {\n          throw new Error(\n            `Cannot deliver more than ordered for product ${orderLine.productId}`,\n          );\n        }\n\n        // Create delivery line\n        const deliveryLinePayload: NewSaleB2cTbDeliveryLine = {\n          deliveryId: delivery.id,\n          orderType: input.orderType,\n          orderLineId: deliveryLine.lineId,\n          quantity: quantity.toString(),\n        };\n\n        await tx.insert(sale_b2c_tb_delivery_lines).values(deliveryLinePayload);\n\n        // Update order line delivered quantity\n        await tx\n          .update(lineTable)\n          .set({\n            quantityDelivered: nextDelivered.toString(),\n            updatedAt: now,\n          })\n          .where(eq(lineTable.id, deliveryLine.lineId));\n\n        // Create stock move (outbound)\n        await stockModel.issueStock({\n          productId: orderLine.productId,\n          warehouseId: input.warehouseId,\n          quantity,\n          reference: input.reference || `DELIVERY:${orderCode}`,\n          note: input.note,\n          userId: input.userId,\n        });\n      }\n\n      // Update delivery status to completed\n      await tx\n        .update(sale_b2c_tb_deliveries)\n        .set({\n          status: \"completed\",\n          updatedAt: now,\n        })\n        .where(eq(sale_b2c_tb_deliveries.id, delivery.id));\n\n      return delivery;\n    });\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Delivery/DeliveryViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_deliveries } from \"../../schemas\";\n\nclass DeliveryViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_deliveries,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_deliveries,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_deliveries.id, sort: true }],\n      [\"orderType\", { column: sale_b2c_tb_deliveries.orderType, sort: true }],\n      [\"orderId\", { column: sale_b2c_tb_deliveries.orderId, sort: true }],\n      [\n        \"warehouseId\",\n        { column: sale_b2c_tb_deliveries.warehouseId, sort: true },\n      ],\n      [\n        \"deliveryDate\",\n        { column: sale_b2c_tb_deliveries.deliveryDate, sort: true },\n      ],\n      [\"reference\", { column: sale_b2c_tb_deliveries.reference, sort: true }],\n      [\"status\", { column: sale_b2c_tb_deliveries.status, sort: true }],\n      [\"createdAt\", { column: sale_b2c_tb_deliveries.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2c_tb_deliveries.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"reference\",\n        (text: string) => ilike(sale_b2c_tb_deliveries.reference, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    orderType: row.orderType,\n    orderId: row.orderId,\n    warehouseId: row.warehouseId ?? undefined,\n    deliveryDate: row.deliveryDate?.getTime(),\n    reference: row.reference ?? undefined,\n    note: row.note ?? undefined,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n    createdBy: row.createdBy ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default DeliveryViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Delivery/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/PriceList/PriceListB2CDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":46,"fix":{"range":[223,374],"text":"import { eq, ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":75,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":75,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike, sql } from \"drizzle-orm\";\n\nimport { sale_b2c_tb_price_lists } from \"../../schemas/b2c-sales.price-list\";\n\ntype PriceListB2CDropdownOption = {\n  label: string;\n  value: string;\n  code: string;\n  name: any;\n  [key: string]: any;\n};\n\nclass PriceListB2CDropdownListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_price_lists,\n  PriceListB2CDropdownOption\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_price_lists,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    // Minimal columns for dropdown\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_price_lists.id, sort: false }],\n      [\"code\", { column: sale_b2c_tb_price_lists.code, sort: true }],\n      [\"name\", { column: sale_b2c_tb_price_lists.name, sort: false }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) =>\n          text ? ilike(sale_b2c_tb_price_lists.code, `%${text}%`) : undefined,\n      ],\n      [\n        \"name\",\n        (text: string) =>\n          text\n            ? sql`${sale_b2c_tb_price_lists.name}::text ILIKE ${`%${text}%`}`\n            : undefined,\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (\n    row: any,\n    index?: number,\n  ): PriceListB2CDropdownOption => {\n    // Handle LocaleDataType<string> for name\n    const name =\n      typeof row.name === \"string\"\n        ? row.name\n        : row.name?.vi || row.name?.en || row.code || \"\";\n\n    return {\n      label: `${row.code} - ${name}`,\n      value: row.id,\n      code: row.code,\n      name: row.name,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PriceListB2CDropdownOption>> => {\n    // Use buildQueryDataListWithSelect to select only needed columns\n    const result = await this.buildQueryDataListWithSelect(\n      params,\n      {\n        id: sale_b2c_tb_price_lists.id,\n        code: sale_b2c_tb_price_lists.code,\n        name: sale_b2c_tb_price_lists.name,\n      },\n      (query) => {\n        // Filter only active price lists\n        return query.where(eq(sale_b2c_tb_price_lists.status, \"active\"));\n      },\n    );\n\n    return {\n      data: result.data.map((row: any, index: number) =>\n        this.declarationMappingData(row, index),\n      ),\n      total: result.total,\n    };\n  };\n}\n\nexport default PriceListB2CDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/PriceList/PriceListB2CModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":48,"fix":{"range":[104,104],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":57,"fix":{"range":[0,162],"text":"import { and, desc, eq, ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { and, desc, eq, ilike, sql } from \"drizzle-orm\";\n\nimport {\n  NewSaleB2cTbPriceList,\n  sale_b2c_tb_price_lists,\n  SaleB2cTbPriceList,\n} from \"../../schemas/b2c-sales.price-list\";\n\nexport interface PriceListB2CRow {\n  id: string;\n  code: string;\n  name: string | { en: string; vi: string };\n  description?: string | null;\n  type: string;\n  status: string;\n  priority: number;\n  currencyId?: string | null;\n  validFrom: Date;\n  validTo?: Date | null;\n  isDefault: boolean;\n  applicableTo: any;\n  createdAt?: Date | null;\n  updatedAt?: Date | null;\n}\n\nexport interface CreatePriceListB2CParams {\n  code: string;\n  name: { en: string; vi: string };\n  description?: string;\n  type: \"standard\" | \"promotion\" | \"seasonal\" | \"flash_sale\";\n  status: \"draft\" | \"active\" | \"inactive\" | \"expired\";\n  priority?: number;\n  currencyId?: string;\n  validFrom: Date;\n  validTo?: Date | null;\n  isDefault?: boolean;\n  applicableTo: {\n    channels?: string[];\n    stores?: string[];\n    locations?: string[];\n    regions?: string[];\n    customerGroups?: string[];\n  };\n  createdBy?: string;\n}\n\nexport interface UpdatePriceListB2CParams {\n  name?: { en: string; vi: string };\n  description?: string;\n  type?: \"standard\" | \"promotion\" | \"seasonal\" | \"flash_sale\";\n  status?: \"draft\" | \"active\" | \"inactive\" | \"expired\";\n  priority?: number;\n  currencyId?: string;\n  validFrom?: Date;\n  validTo?: Date | null;\n  isDefault?: boolean;\n  applicableTo?: {\n    channels?: string[];\n    stores?: string[];\n    locations?: string[];\n    regions?: string[];\n    customerGroups?: string[];\n  };\n  updatedBy?: string;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport interface ApplicableTo {\n  channels?: string[];\n  stores?: string[];\n  locations?: string[];\n  regions?: string[];\n  customerGroups?: string[];\n}\n\ntype PriceListFilter = {\n  type?: string;\n  status?: string;\n  isDefault?: boolean;\n};\n\nexport default class PriceListB2CViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_price_lists,\n  PriceListB2CRow,\n  PriceListFilter\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_price_lists,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () => {\n    const map = new Map();\n\n    map.set(\"id\", { column: sale_b2c_tb_price_lists.id, sort: false });\n    map.set(\"code\", { column: sale_b2c_tb_price_lists.code, sort: true });\n    map.set(\"name\", { column: sale_b2c_tb_price_lists.name, sort: false });\n    map.set(\"type\", { column: sale_b2c_tb_price_lists.type, sort: true });\n    map.set(\"status\", { column: sale_b2c_tb_price_lists.status, sort: true });\n    map.set(\"priority\", {\n      column: sale_b2c_tb_price_lists.priority,\n      sort: true,\n    });\n    map.set(\"validFrom\", {\n      column: sale_b2c_tb_price_lists.validFrom,\n      sort: true,\n    });\n    map.set(\"validTo\", { column: sale_b2c_tb_price_lists.validTo, sort: true });\n    map.set(\"isDefault\", {\n      column: sale_b2c_tb_price_lists.isDefault,\n      sort: true,\n    });\n    map.set(\"createdAt\", {\n      column: sale_b2c_tb_price_lists.createdAt,\n      sort: true,\n    });\n    map.set(\"updatedAt\", {\n      column: sale_b2c_tb_price_lists.updatedAt,\n      sort: true,\n    });\n\n    return map;\n  };\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) =>\n          text ? ilike(sale_b2c_tb_price_lists.code, `%${text}%`) : undefined,\n      ],\n      [\n        \"name\",\n        (text: string) =>\n          text\n            ? sql`${sale_b2c_tb_price_lists.name}::text ILIKE ${`%${text}%`}`\n            : undefined,\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<PriceListFilter> =>\n    new Map([\n      [\n        \"type\",\n        (value?: unknown, _filters?: PriceListFilter) =>\n          typeof value === \"string\" && value\n            ? eq(sale_b2c_tb_price_lists.type, value)\n            : undefined,\n      ],\n      [\n        \"status\",\n        (value?: unknown, _filters?: PriceListFilter) =>\n          typeof value === \"string\" && value\n            ? eq(sale_b2c_tb_price_lists.status, value)\n            : undefined,\n      ],\n      [\n        \"isDefault\",\n        (value?: unknown, _filters?: PriceListFilter) =>\n          typeof value === \"boolean\"\n            ? eq(sale_b2c_tb_price_lists.isDefault, value)\n            : undefined,\n      ],\n    ]);\n\n  protected declarationMappingData = (row: any): PriceListB2CRow => {\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      type: row.type,\n      status: row.status,\n      priority: row.priority,\n      currencyId: row.currencyId,\n      validFrom: row.validFrom,\n      validTo: row.validTo,\n      isDefault: row.isDefault,\n      applicableTo: row.applicableTo,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n  };\n\n  /**\n   * Get list of price lists (simple list, not for view list data table)\n   */\n  async getList(): Promise<SaleB2cTbPriceList[]> {\n    const db = await this.db;\n\n    return db\n      .select()\n      .from(sale_b2c_tb_price_lists)\n      .orderBy(\n        desc(sale_b2c_tb_price_lists.priority),\n        desc(sale_b2c_tb_price_lists.createdAt),\n      );\n  }\n\n  /**\n   * Get price list by ID\n   */\n  async getById(id: string): Promise<SaleB2cTbPriceList | null> {\n    const [priceList] = await this.db\n      .select()\n      .from(sale_b2c_tb_price_lists)\n      .where(eq(sale_b2c_tb_price_lists.id, id))\n      .limit(1);\n\n    return priceList || null;\n  }\n\n  /**\n   * Create a new price list\n   */\n  async create(params: CreatePriceListB2CParams): Promise<SaleB2cTbPriceList> {\n    // Validate\n    const validation = await this.validatePriceList(params);\n\n    if (!validation.valid) {\n      throw new Error(validation.errors.join(\"; \"));\n    }\n\n    // Check if code already exists\n    const existing = await this.isExistInModelByFieldAndValue({\n      field: \"code\",\n      value: params.code,\n    });\n\n    if (existing.isExist) {\n      throw new Error(`Price list with code \"${params.code}\" already exists`);\n    }\n\n    const now = new Date();\n    const db = await this.db;\n\n    const [priceList] = await db\n      .insert(sale_b2c_tb_price_lists)\n      .values({\n        code: params.code,\n        name: params.name,\n        description: params.description,\n        type: params.type,\n        status: params.status,\n        priority: params.priority ?? 0,\n        currencyId: params.currencyId,\n        validFrom: params.validFrom,\n        validTo: params.validTo,\n        isDefault: params.isDefault ?? false,\n        applicableTo: params.applicableTo,\n        createdBy: params.createdBy,\n        createdAt: now,\n        updatedAt: now,\n      })\n      .returning();\n\n    if (!priceList) {\n      throw new Error(\"Failed to create price list\");\n    }\n\n    return priceList;\n  }\n\n  /**\n   * Update price list\n   */\n  async update(\n    id: string,\n    params: UpdatePriceListB2CParams,\n  ): Promise<SaleB2cTbPriceList> {\n    // Get existing price list\n    const existing = await this.getById(id);\n\n    if (!existing) {\n      throw new Error(`Price list with id \"${id}\" not found`);\n    }\n\n    // Merge with existing data for validation\n    const mergedData = {\n      ...existing,\n      ...params,\n      validFrom: params.validFrom ?? existing.validFrom,\n      validTo: params.validTo !== undefined ? params.validTo : existing.validTo,\n      applicableTo: params.applicableTo ?? existing.applicableTo,\n    };\n\n    // Validate\n    const validation = await this.validatePriceList(mergedData, id);\n\n    if (!validation.valid) {\n      throw new Error(validation.errors.join(\"; \"));\n    }\n\n    const now = new Date();\n    const db = await this.db;\n\n    const [priceList] = await db\n      .update(sale_b2c_tb_price_lists)\n      .set({\n        name: params.name,\n        description: params.description,\n        type: params.type,\n        status: params.status,\n        priority: params.priority,\n        currencyId: params.currencyId,\n        validFrom: params.validFrom,\n        validTo: params.validTo,\n        isDefault: params.isDefault,\n        applicableTo: params.applicableTo,\n        updatedBy: params.updatedBy,\n        updatedAt: now,\n      })\n      .where(eq(sale_b2c_tb_price_lists.id, id))\n      .returning();\n\n    if (!priceList) {\n      throw new Error(\"Failed to update price list\");\n    }\n\n    return priceList;\n  }\n\n  /**\n   * Delete price list\n   */\n  async delete(id: string): Promise<boolean> {\n    // Get existing price list\n    const existing = await this.getById(id);\n\n    if (!existing) {\n      throw new Error(`Price list with id \"${id}\" not found`);\n    }\n\n    // Validate deletion (check if it's the last active standard price list)\n    // Simulate deactivation by setting status to inactive\n    const simulatedData = {\n      ...existing,\n      status: \"inactive\" as const,\n    };\n    const validation = await this.validatePriceList(simulatedData, id);\n\n    if (!validation.valid) {\n      throw new Error(validation.errors.join(\"; \"));\n    }\n\n    const db = await this.db;\n    const result = await db\n      .delete(sale_b2c_tb_price_lists)\n      .where(eq(sale_b2c_tb_price_lists.id, id))\n      .returning();\n\n    return result.length > 0;\n  }\n\n  /**\n   * Validate price list data\n   */\n  private async validatePriceList(\n    data: NewSaleB2cTbPriceList | SaleB2cTbPriceList,\n    existingId?: string,\n  ): Promise<ValidationResult> {\n    const errors: string[] = [];\n\n    // 1. Validate validFrom và validTo\n    if (!data.validFrom) {\n      errors.push(\"validFrom là bắt buộc\");\n    }\n\n    if (data.validTo && data.validFrom && data.validTo < data.validFrom) {\n      errors.push(\"validTo phải >= validFrom\");\n    }\n\n    if (data.type !== \"standard\" && !data.validTo) {\n      errors.push(\n        \"Nếu type != 'standard' thì validTo là bắt buộc (không được NULL)\",\n      );\n    }\n\n    // 2. Validate applicableTo\n    if (!data.applicableTo) {\n      errors.push(\"applicableTo là bắt buộc\");\n    } else {\n      const applicableTo = data.applicableTo as ApplicableTo;\n\n      if (\n        !applicableTo.channels &&\n        !applicableTo.stores &&\n        !applicableTo.locations &&\n        !applicableTo.regions &&\n        !applicableTo.customerGroups\n      ) {\n        errors.push(\n          \"applicableTo phải có ít nhất một trong: channels, stores, locations, regions, customerGroups\",\n        );\n      }\n    }\n\n    // 3. Validate không trùng valid dates cho standard price lists\n    if (data.type === \"standard\" && data.status === \"active\") {\n      const overlapError = await this.checkStandardPriceListOverlap(\n        data,\n        existingId,\n      );\n\n      if (overlapError) {\n        errors.push(overlapError);\n      }\n    }\n\n    // 4. Validate ít nhất 1 standard price list active (chỉ khi update/delete)\n    if (existingId) {\n      const activeStandardError = await this.checkAtLeastOneActiveStandard(\n        data,\n        existingId,\n      );\n\n      if (activeStandardError) {\n        errors.push(activeStandardError);\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Kiểm tra không trùng valid dates cho standard price lists với cùng applicableTo\n   */\n  private async checkStandardPriceListOverlap(\n    data: NewSaleB2cTbPriceList | SaleB2cTbPriceList,\n    existingId?: string,\n  ): Promise<string | null> {\n    if (!data.applicableTo || !data.validFrom) {\n      return null;\n    }\n\n    const applicableTo = data.applicableTo as ApplicableTo;\n    const db = await this.db;\n\n    const existing = await db\n      .select()\n      .from(sale_b2c_tb_price_lists)\n      .where(\n        and(\n          eq(sale_b2c_tb_price_lists.type, \"standard\"),\n          eq(sale_b2c_tb_price_lists.status, \"active\"),\n          sql`${sale_b2c_tb_price_lists.applicableTo} = ${JSON.stringify(applicableTo)}::jsonb`,\n          existingId\n            ? sql`${sale_b2c_tb_price_lists.id} != ${existingId}::uuid`\n            : sql`1=1`,\n        ),\n      );\n\n    for (const existingList of existing) {\n      const existingValidFrom = existingList.validFrom;\n      const existingValidTo = existingList.validTo;\n      const newValidFrom = data.validFrom;\n      const newValidTo = data.validTo;\n\n      if (!newValidTo) {\n        return `Không được phép tạo bảng giá standard mãi mãi khi đã có bảng giá standard khác với cùng applicableTo`;\n      }\n\n      if (!existingValidTo) {\n        return `Không được phép tạo bảng giá standard khi đã có bảng giá standard mãi mãi với cùng applicableTo`;\n      }\n\n      const hasOverlap =\n        (newValidFrom >= existingValidFrom &&\n          newValidFrom <= existingValidTo) ||\n        (newValidTo >= existingValidFrom && newValidTo <= existingValidTo) ||\n        (existingValidFrom >= newValidFrom && existingValidTo <= newValidTo);\n\n      if (hasOverlap) {\n        return `Không được phép tạo bảng giá standard với cùng applicableTo và trùng thời gian áp dụng. Vui lòng kiểm tra valid_from và valid_to.`;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Kiểm tra ít nhất 1 standard price list đang active\n   */\n  private async checkAtLeastOneActiveStandard(\n    data: NewSaleB2cTbPriceList | SaleB2cTbPriceList,\n    existingId: string,\n  ): Promise<string | null> {\n    const db = await this.db;\n    const existing = await db\n      .select()\n      .from(sale_b2c_tb_price_lists)\n      .where(eq(sale_b2c_tb_price_lists.id, existingId))\n      .limit(1);\n\n    if (existing.length === 0) {\n      return null;\n    }\n\n    const existingRecord = existing[0];\n    const isDeactivatingStandard =\n      existingRecord.type === \"standard\" &&\n      existingRecord.status === \"active\" &&\n      (data.status !== \"active\" || data.type !== \"standard\");\n\n    if (!isDeactivatingStandard) {\n      return null;\n    }\n\n    const activeStandardCount = await db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(sale_b2c_tb_price_lists)\n      .where(\n        and(\n          eq(sale_b2c_tb_price_lists.type, \"standard\"),\n          eq(sale_b2c_tb_price_lists.status, \"active\"),\n          sql`${sale_b2c_tb_price_lists.id} != ${existingId}::uuid`,\n        ),\n      );\n\n    const count = Number(activeStandardCount[0]?.count || 0);\n\n    if (count === 0) {\n      return \"Hệ thống bắt buộc phải có ít nhất 1 bảng giá standard đang active.\";\n    }\n\n    return null;\n  }\n\n  /**\n   * Kiểm tra xem có ít nhất 1 standard price list đang active không\n   */\n  async hasActiveStandardPriceList(): Promise<boolean> {\n    const db = await this.db;\n    const result = await db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(sale_b2c_tb_price_lists)\n      .where(\n        and(\n          eq(sale_b2c_tb_price_lists.type, \"standard\"),\n          eq(sale_b2c_tb_price_lists.status, \"active\"),\n        ),\n      );\n\n    const count = Number(result[0]?.count || 0);\n\n    return count > 0;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/PriceList/PriceListB2CViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":42,"fix":{"range":[264,264],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_price_lists } from \"../../schemas/b2c-sales.price-list\";\n\nclass PriceListB2CViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_price_lists,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_price_lists,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_price_lists.id, sort: false }],\n      [\"code\", { column: sale_b2c_tb_price_lists.code, sort: true }],\n      [\"name\", { column: sale_b2c_tb_price_lists.name, sort: false }],\n      [\"type\", { column: sale_b2c_tb_price_lists.type, sort: true }],\n      [\"status\", { column: sale_b2c_tb_price_lists.status, sort: true }],\n      [\"priority\", { column: sale_b2c_tb_price_lists.priority, sort: true }],\n      [\"isDefault\", { column: sale_b2c_tb_price_lists.isDefault, sort: true }],\n      [\"validFrom\", { column: sale_b2c_tb_price_lists.validFrom, sort: true }],\n      [\"validTo\", { column: sale_b2c_tb_price_lists.validTo, sort: true }],\n      [\"createdAt\", { column: sale_b2c_tb_price_lists.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2c_tb_price_lists.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) =>\n          text ? ilike(sale_b2c_tb_price_lists.code, `%${text}%`) : undefined,\n      ],\n      [\n        \"name\",\n        (text: string) =>\n          text\n            ? sql`${sale_b2c_tb_price_lists.name}::text ILIKE ${`%${text}%`}`\n            : undefined,\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    description: row.description,\n    type: row.type,\n    status: row.status,\n    priority: row.priority,\n    currencyId: row.currencyId ?? undefined,\n    validFrom: row.validFrom?.getTime(),\n    validTo: row.validTo?.getTime(),\n    isDefault: row.isDefault,\n    applicableTo: row.applicableTo,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default PriceListB2CViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Sale/SalesOrderB2CModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[235,235],"text":"\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":19,"suggestions":[{"fix":{"range":[2523,2575],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type {\n  CreateSalesOrderB2CInput,\n  UpdateSalesOrderB2CInput,\n} from \"../../models/interfaces/SalesOrderB2C\";\nimport type { NewSaleB2cTbOrder, SaleB2cTbOrder } from \"../../schemas\";\n\nimport { desc, eq, sql } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  base_tb_currencies,\n  base_tb_currencies_exchange_rate,\n} from \"@base/server/schemas\";\n\nimport {\n  sale_b2c_tb_currency_rates,\n  sale_b2c_tb_orders,\n  sale_b2c_tb_order_lines,\n} from \"../../schemas\";\n\nexport default class SalesOrderB2CModel extends BaseModel<\n  typeof sale_b2c_tb_orders\n> {\n  constructor() {\n    super(sale_b2c_tb_orders);\n  }\n\n  list = async (): Promise<SaleB2cTbOrder[]> => {\n    return this.db\n      .select()\n      .from(sale_b2c_tb_orders)\n      .orderBy(desc(sale_b2c_tb_orders.createdAt));\n  };\n\n  getById = async (id: string) => {\n    const [order] = await this.db\n      .select()\n      .from(sale_b2c_tb_orders)\n      .where(eq(sale_b2c_tb_orders.id, id))\n      .limit(1);\n\n    if (!order) {\n      return null;\n    }\n    const lines = await this.db\n      .select()\n      .from(sale_b2c_tb_order_lines)\n      .where(eq(sale_b2c_tb_order_lines.orderId, order.id));\n\n    return { order, lines };\n  };\n\n  create = async (input: CreateSalesOrderB2CInput) => {\n    if (!input.lines?.length) {\n      throw new Error(\"Sales order requires at least one line\");\n    }\n\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `SO-B2C-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    // Get currency rate\n    const currency = input.currency ?? \"VND\";\n    let currencyRate: number | undefined;\n\n    try {\n      const [currencyRecord] = await this.db\n        .select()\n        .from(base_tb_currencies)\n        .where(eq(base_tb_currencies.code, currency))\n        .limit(1);\n\n      if (currencyRecord) {\n        const [latestRate] = await this.db\n          .select()\n          .from(base_tb_currencies_exchange_rate)\n          .where(\n            eq(base_tb_currencies_exchange_rate.currencyId, currencyRecord.id),\n          )\n          .orderBy(desc(base_tb_currencies_exchange_rate.rateDate))\n          .limit(1);\n\n        if (latestRate?.exchangeRate) {\n          currencyRate = Number(latestRate.exchangeRate);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Failed to get currency rate:\", error);\n    }\n\n    return this.db.transaction(async (tx) => {\n      // Tự động tìm default price list nếu không có priceListId\n      let finalPriceListId = input.priceListId;\n\n      let subtotal = 0;\n      let totalDiscount = input.totalDiscount ?? 0;\n      let totalTax = input.totalTax ?? 0;\n      const shippingFee = input.shippingFee ?? 0;\n\n      // Calculate line totals\n      const lineData: Array<{\n        productId: string;\n        quantity: number;\n        unitPrice: number;\n        description?: string;\n        lineDiscount: number;\n        taxRate: number;\n        lineSubtotal: number;\n        lineTax: number;\n        lineTotal: number;\n      }> = [];\n\n      for (const line of input.lines) {\n        const quantity = Number(line.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const unitPrice = Number(line.unitPrice ?? 0);\n        const lineDiscount = Number(line.lineDiscount ?? 0);\n        const taxRate = Number(line.taxRate ?? 0);\n\n        const lineSubtotal = quantity * unitPrice;\n        const lineTax = ((lineSubtotal - lineDiscount) * taxRate) / 100;\n        const lineTotal = lineSubtotal - lineDiscount + lineTax;\n\n        subtotal += lineSubtotal;\n        totalTax += lineTax;\n\n        lineData.push({\n          productId: line.productId,\n          quantity,\n          unitPrice,\n          description: line.description,\n          lineDiscount,\n          taxRate,\n          lineSubtotal,\n          lineTax,\n          lineTotal,\n        });\n      }\n\n      const grandTotal = subtotal - totalDiscount + totalTax + shippingFee;\n\n      const orderPayload: NewSaleB2cTbOrder = {\n        code: generatedCode,\n        customerName: input.customerName.trim(),\n        customerPhone: input.customerPhone,\n        customerEmail: input.customerEmail,\n        deliveryAddress: input.deliveryAddress,\n        paymentMethodId: input.paymentMethodId,\n        shippingMethodId: input.shippingMethodId,\n        shippingTermsId: input.shippingTermsId,\n        requireInvoice: input.requireInvoice ?? false,\n        status: \"draft\",\n        expectedDate: input.expectedDate\n          ? new Date(input.expectedDate)\n          : undefined,\n        warehouseId: input.warehouseId,\n        currency: currency,\n        currencyRate: currencyRate?.toString(),\n        priceListId: finalPriceListId,\n        notes: input.notes,\n        subtotal: subtotal.toString(),\n        totalDiscount: totalDiscount.toString(),\n        totalTax: totalTax.toString(),\n        shippingFee: shippingFee.toString(),\n        grandTotal: grandTotal.toString(),\n        totalAmount: grandTotal.toString(),\n        createdBy: input.userId,\n      };\n\n      const [order] = await tx\n        .insert(sale_b2c_tb_orders)\n        .values(orderPayload)\n        .returning();\n\n      // Save currency rate snapshot\n      if (currencyRate) {\n        await tx.insert(sale_b2c_tb_currency_rates).values({\n          orderType: \"B2C\",\n          orderId: order.id,\n          currencyCode: currency,\n          exchangeRate: currencyRate.toString(),\n          rateDate: now,\n          source: \"api\",\n        });\n      }\n\n      // Insert lines\n      for (const line of lineData) {\n        await tx.insert(sale_b2c_tb_order_lines).values({\n          orderId: order.id,\n          productId: line.productId,\n          description: line.description,\n          quantityOrdered: line.quantity.toString(),\n          quantityDelivered: \"0\",\n          unitPrice: line.unitPrice.toString(),\n          lineDiscount: line.lineDiscount.toString(),\n          taxRate: line.taxRate.toString(),\n          lineTax: line.lineTax.toString(),\n          lineSubtotal: line.lineSubtotal.toString(),\n          lineTotal: line.lineTotal.toString(),\n        });\n      }\n\n      await tx\n        .update(sale_b2c_tb_orders)\n        .set({\n          updatedAt: now,\n        })\n        .where(eq(sale_b2c_tb_orders.id, order.id));\n\n      const result = await this.getById(order.id);\n\n      if (!result) {\n        throw new Error(\"Failed to load sales order after creation\");\n      }\n\n      return result;\n    });\n  };\n\n  update = async (input: UpdateSalesOrderB2CInput) => {\n    const orderData = await this.getById(input.id);\n\n    if (!orderData) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    if (!input.lines?.length) {\n      throw new Error(\"Sales order requires at least one line\");\n    }\n\n    const now = new Date();\n    let subtotal = 0;\n    let totalDiscount =\n      input.totalDiscount ?? Number(orderData.order.totalDiscount);\n    let totalTax = input.totalTax ?? Number(orderData.order.totalTax);\n    const shippingFee =\n      input.shippingFee ?? Number(orderData.order.shippingFee);\n\n    // Calculate line totals\n    const lineData: Array<{\n      productId: string;\n      quantity: number;\n      unitPrice: number;\n      description?: string;\n      lineDiscount: number;\n      taxRate: number;\n      lineSubtotal: number;\n      lineTax: number;\n      lineTotal: number;\n    }> = [];\n\n    for (const line of input.lines) {\n      const quantity = Number(line.quantity ?? 0);\n\n      if (quantity <= 0) continue;\n\n      const unitPrice = Number(line.unitPrice ?? 0);\n      const lineDiscount = Number(line.lineDiscount ?? 0);\n      const taxRate = Number(line.taxRate ?? 0);\n\n      const lineSubtotal = quantity * unitPrice;\n      const lineTax = ((lineSubtotal - lineDiscount) * taxRate) / 100;\n      const lineTotal = lineSubtotal - lineDiscount + lineTax;\n\n      subtotal += lineSubtotal;\n      totalTax += lineTax;\n\n      lineData.push({\n        productId: line.productId,\n        quantity,\n        unitPrice,\n        description: line.description,\n        lineDiscount,\n        taxRate,\n        lineSubtotal,\n        lineTax,\n        lineTotal,\n      });\n    }\n\n    const grandTotal = subtotal - totalDiscount + totalTax + shippingFee;\n\n    return this.db.transaction(async (tx) => {\n      // Update order\n      const updatePayload: Partial<NewSaleB2cTbOrder> = {\n        customerName: input.customerName?.trim(),\n        customerPhone: input.customerPhone,\n        customerEmail: input.customerEmail,\n        deliveryAddress: input.deliveryAddress,\n        paymentMethodId: input.paymentMethodId,\n        shippingMethodId: input.shippingMethodId,\n        shippingTermsId: input.shippingTermsId,\n        requireInvoice: input.requireInvoice,\n        expectedDate: input.expectedDate\n          ? new Date(input.expectedDate)\n          : undefined,\n        warehouseId: input.warehouseId,\n        currency: input.currency,\n        notes: input.notes,\n        subtotal: subtotal.toString(),\n        totalDiscount: totalDiscount.toString(),\n        totalTax: totalTax.toString(),\n        shippingFee: shippingFee.toString(),\n        grandTotal: grandTotal.toString(),\n        totalAmount: grandTotal.toString(),\n        updatedAt: now,\n      };\n\n      await tx\n        .update(sale_b2c_tb_orders)\n        .set(updatePayload)\n        .where(eq(sale_b2c_tb_orders.id, input.id));\n\n      // Delete existing lines\n      await tx\n        .delete(sale_b2c_tb_order_lines)\n        .where(eq(sale_b2c_tb_order_lines.orderId, input.id));\n\n      // Insert new lines\n      for (const line of lineData) {\n        await tx.insert(sale_b2c_tb_order_lines).values({\n          orderId: input.id,\n          productId: line.productId,\n          description: line.description,\n          quantityOrdered: line.quantity.toString(),\n          quantityDelivered: \"0\",\n          unitPrice: line.unitPrice.toString(),\n          lineDiscount: line.lineDiscount.toString(),\n          taxRate: line.taxRate.toString(),\n          lineTax: line.lineTax.toString(),\n          lineSubtotal: line.lineSubtotal.toString(),\n          lineTotal: line.lineTotal.toString(),\n        });\n      }\n\n      return this.getById(input.id);\n    });\n  };\n\n  confirm = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(sale_b2c_tb_orders)\n      .set({\n        status: \"confirmed\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(sale_b2c_tb_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    return updated;\n  };\n\n  complete = async (orderId: string) => {\n    const now = new Date();\n    const [updated] = await this.db\n      .update(sale_b2c_tb_orders)\n      .set({\n        status: \"completed\",\n        completedAt: now,\n        updatedAt: sql`now()`,\n      })\n      .where(eq(sale_b2c_tb_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    return updated;\n  };\n\n  cancel = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(sale_b2c_tb_orders)\n      .set({\n        status: \"cancelled\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(sale_b2c_tb_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Sales order not found\");\n    }\n\n    return updated;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Sale/SalesOrderB2CViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { sale_b2c_tb_orders } from \"../../schemas\";\n\nclass SalesOrderB2CViewListModel extends BaseViewListModel<\n  typeof sale_b2c_tb_orders,\n  any\n> {\n  constructor() {\n    super({\n      table: sale_b2c_tb_orders,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: sale_b2c_tb_orders.id, sort: true }],\n      [\"code\", { column: sale_b2c_tb_orders.code, sort: true }],\n      [\"customerName\", { column: sale_b2c_tb_orders.customerName, sort: true }],\n      [\"status\", { column: sale_b2c_tb_orders.status, sort: true }],\n      [\"warehouseId\", { column: sale_b2c_tb_orders.warehouseId, sort: true }],\n      [\"expectedDate\", { column: sale_b2c_tb_orders.expectedDate, sort: true }],\n      [\"grandTotal\", { column: sale_b2c_tb_orders.grandTotal, sort: true }],\n      [\"totalAmount\", { column: sale_b2c_tb_orders.totalAmount, sort: true }],\n      [\"currency\", { column: sale_b2c_tb_orders.currency, sort: true }],\n      [\"completedAt\", { column: sale_b2c_tb_orders.completedAt, sort: true }],\n      [\"notes\", { column: sale_b2c_tb_orders.notes, sort: false }],\n      [\"createdAt\", { column: sale_b2c_tb_orders.createdAt, sort: true }],\n      [\"updatedAt\", { column: sale_b2c_tb_orders.updatedAt, sort: true }],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(sale_b2c_tb_orders.code, text)],\n      [\n        \"customerName\",\n        (text: string) => ilike(sale_b2c_tb_orders.customerName, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    customerName: row.customerName,\n    status: row.status,\n    warehouseId: row.warehouseId ?? undefined,\n    expectedDate: row.expectedDate?.getTime(),\n    grandTotal: row.grandTotal ?? \"0\",\n    totalAmount: row.totalAmount ?? \"0\",\n    currency: row.currency ?? \"USD\",\n    completedAt: row.completedAt?.getTime(),\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default SalesOrderB2CViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/Sale/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/interfaces/Customer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/interfaces/MasterData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/interfaces/SalesOrderB2B.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/models/interfaces/SalesOrderB2C.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.currency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.customer.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":30,"fix":{"range":[144,144],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_payment_terms } from \"@base/server/schemas/base.payment-term\";\n\nimport { mdlSaleB2cSchema } from \"./schema\";\n\n// Customer Companies (B2B customers) - Note: This should be in b2b-sales module\nexport const sale_b2c_tb_customer_companies = mdlSaleB2cSchema.table(\n  \"customer_companies\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    name: varchar(\"name\", { length: 256 }).notNull(),\n    taxId: varchar(\"tax_id\", { length: 50 }),\n    address: text(\"address\"),\n    phone: varchar(\"phone\", { length: 20 }),\n    email: varchar(\"email\", { length: 255 }),\n    website: varchar(\"website\", { length: 255 }),\n    contactPerson: varchar(\"contact_person\", { length: 128 }),\n    creditLimit: numeric(\"credit_limit\", { precision: 14, scale: 2 }),\n    paymentTermsId: uuid(\"payment_terms_id\").references(\n      () => base_tb_payment_terms.id,\n      { onDelete: \"set null\" },\n    ),\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"customer_companies_code_idx\").on(table.code),\n    index(\"customer_companies_name_idx\").on(table.name),\n    index(\"customer_companies_tax_id_idx\").on(table.taxId),\n    index(\"customer_companies_active_idx\").on(table.isActive),\n  ],\n);\n\nexport type SaleB2cTbCustomerCompany =\n  typeof sale_b2c_tb_customer_companies.$inferSelect;\nexport type NewSaleB2cTbCustomerCompany =\n  typeof sale_b2c_tb_customer_companies.$inferInsert;\n\n// Customer Individuals (B2C customers)\nexport const sale_b2c_tb_customers = mdlSaleB2cSchema.table(\n  \"customers\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    firstName: varchar(\"first_name\", { length: 128 }).notNull(),\n    lastName: varchar(\"last_name\", { length: 128 }).notNull(),\n    phone: varchar(\"phone\", { length: 20 }),\n    email: varchar(\"email\", { length: 255 }),\n    address: text(\"address\"),\n    dateOfBirth: timestamp(\"date_of_birth\", { withTimezone: true }),\n    gender: varchar(\"gender\", { length: 10 }), // 'male', 'female', 'other'\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"customers_code_idx\").on(table.code),\n    index(\"customers_name_idx\").on(table.firstName, table.lastName),\n    index(\"customers_phone_idx\").on(table.phone),\n    index(\"customers_email_idx\").on(table.email),\n    index(\"customers_active_idx\").on(table.isActive),\n  ],\n);\n\nexport type SaleB2cTbCustomer = typeof sale_b2c_tb_customers.$inferSelect;\nexport type NewSaleB2cTbCustomer = typeof sale_b2c_tb_customers.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.delivery.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":30,"fix":{"range":[133,133],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\n\nimport { mdlSaleB2cSchema } from \"./schema\";\n\n// Sales Order Delivery - Track deliveries from orders (warehouse receipts)\nexport const sale_b2c_tb_deliveries = mdlSaleB2cSchema.table(\n  \"deliveries\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    orderType: varchar(\"order_type\", { length: 10 }).notNull(), // 'B2B' | 'B2C'\n    orderId: uuid(\"order_id\").notNull(),\n    warehouseId: uuid(\"warehouse_id\")\n      .notNull()\n      .references(() => stock_tb_stock_warehouses.id, { onDelete: \"restrict\" }),\n    deliveryDate: timestamp(\"delivery_date\", { withTimezone: true }).notNull(),\n    reference: varchar(\"reference\", { length: 128 }), // Reference number for the delivery\n    note: text(\"note\"),\n    status: varchar(\"status\", { length: 20 }).notNull().default(\"draft\"), // draft, completed, cancelled\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"deliveries_order_idx\").on(table.orderType, table.orderId),\n    index(\"deliveries_warehouse_idx\").on(table.warehouseId),\n    index(\"deliveries_date_idx\").on(table.deliveryDate),\n    index(\"deliveries_status_idx\").on(table.status),\n  ],\n);\n\nexport type SaleB2cTbDelivery = typeof sale_b2c_tb_deliveries.$inferSelect;\nexport type NewSaleB2cTbDelivery = typeof sale_b2c_tb_deliveries.$inferInsert;\n\n// Delivery Lines - Track which order lines are delivered\nexport const sale_b2c_tb_delivery_lines = mdlSaleB2cSchema.table(\n  \"delivery_lines\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    deliveryId: uuid(\"delivery_id\")\n      .notNull()\n      .references(() => sale_b2c_tb_deliveries.id, { onDelete: \"cascade\" }),\n    orderType: varchar(\"order_type\", { length: 10 }).notNull(), // 'B2B' | 'B2C'\n    orderLineId: uuid(\"order_line_id\").notNull(), // Reference to order line (B2B or B2C)\n    quantity: numeric(\"quantity\", { precision: 14, scale: 2 }).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => [\n    index(\"delivery_lines_delivery_idx\").on(table.deliveryId),\n    index(\"delivery_lines_order_line_idx\").on(\n      table.orderType,\n      table.orderLineId,\n    ),\n  ],\n);\n\nexport type SaleB2cTbDeliveryLine =\n  typeof sale_b2c_tb_delivery_lines.$inferSelect;\nexport type NewSaleB2cTbDeliveryLine =\n  typeof sale_b2c_tb_delivery_lines.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.order-line.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":80,"fix":{"range":[114,114],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport { index, numeric, timestamp, uuid, varchar } from \"drizzle-orm/pg-core\";\nimport { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\n\nimport { mdlSaleB2cSchema } from \"./schema\";\nimport { sale_b2c_tb_orders } from \"./b2c-sales.order\";\n\nexport const sale_b2c_tb_order_lines = mdlSaleB2cSchema.table(\n  \"order_lines\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    orderId: uuid(\"order_id\")\n      .notNull()\n      .references(() => sale_b2c_tb_orders.id, { onDelete: \"cascade\" }),\n    productId: uuid(\"product_id\")\n      .notNull()\n      .references(() => product_tb_product_masters.id, {\n        onDelete: \"restrict\",\n      }),\n    description: varchar(\"description\", { length: 256 }),\n    quantityOrdered: numeric(\"quantity_ordered\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    quantityDelivered: numeric(\"quantity_delivered\", {\n      precision: 14,\n      scale: 2,\n    })\n      .notNull()\n      .default(\"0\"),\n    unitPrice: numeric(\"unit_price\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n\n    // Pricing fields\n    lineDiscount: numeric(\"line_discount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Fixed amount discount\n    taxRate: numeric(\"tax_rate\", { precision: 5, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Tax rate percentage\n    lineTax: numeric(\"line_tax\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Calculated tax amount\n    lineSubtotal: numeric(\"line_subtotal\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // quantity * unitPrice\n    lineTotal: numeric(\"line_total\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // lineSubtotal - lineDiscount + lineTax\n\n    // Price source tracking (for audit and manual override)\n    priceSource: varchar(\"price_source\", { length: 20 })\n      .notNull()\n      .default(\"price_list\"), // 'price_list' | 'manual_override' | 'product_default'\n    priceListItemId: uuid(\"price_list_item_id\"), // ID của price_list_item đã dùng (để audit)\n    pricingRuleId: uuid(\"pricing_rule_id\"), // ID của pricing_rule đã dùng (để audit)\n    basePrice: numeric(\"base_price\", { precision: 18, scale: 4 }), // Giá gốc trước khi áp dụng rules\n    originalUnitPrice: numeric(\"original_unit_price\", {\n      precision: 18,\n      scale: 4,\n    }), // Giá từ price list (trước override)\n\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => [\n    index(\"order_lines_order_idx\").on(table.orderId),\n    index(\"order_lines_product_idx\").on(table.productId),\n    index(\"order_lines_price_source_idx\").on(table.priceSource),\n  ],\n);\n\nexport type SaleB2cTbOrderLine = typeof sale_b2c_tb_order_lines.$inferSelect;\nexport type NewSaleB2cTbOrderLine = typeof sale_b2c_tb_order_lines.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.order.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":87,"fix":{"range":[338,338],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/schemas/base.payment-method`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":35,"fix":{"range":[0,374],"text":"import { sql } from \"drizzle-orm\";\nimport { base_tb_payment_methods } from \"@base/server/schemas/base.payment-method\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/server/schemas/base.payment-method`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":30,"fix":{"range":[0,484],"text":"import {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_payment_methods } from \"@base/server/schemas/base.payment-method\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\nimport { sql } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { base_tb_payment_methods } from \"@base/server/schemas/base.payment-method\";\nimport { base_tb_shipping_methods } from \"@base/server/schemas/base.shipping-method\";\nimport { base_tb_shipping_terms } from \"@base/server/schemas/base.shipping-term\";\nimport { stock_tb_stock_warehouses } from \"@mdl/stock/server/schemas/stock.warehouse\";\nimport { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  index,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { sale_b2c_tb_price_lists } from \"./b2c-sales.price-list\";\nimport { mdlSaleB2cSchema } from \"./schema\";\n\nexport const sale_b2c_tb_orders = mdlSaleB2cSchema.table(\n  \"orders\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    status: varchar(\"status\", { length: 20 }).notNull().default(\"draft\"),\n\n    // B2C specific customer info\n    customerName: varchar(\"customer_name\", { length: 128 }).notNull(),\n    customerPhone: varchar(\"customer_phone\", { length: 20 }),\n    customerEmail: varchar(\"customer_email\", { length: 255 }),\n    deliveryAddress: text(\"delivery_address\"),\n\n    // Business fields\n    paymentMethodId: uuid(\"payment_method_id\").references(\n      () => base_tb_payment_methods.id,\n      { onDelete: \"set null\" },\n    ),\n    shippingMethodId: uuid(\"shipping_method_id\").references(\n      () => base_tb_shipping_methods.id,\n      { onDelete: \"set null\" },\n    ),\n    shippingTermsId: uuid(\"shipping_terms_id\").references(\n      () => base_tb_shipping_terms.id,\n      { onDelete: \"set null\" },\n    ),\n    requireInvoice: boolean(\"require_invoice\").default(false).notNull(),\n\n    // Pricing\n    priceListId: uuid(\"price_list_id\").references(\n      () => sale_b2c_tb_price_lists.id,\n      { onDelete: \"set null\" },\n    ),\n\n    // Common fields\n    warehouseId: uuid(\"warehouse_id\").references(\n      () => stock_tb_stock_warehouses.id,\n      { onDelete: \"set null\" },\n    ),\n    expectedDate: timestamp(\"expected_date\", { withTimezone: true }),\n\n    // Pricing fields\n    subtotal: numeric(\"subtotal\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalDiscount: numeric(\"total_discount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalTax: numeric(\"total_tax\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    shippingFee: numeric(\"shipping_fee\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    grandTotal: numeric(\"grand_total\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"),\n    totalAmount: numeric(\"total_amount\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"0\"), // Alias for grandTotal for compatibility\n    currency: varchar(\"currency\", { length: 8 }).default(\"USD\"),\n    currencyRate: numeric(\"currency_rate\", { precision: 14, scale: 6 }),\n\n    // B2C specific\n    completedAt: timestamp(\"completed_at\", { withTimezone: true }),\n\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n  },\n  (table) => [\n    index(\"orders_code_idx\").on(table.code),\n    index(\"orders_customer_idx\").on(table.customerName),\n    index(\"orders_status_idx\").on(table.status),\n    index(\"orders_warehouse_idx\").on(table.warehouseId),\n    index(\"orders_expected_idx\").on(table.expectedDate),\n    index(\"orders_created_idx\").on(table.createdAt),\n    index(\"orders_completed_idx\").on(table.completedAt),\n    index(\"orders_price_list_idx\").on(table.priceListId),\n  ],\n);\n\nexport type SaleB2cTbOrder = typeof sale_b2c_tb_orders.$inferSelect;\nexport type NewSaleB2cTbOrder = typeof sale_b2c_tb_orders.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.price-list-item.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":91,"fix":{"range":[179,179],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@mdl/product/server/schemas/product.master`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":35,"fix":{"range":[0,215],"text":"import { sql } from \"drizzle-orm\";\nimport { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\nimport { product_tb_product_variants } from \"@mdl/product/server/schemas/product.variant\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@mdl/product/server/schemas/product.master`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":30,"fix":{"range":[0,336],"text":"import {\n  boolean,\n  index,\n  integer,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\nimport { product_tb_product_variants } from \"@mdl/product/server/schemas/product.variant\";\nimport { sql } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\nimport { product_tb_product_variants } from \"@mdl/product/server/schemas/product.variant\";\nimport { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  index,\n  integer,\n  numeric,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { sale_b2c_tb_price_lists } from \"./b2c-sales.price-list\";\nimport { mdlSaleB2cSchema } from \"./schema\";\n\n// ============================================\n// Price List Item B2C\n// ============================================\nexport const sale_b2c_tb_price_list_items = mdlSaleB2cSchema.table(\n  \"price_list_items\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    priceListId: uuid(\"price_list_id\")\n      .notNull()\n      .references(() => sale_b2c_tb_price_lists.id, { onDelete: \"cascade\" }),\n    productVariantId: uuid(\"product_variant_id\")\n      .notNull()\n      .references(() => product_tb_product_variants.id, {\n        onDelete: \"restrict\",\n      }),\n    productMasterId: uuid(\"product_master_id\")\n      .notNull()\n      .references(() => product_tb_product_masters.id, {\n        onDelete: \"restrict\",\n      }),\n    pricingType: varchar(\"pricing_type\", { length: 20 })\n      .notNull()\n      .default(\"fixed\"), // 'fixed' | 'percentage_discount' | 'tiered'\n    basePrice: numeric(\"base_price\", { precision: 18, scale: 4 }),\n    salePrice: numeric(\"sale_price\", { precision: 18, scale: 4 }),\n    discountType: varchar(\"discount_type\", { length: 20 }), // NULL | 'percentage' | 'fixed_amount'\n    discountValue: numeric(\"discount_value\", { precision: 18, scale: 4 }),\n    finalPrice: numeric(\"final_price\", { precision: 18, scale: 4 }),\n    minQuantity: numeric(\"min_quantity\", { precision: 14, scale: 2 })\n      .notNull()\n      .default(\"1\"),\n    maxQuantity: numeric(\"max_quantity\", { precision: 14, scale: 2 }),\n    uomId: uuid(\"uom_id\"), // FK -> unit_of_measures\n    taxIncluded: boolean(\"tax_included\").notNull().default(false),\n    taxRateId: uuid(\"tax_rate_id\"), // FK -> tax_rates\n    validFrom: timestamp(\"valid_from\", { withTimezone: true }),\n    validTo: timestamp(\"valid_to\", { withTimezone: true }),\n    isActive: boolean(\"is_active\").notNull().default(true),\n    priority: integer(\"priority\").notNull().default(0),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => [\n    index(\"price_list_items_price_list_idx\").on(table.priceListId),\n    index(\"price_list_items_product_variant_idx\").on(table.productVariantId),\n    index(\"price_list_items_product_master_idx\").on(table.productMasterId),\n    index(\"price_list_items_active_idx\")\n      .on(table.isActive)\n      .where(sql`${table.isActive} = true`),\n    index(\"price_list_items_valid_dates_idx\").on(\n      table.validFrom,\n      table.validTo,\n    ),\n    index(\"price_list_items_lookup_idx\").on(\n      table.productVariantId,\n      table.priceListId,\n      table.isActive,\n    ),\n  ],\n);\n\nexport type SaleB2cTbPriceListItem =\n  typeof sale_b2c_tb_price_list_items.$inferSelect;\nexport type NewSaleB2cTbPriceListItem =\n  typeof sale_b2c_tb_price_list_items.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.price-list.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.price-tier.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/b2c-sales.pricing-rule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/b2c-sales/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Candidate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Certificate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Contract.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Course.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Department.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Employee.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/JobRequisition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/LeaveRequest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/LeaveType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Payroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/PerformanceReview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/interface/Timesheet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/CandidateCreatePage/CandidateCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":78,"fix":{"range":[162,162],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,208],"text":"import { useTranslations } from \"next-intl\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[15,253],"text":"import { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport CandidateForm, {\n  type CandidateFormValues,\n} from \"../components/CandidateForm/CandidateForm\";\n\nexport default function CandidateCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.candidates\");\n\n  const {\n    handleSubmit: submitCandidate,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof candidateService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await candidateService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateCandidate\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-candidates\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/candidates/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CandidateFormValues) => {\n    await submitCandidate({\n      requisitionId: values.requisitionId.trim(),\n      firstName: values.firstName?.trim() || null,\n      lastName: values.lastName?.trim() || null,\n      fullName: values.fullName || { vi: \"\", en: \"\" },\n      email: values.email?.trim() || null,\n      phone: values.phone?.trim() || null,\n      dateOfBirth: values.dateOfBirth?.trim() || null,\n      gender: values.gender?.trim() || null,\n      address: values.address || null,\n      cvUrl: values.cvUrl?.trim() || null,\n      coverLetter: values.coverLetter?.trim() || null,\n      source: values.source?.trim() || null,\n      status: values.status || \"applied\",\n      stage: values.stage?.trim() || null,\n      rating: values.rating || null,\n      notes: values.notes?.trim() || null,\n    });\n  };\n\n  return (\n    <CandidateForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/candidates\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/CandidateCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/CandidateEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":78,"fix":{"range":[220,220],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,271],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,316],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,372],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport CandidateForm, {\n  type CandidateFormValues,\n} from \"./components/CandidateForm/CandidateForm\";\n\nexport default function CandidateEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.candidates\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: candidateData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-candidates\", id],\n    queryFn: async () => {\n      const response = await candidateService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadCandidate\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitCandidate,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof candidateService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await candidateService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateCandidate\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-candidates\"], [\"hrm-candidates\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/candidates/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CandidateFormValues) => {\n    await submitCandidate({\n      id,\n      requisitionId: values.requisitionId.trim(),\n      firstName: values.firstName?.trim() || null,\n      lastName: values.lastName?.trim() || null,\n      fullName: values.fullName || { vi: \"\", en: \"\" },\n      email: values.email?.trim() || null,\n      phone: values.phone?.trim() || null,\n      dateOfBirth: values.dateOfBirth?.trim() || null,\n      gender: values.gender?.trim() || null,\n      address: values.address || null,\n      cvUrl: values.cvUrl?.trim() || null,\n      coverLetter: values.coverLetter?.trim() || null,\n      source: values.source?.trim() || null,\n      status: values.status || \"applied\",\n      stage: values.stage?.trim() || null,\n      rating: values.rating || null,\n      notes: values.notes?.trim() || null,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!candidateData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <CandidateForm\n      defaultValues={{\n        requisitionId: candidateData.requisitionId,\n        firstName: candidateData.firstName || \"\",\n        lastName: candidateData.lastName || \"\",\n        fullName: (candidateData.fullName as any) || { vi: \"\", en: \"\" },\n        email: candidateData.email || \"\",\n        phone: candidateData.phone || \"\",\n        dateOfBirth: candidateData.dateOfBirth || \"\",\n        gender: candidateData.gender || \"\",\n        address: candidateData.address as any,\n        cvUrl: candidateData.cvUrl || \"\",\n        coverLetter: candidateData.coverLetter || \"\",\n        source: candidateData.source || \"\",\n        status: candidateData.status,\n        stage: candidateData.stage || \"\",\n        rating: candidateData.rating || undefined,\n        notes: candidateData.notes || \"\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/candidates/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/CandidateViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":76,"fix":{"range":[15,546],"text":"import { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { IBaseDigitViewer, LoadingOverlay } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `next/navigation`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":72,"fix":{"range":[91,546],"text":"import { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":65,"fix":{"range":[227,227],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/utils/date/formatDate` import should occur after import of `next/navigation`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":65,"fix":{"range":[163,546],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":48,"fix":{"range":[316,316],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":78,"fix":{"range":[394,394],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/CandidateService` import should occur after import of `next/navigation`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":78,"fix":{"range":[317,546],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"\"use client\";\n\nimport { IBaseDigitViewer, LoadingOverlay } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { candidateService } from \"@mdl/hrm/client/services/CandidateService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nexport default function CandidateViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.candidates\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: candidateData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-candidates\", id],\n    queryFn: async () => {\n      const response = await candidateService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadCandidate\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!candidateData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/candidates\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/candidates/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.fullName\")}\n              value={getLocalizedText(candidateData.fullName)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.firstName\")}\n              value={candidateData.firstName}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.lastName\")}\n              value={candidateData.lastName}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.email\")}\n              value={candidateData.email}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.phone\")}\n              value={candidateData.phone}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.dateOfBirth\")}\n              value={formatDate(candidateData.dateOfBirth)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.gender\")}\n              value={candidateData.gender}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.requisition\")}\n              value={candidateData.requisition?.requisitionNumber || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={candidateData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.stage\")}\n              value={candidateData.stage || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.rating\")}\n              value={candidateData.rating ? `${candidateData.rating}/5` : \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.source\")}\n              value={candidateData.source || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.cvUrl\")}\n              value={candidateData.cvUrl || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.appliedDate\")}\n              value={formatDate(candidateData.appliedDate)}\n            />\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.coverLetter\")}\n                value={candidateData.coverLetter || \"—\"}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.notes\")}\n                value={candidateData.notes || \"—\"}\n              />\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/CandidatesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { CandidateDto } from \"@mdl/hrm/client/interface/Candidate\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype CandidateRow = CandidateDto & {\n  appliedDate?: number | string | null;\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function CandidatesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.candidates\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<CandidateRow>[]>(\n    () => [\n      {\n        key: \"fullName\",\n        label: t(\"labels.fullName\"),\n        render: (value, row) => {\n          if (!row?.id) return getLocalizedText(value);\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/candidates/view/${row.id}`}>\n              {getLocalizedText(value)}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"email\",\n        label: t(\"labels.email\"),\n      },\n      {\n        key: \"phone\",\n        label: t(\"labels.phone\"),\n      },\n      {\n        key: \"requisition\",\n        label: t(\"labels.requisition\"),\n        render: (value, row) => row.requisition?.requisitionNumber || \"—\",\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"applied\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"stage\",\n        label: t(\"labels.stage\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"rating\",\n        label: t(\"labels.rating\"),\n        render: (value) => (value ? `${value}/5` : \"—\"),\n      },\n      {\n        key: \"appliedDate\",\n        label: t(\"labels.appliedDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/candidates/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<CandidateRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/candidates/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.candidate\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/components/CandidateForm/CandidateForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[157,157],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[15,526],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":48,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createCandidateValidation,\n  type CandidateFormValues,\n} from \"../../validation/candidateValidation\";\n\nexport type { CandidateFormValues };\n\ninterface CandidateFormProps {\n  onSubmit: (values: CandidateFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<CandidateFormValues>;\n}\n\nexport default function CandidateForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: CandidateFormProps) {\n  const t = useTranslations(\"hrm.candidates\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createCandidateValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<CandidateFormValues>({\n    resolver: valibotResolver(validation.candidateFormSchema) as any,\n    defaultValues: {\n      status: \"applied\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<CandidateFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"requisitionId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.requisition\")}\n                  model=\"hrm.job-requisition.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"fullName\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.fullName\")}\n                  size=\"sm\"\n                  value={field.value as any}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"firstName\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.firstName\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"lastName\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.lastName\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"email\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.email\")}\n                  size=\"sm\"\n                  type=\"email\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"phone\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.phone\")}\n                  size=\"sm\"\n                  type=\"tel\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"dateOfBirth\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.dateOfBirth\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"gender\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.gender\")}\n                  model=\"base-gender\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"cvUrl\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.cvUrl\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"source\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.source\")}\n                  model=\"base-recruitment-source\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-candidate-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"stage\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.stage\")}\n                  model=\"base-candidate-stage\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"rating\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.rating\")}\n                  max={5}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ?? null}\n                  onValueChange={(val) => field.onChange(val ?? undefined)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"coverLetter\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.coverLetter\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.notes\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Candidates/validation/candidateValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/CertificateCreatePage/CertificateCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { certificateService } from \"@mdl/hrm/client/services/CertificateService\";\n\nimport CertificateForm, {\n  type CertificateFormValues,\n} from \"../components/CertificateForm/CertificateForm\";\n\nexport default function CertificateCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.certificates\");\n\n  const {\n    handleSubmit: submitCertificate,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof certificateService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await certificateService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateCertificate\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-certificates\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/certificates/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CertificateFormValues) => {\n    await submitCertificate({\n      employeeId: values.employeeId.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      issuer: values.issuer.trim(),\n      certificateNumber: values.certificateNumber?.trim() || null,\n      issueDate: values.issueDate.trim(),\n      expiryDate: values.expiryDate?.trim() || null,\n      documentUrl: values.documentUrl?.trim() || null,\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  return (\n    <CertificateForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/certificates\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/CertificateCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/CertificateEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":56,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { certificateService } from \"@mdl/hrm/client/services/CertificateService\";\nimport { LoadingOverlay } from \"@base/client/components\";\n\nimport CertificateForm, {\n  type CertificateFormValues,\n} from \"./components/CertificateForm/CertificateForm\";\n\nexport default function CertificateEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.certificates\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: certificateData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-certificates\", id],\n    queryFn: async () => {\n      const response = await certificateService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadCertificate\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitCertificate,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof certificateService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await certificateService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateCertificate\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-certificates\"], [\"hrm-certificates\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/certificates/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CertificateFormValues) => {\n    await submitCertificate({\n      id,\n      employeeId: values.employeeId.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      issuer: values.issuer.trim(),\n      certificateNumber: values.certificateNumber?.trim() || null,\n      issueDate: values.issueDate.trim(),\n      expiryDate: values.expiryDate?.trim() || null,\n      documentUrl: values.documentUrl?.trim() || null,\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!certificateData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <CertificateForm\n      defaultValues={{\n        employeeId: certificateData.employeeId,\n        name: (certificateData.name as any) || { vi: \"\", en: \"\" },\n        issuer: certificateData.issuer,\n        certificateNumber: certificateData.certificateNumber || \"\",\n        issueDate: certificateData.issueDate,\n        expiryDate: certificateData.expiryDate || \"\",\n        documentUrl: certificateData.documentUrl || \"\",\n        isActive: certificateData.isActive ? \"true\" : \"false\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/certificates/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/CertificateViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":82,"fix":{"range":[247,247],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/CertificateService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":82,"fix":{"range":[166,337],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { certificateService } from \"@mdl/hrm/client/services/CertificateService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[336,336],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { certificateService } from \"@mdl/hrm/client/services/CertificateService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nexport default function CertificateViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.certificates\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: certificateData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-certificates\", id],\n    queryFn: async () => {\n      const response = await certificateService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadCertificate\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!certificateData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/certificates\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/certificates/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.employee\")}\n              value={\n                getLocalizedText(certificateData.employee?.fullName) ||\n                certificateData.employee?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.name\")}\n              value={getLocalizedText(certificateData.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.issuer\")}\n              value={certificateData.issuer}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.certificateNumber\")}\n              value={certificateData.certificateNumber || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.issueDate\")}\n              value={formatDate(certificateData.issueDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.expiryDate\")}\n              value={formatDate(certificateData.expiryDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.documentUrl\")}\n              value={certificateData.documentUrl || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.isActive\")}\n              value={\n                certificateData.isActive\n                  ? tCommon(\"active\")\n                  : tCommon(\"inactive\")\n              }\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/CertificatesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { CertificateDto } from \"@mdl/hrm/client/interface/Certificate\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype CertificateRow = CertificateDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function CertificatesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.certificates\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<CertificateRow>[]>(\n    () => [\n      {\n        key: \"employee\",\n        label: t(\"labels.employee\"),\n        render: (value, row) => {\n          if (!row?.id) return null;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/certificates/view/${row.id}`}>\n              {getLocalizedText(row.employee?.fullName) ||\n                row.employee?.employeeCode ||\n                \"—\"}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: t(\"labels.name\"),\n        render: (value) => getLocalizedText(value),\n      },\n      {\n        key: \"issuer\",\n        label: t(\"labels.issuer\"),\n      },\n      {\n        key: \"certificateNumber\",\n        label: t(\"labels.certificateNumber\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"issueDate\",\n        label: t(\"labels.issueDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"expiryDate\",\n        label: t(\"labels.expiryDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"isActive\",\n        label: t(\"labels.isActive\"),\n        render: (value) => (\n          <Chip color={value ? \"success\" : \"default\"} size=\"sm\" variant=\"flat\">\n            {value ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/certificates/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<CertificateRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/certificates/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.certificate\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/components/CertificateForm/CertificateForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[137,137],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,506],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":47,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createCertificateValidation,\n  type CertificateFormValues,\n} from \"../../validation/certificateValidation\";\n\nexport type { CertificateFormValues };\n\ninterface CertificateFormProps {\n  onSubmit: (values: CertificateFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<CertificateFormValues>;\n}\n\nexport default function CertificateForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: CertificateFormProps) {\n  const t = useTranslations(\"hrm.certificates\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createCertificateValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<CertificateFormValues>({\n    resolver: valibotResolver(validation.certificateFormSchema) as any,\n    defaultValues: {\n      isActive: \"true\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<CertificateFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employee\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"name\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.name\")}\n                  size=\"sm\"\n                  value={field.value as any}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"issuer\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.issuer\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"certificateNumber\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.certificateNumber\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"issueDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.issueDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"expiryDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.expiryDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"documentUrl\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.documentUrl\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"isActive\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.isActive\")}\n                </Checkbox>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Certificates/validation/certificateValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/ContractCreatePage/ContractCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":76,"fix":{"range":[160,160],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,206],"text":"import { useTranslations } from \"next-intl\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[15,251],"text":"import { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport ContractForm, {\n  type ContractFormValues,\n} from \"../components/ContractForm/ContractForm\";\n\nexport default function ContractCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.contract.create.labels\");\n\n  const {\n    handleSubmit: submitContract,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof contractService.create>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await contractService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreate\"));\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"hrm-contracts\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/contracts/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: ContractFormValues) => {\n    const payload = {\n      contractNumber: values.contractNumber.trim(),\n      employeeId: values.employeeId.trim(),\n      contractType: values.contractType.trim(),\n      startDate: values.startDate.trim(),\n      endDate: values.endDate?.trim() || null,\n      baseSalary: Number(values.baseSalary),\n      currency: values.currency?.trim() || \"VND\",\n      workingHours: values.workingHours ? Number(values.workingHours) : null,\n      probationPeriod: values.probationPeriod\n        ? Number(values.probationPeriod)\n        : null,\n      probationEndDate: values.probationEndDate?.trim() || null,\n      status: values.status || \"draft\",\n      documentUrl: values.documentUrl?.trim() || null,\n      signedDate: values.signedDate?.trim() || null,\n      signedBy: values.signedBy?.trim() || null,\n      notes: values.notes?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await submitContract(payload);\n  };\n\n  return (\n    <ContractForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/contracts\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/ContractCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/ContractEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,312],"text":"import { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":76,"fix":{"range":[160,160],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/ContractService` import should occur after import of `next/navigation`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":76,"fix":{"range":[85,312],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport ContractForm, {\n  type ContractFormValues,\n} from \"./components/ContractForm/ContractForm\";\n\nexport default function ContractEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.contract.create.labels\");\n\n  const { data: contractData, isLoading } = useQuery({\n    queryKey: [\"hrm-contract\", id],\n    queryFn: async () => {\n      const response = await contractService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Contract not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: updateContract,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof contractService.update>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await contractService.update({ ...payload, id });\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdate\"));\n      }\n\n      return { id: response.data.id };\n    },\n    invalidateQueries: [[\"hrm-contracts\"], [\"hrm-contract\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/contracts/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: ContractFormValues) => {\n    const payload = {\n      id,\n      contractNumber: values.contractNumber.trim(),\n      employeeId: values.employeeId.trim(),\n      contractType: values.contractType.trim(),\n      startDate: values.startDate.trim(),\n      endDate: values.endDate?.trim() || null,\n      baseSalary: Number(values.baseSalary),\n      currency: values.currency?.trim() || \"VND\",\n      workingHours: values.workingHours ? Number(values.workingHours) : null,\n      probationPeriod: values.probationPeriod\n        ? Number(values.probationPeriod)\n        : null,\n      probationEndDate: values.probationEndDate?.trim() || null,\n      status: values.status || \"draft\",\n      documentUrl: values.documentUrl?.trim() || null,\n      signedDate: values.signedDate?.trim() || null,\n      signedBy: values.signedBy?.trim() || null,\n      notes: values.notes?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await updateContract(payload);\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!contractData) {\n    return <div>Contract not found</div>;\n  }\n\n  return (\n    <ContractForm\n      defaultValues={{\n        contractNumber: contractData.contractNumber,\n        employeeId: contractData.employeeId,\n        contractType: contractData.contractType,\n        startDate: contractData.startDate,\n        endDate: contractData.endDate || \"\",\n        baseSalary: contractData.baseSalary.toString(),\n        currency: contractData.currency || \"VND\",\n        workingHours: contractData.workingHours?.toString() || \"\",\n        probationPeriod: contractData.probationPeriod?.toString() || \"\",\n        probationEndDate: contractData.probationEndDate || \"\",\n        status: contractData.status,\n        documentUrl: contractData.documentUrl || \"\",\n        signedDate: contractData.signedDate || \"\",\n        signedBy: contractData.signedBy || \"\",\n        notes: contractData.notes || \"\",\n        isActive: contractData.isActive ?? true,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/contracts/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/ContractViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":72,"fix":{"range":[86,86],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":72,"fix":{"range":[15,403],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":48,"fix":{"range":[175,175],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":76,"fix":{"range":[251,251],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/ContractService` import should occur after import of `next/navigation`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":76,"fix":{"range":[176,403],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { contractService } from \"@mdl/hrm/client/services/ContractService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nexport default function ContractViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.contract.view.labels\");\n  const getLocalizedText = useLocalizedText();\n\n  const { data: contract, isLoading } = useQuery({\n    queryKey: [\"hrm-contract\", id],\n    queryFn: async () => {\n      const response = await contractService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Contract not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!contract) {\n    return <div>Contract not found</div>;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-2xl font-bold\">{t(\"title\")}</h1>\n        <div className=\"flex gap-2\">\n          <Button\n            size=\"sm\"\n            variant=\"light\"\n            onPress={() => router.push(\"/workspace/modules/hrm/contracts\")}\n          >\n            {t(\"backToList\")}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"sm\"\n            onPress={() =>\n              router.push(`/workspace/modules/hrm/contracts/edit/${id}`)\n            }\n          >\n            {t(\"edit\")}\n          </Button>\n        </div>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">{t(\"basicInfo\")}</h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <div>\n              <div className=\"text-sm text-default-500\">\n                {t(\"contractNumber\")}\n              </div>\n              <div className=\"text-base\">{contract.contractNumber}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"employee\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(contract.employee?.fullName as any) ||\n                  contract.employee?.employeeCode ||\n                  \"—\"}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">\n                {t(\"contractType\")}\n              </div>\n              <div className=\"text-base\">{contract.contractType}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"status\")}</div>\n              <div className=\"text-base\">{contract.status}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"startDate\")}</div>\n              <div className=\"text-base\">{contract.startDate}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"endDate\")}</div>\n              <div className=\"text-base\">{contract.endDate || \"—\"}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"baseSalary\")}</div>\n              <div className=\"text-base\">\n                {new Intl.NumberFormat(undefined, {\n                  style: \"currency\",\n                  currency: contract.currency || \"VND\",\n                }).format(contract.baseSalary)}\n              </div>\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/ContractsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":75,"fix":{"range":[308,308],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,347],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,392],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[424,424],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,425],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Contract } from \"@mdl/hrm/client/interface/Contract\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype ContractRow = Contract & {\n  startDate?: number | string | null;\n  createdAt?: number | string | null;\n};\n\nexport default function ContractsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.contract.list\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<ContractRow>[]>(\n    () => [\n      {\n        key: \"contractNumber\",\n        label: t(\"contractNumber\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/contracts/view/${row.id}`}>\n              {row.contractNumber}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"employee\",\n        label: t(\"employee\"),\n        render: (_, row) =>\n          getLocalizedText(row.employee?.fullName as any) ||\n          row.employee?.employeeCode ||\n          \"—\",\n      },\n      {\n        key: \"contractType\",\n        label: t(\"contractType\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"startDate\",\n        label: t(\"startDate\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"baseSalary\",\n        label: t(\"baseSalary\"),\n        render: (_, row) =>\n          new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: row.currency || \"VND\",\n          }).format(row.baseSalary),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/contracts/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"view\"),\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: t(\"edit\"),\n                  href: `/workspace/modules/hrm/contracts/edit/${row.id}`,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [t, tDataTable, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<ContractRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"newContract\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/contracts/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"contract\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/components/ContractForm/ContractForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":78,"fix":{"range":[172,172],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":78,"fix":{"range":[95,488],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { IBaseInput, IBaseSingleSelectAsync } from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":40,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { ContractFormValues } from \"../../validation/contractValidation\";\n\nimport { IBaseInput, IBaseSingleSelectAsync } from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport { createContractValidation } from \"../../validation/contractValidation\";\n\nexport type { ContractFormValues };\n\ninterface ContractFormProps {\n  onSubmit: (values: ContractFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<ContractFormValues>;\n}\n\nexport default function ContractForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: ContractFormProps) {\n  const t = useTranslations(\"hrm.contract.create.validation\");\n  const tLabels = useTranslations(\"hrm.contract.create.labels\");\n\n  const validation = useMemo(() => createContractValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<ContractFormValues>({\n    resolver: valibotResolver(validation.contractFormSchema) as any,\n    defaultValues: {\n      isActive: true,\n      status: \"draft\",\n      currency: \"VND\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<ContractFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tLabels(\"cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tLabels(\"save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"basicInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"contractNumber\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"contractNumber\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"employee\")}\n                  model=\"employee.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"contractType\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"contractType\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"status\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"startDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"startDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"endDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"endDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"baseSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"baseSalary\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"currency\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"currency\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"additionalInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"workingHours\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"workingHours\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"probationPeriod\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"probationPeriod\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"probationEndDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"probationEndDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"signedDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"signedDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n          </div>\n\n          <div className=\"mt-4\">\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <Textarea\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"notes\")}\n                  minRows={2}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Contracts/validation/contractValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/CourseCreatePage/CourseCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\n\nimport CourseForm, {\n  type CourseFormValues,\n} from \"../components/CourseForm/CourseForm\";\n\nexport default function CourseCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.courses\");\n\n  const {\n    handleSubmit: submitCourse,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof courseService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await courseService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreateCourse\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-courses\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/courses/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CourseFormValues) => {\n    await submitCourse({\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      category: values.category?.trim() || null,\n      duration: values.duration ?? null,\n      format: values.format?.trim() || null,\n      instructor: values.instructor?.trim() || null,\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  return (\n    <CourseForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/courses\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/CourseCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/CourseEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":72,"fix":{"range":[214,214],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,265],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,310],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,366],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport CourseForm, {\n  type CourseFormValues,\n} from \"./components/CourseForm/CourseForm\";\n\nexport default function CourseEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.courses\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: courseData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-courses\", id],\n    queryFn: async () => {\n      const response = await courseService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadCourse\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitCourse,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof courseService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await courseService.update(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdateCourse\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-courses\"], [\"hrm-courses\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/courses/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: CourseFormValues) => {\n    await submitCourse({\n      id,\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      category: values.category?.trim() || null,\n      duration: values.duration || null,\n      format: values.format?.trim() || null,\n      instructor: values.instructor?.trim() || null,\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!courseData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <CourseForm\n      defaultValues={{\n        code: courseData?.code || \"\",\n        name: (courseData?.name as any) || { vi: \"\", en: \"\" },\n        description: courseData?.description as any,\n        category: courseData?.category || \"\",\n        duration: courseData?.duration ?? undefined,\n        format: courseData?.format || \"\",\n        instructor: courseData?.instructor || \"\",\n        isActive: courseData?.isActive ? \"true\" : \"false\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(`/workspace/modules/hrm/courses/view/${id}`)}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/CourseViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":72,"fix":{"range":[237,237],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/CourseService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":72,"fix":{"range":[166,327],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[326,326],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { courseService } from \"@mdl/hrm/client/services/CourseService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function CourseViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.courses\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: courseData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-courses\", id],\n    queryFn: async () => {\n      const response = await courseService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadCourse\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!courseData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/courses\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/courses/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.code\")}\n              value={courseData.code}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.name\")}\n              value={getLocalizedText(courseData.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.category\")}\n              value={courseData.category || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.duration\")}\n              value={courseData.duration ? `${courseData.duration} hours` : \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.format\")}\n              value={courseData.format || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.instructor\")}\n              value={courseData.instructor || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.isActive\")}\n              value={\n                courseData.isActive ? tCommon(\"active\") : tCommon(\"inactive\")\n              }\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/CoursesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":53,"fix":{"range":[254,254],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,293],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,338],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[370,370],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,371],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { CourseDto } from \"@mdl/hrm/client/interface/Course\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype CourseRow = CourseDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function CoursesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.courses\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<CourseRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"labels.code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/courses/view/${row.id}`}>\n              {value}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: t(\"labels.name\"),\n        render: (value) => getLocalizedText(value),\n      },\n      {\n        key: \"category\",\n        label: t(\"labels.category\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"duration\",\n        label: t(\"labels.duration\"),\n        render: (value) => (value ? `${value} hours` : \"—\"),\n      },\n      {\n        key: \"format\",\n        label: t(\"labels.format\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"isActive\",\n        label: t(\"labels.isActive\"),\n        render: (value) => (\n          <Chip color={value ? \"success\" : \"default\"} size=\"sm\" variant=\"flat\">\n            {value ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/courses/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<CourseRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/courses/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.course\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/components/CourseForm/CourseForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[143,143],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,469],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":46,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createCourseValidation,\n  type CourseFormValues,\n} from \"../../validation/courseValidation\";\n\nexport type { CourseFormValues };\n\ninterface CourseFormProps {\n  onSubmit: (values: CourseFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<CourseFormValues>;\n}\n\nexport default function CourseForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: CourseFormProps) {\n  const t = useTranslations(\"hrm.courses\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createCourseValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<CourseFormValues>({\n    resolver: valibotResolver(validation.courseFormSchema) as any,\n    defaultValues: {\n      isActive: \"true\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<CourseFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"code\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.code\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"name\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.name\")}\n                  size=\"sm\"\n                  value={field.value as any}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"category\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.category\")}\n                  model=\"base-course-category\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"duration\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.duration\")}\n                  min={0}\n                  size=\"sm\"\n                  value={\n                    typeof field.value === \"number\"\n                      ? field.value\n                      : (field.value ?? null)\n                  }\n                  onValueChange={(val) => field.onChange(val ?? undefined)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"format\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.format\")}\n                  model=\"base-course-format\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"instructor\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.instructor\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"isActive\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.isActive\")}\n                </Checkbox>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"description\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.description\")}\n                    size=\"sm\"\n                    value={field.value ? JSON.stringify(field.value) : \"\"}\n                    onValueChange={(val) =>\n                      field.onChange(val ? {} : undefined)\n                    }\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Courses/validation/courseValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/DepartmentCreatePage/DepartmentCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { departmentService } from \"@mdl/hrm/client/services/DepartmentService\";\n\nimport DepartmentForm, {\n  type DepartmentFormValues,\n} from \"../components/DepartmentForm/DepartmentForm\";\n\nexport default function DepartmentCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.department.create.labels\");\n\n  const {\n    handleSubmit: submitDepartment,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof departmentService.create>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await departmentService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreate\"));\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"hrm-departments\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/departments/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: DepartmentFormValues) => {\n    const payload = {\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      parentId: values.parentId?.trim() || null,\n      level: values.level ? Number(values.level) : null,\n      managerId: values.managerId?.trim() || null,\n      locationId: values.locationId?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await submitDepartment(payload);\n  };\n\n  return (\n    <DepartmentForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/departments\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/DepartmentCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/DepartmentEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `@tanstack/react-query`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { departmentService } from \"@mdl/hrm/client/services/DepartmentService\";\n\nimport DepartmentForm, {\n  type DepartmentFormValues,\n} from \"./components/DepartmentForm/DepartmentForm\";\n\nexport default function DepartmentEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.department.create.labels\");\n\n  const { data: departmentData, isLoading } = useQuery({\n    queryKey: [\"hrm-department\", id],\n    queryFn: async () => {\n      const response = await departmentService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Department not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: updateDepartment,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof departmentService.update>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await departmentService.update(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdate\"));\n      }\n\n      return { id: response.data.id };\n    },\n    invalidateQueries: [[\"hrm-departments\"], [\"hrm-department\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/departments/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: DepartmentFormValues) => {\n    const payload = {\n      id,\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      parentId: values.parentId?.trim() || null,\n      level: values.level ? Number(values.level) : null,\n      managerId: values.managerId?.trim() || null,\n      locationId: values.locationId?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await updateDepartment(payload);\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!departmentData) {\n    return <div>Department not found</div>;\n  }\n\n  return (\n    <DepartmentForm\n      defaultValues={{\n        code: departmentData.code,\n        name: (departmentData.name as any) || { vi: \"\", en: \"\" },\n        description: (departmentData.description as any) || undefined,\n        parentId: departmentData.parent?.id || \"\",\n        level: departmentData.level?.toString() || \"\",\n        managerId: departmentData.managerId || \"\",\n        locationId: departmentData.locationId || \"\",\n        isActive: departmentData.isActive ?? true,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/departments/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/DepartmentViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":50,"fix":{"range":[254,254],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { departmentService } from \"@mdl/hrm/client/services/DepartmentService\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function DepartmentViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.department.view.labels\");\n  const getLocalizedText = useLocalizedText();\n\n  const { data: department, isLoading } = useQuery({\n    queryKey: [\"hrm-department\", id],\n    queryFn: async () => {\n      const response = await departmentService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Department not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!department) {\n    return <div>Department not found</div>;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-2xl font-bold\">{t(\"title\")}</h1>\n        <div className=\"flex gap-2\">\n          <Button\n            size=\"sm\"\n            variant=\"light\"\n            onPress={() => router.push(\"/workspace/modules/hrm/departments\")}\n          >\n            {t(\"backToList\")}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"sm\"\n            onPress={() =>\n              router.push(`/workspace/modules/hrm/departments/edit/${id}`)\n            }\n          >\n            {t(\"edit\")}\n          </Button>\n        </div>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">{t(\"basicInfo\")}</h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"code\")}</div>\n              <div className=\"text-base\">{department.code}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"name\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(department.name as any)}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">\n                {t(\"parentDepartment\")}\n              </div>\n              <div className=\"text-base\">\n                {getLocalizedText(department.parent?.name as any) || \"—\"}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"level\")}</div>\n              <div className=\"text-base\">{department.level || \"—\"}</div>\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/DepartmentsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":75,"fix":{"range":[308,308],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,347],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,392],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[424,424],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,425],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Department } from \"@mdl/hrm/client/interface/Department\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype DepartmentRow = Department & {\n  createdAt?: number | string | null;\n};\n\nexport default function DepartmentsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.department.list\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<DepartmentRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/departments/view/${row.id}`}>\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: t(\"name\"),\n        render: (value) => getLocalizedText(value as any),\n      },\n      {\n        key: \"level\",\n        label: t(\"level\"),\n      },\n      {\n        key: \"isActive\",\n        label: t(\"status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value ? \"active\" : \"inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/departments/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"view\"),\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: t(\"edit\"),\n                  href: `/workspace/modules/hrm/departments/edit/${row.id}`,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [t, tDataTable, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<DepartmentRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"newDepartment\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/departments/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"department\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/components/DepartmentForm/DepartmentForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[207,207],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[99,513],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":44,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { DepartmentFormValues } from \"../../validation/departmentValidation\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport { createDepartmentValidation } from \"../../validation/departmentValidation\";\n\nexport type { DepartmentFormValues };\n\ninterface DepartmentFormProps {\n  onSubmit: (values: DepartmentFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<DepartmentFormValues>;\n}\n\nexport default function DepartmentForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: DepartmentFormProps) {\n  const t = useTranslations(\"hrm.department.create.validation\");\n  const tLabels = useTranslations(\"hrm.department.create.labels\");\n\n  const validation = useMemo(() => createDepartmentValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<DepartmentFormValues>({\n    resolver: valibotResolver(validation.departmentFormSchema) as any,\n    defaultValues: {\n      isActive: true,\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<DepartmentFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tLabels(\"cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tLabels(\"save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"basicInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"code\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"code\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"name\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"name\")}\n                  size=\"sm\"\n                  value={field.value || { vi: \"\", en: \"\" }}\n                  onChange={field.onChange}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"parentId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"parentDepartment\")}\n                  model=\"department.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"level\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"level\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"managerId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"manager\")}\n                  model=\"employee.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Departments/validation/departmentValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/EmployeeCreatePage/EmployeeCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { employeeService } from \"@mdl/hrm/client/services/EmployeeService\";\n\nimport EmployeeForm, {\n  type EmployeeFormValues,\n} from \"../components/EmployeeForm/EmployeeForm\";\n\nexport default function EmployeeCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.employee.create.labels\");\n\n  const {\n    handleSubmit: submitEmployee,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof employeeService.create>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await employeeService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreate\"));\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"hrm-employees\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/employees/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: EmployeeFormValues) => {\n    const payload = {\n      employeeCode: values.employeeCode.trim(),\n      firstName: values.firstName?.trim() || null,\n      lastName: values.lastName?.trim() || null,\n      fullName: values.fullName || { vi: \"\", en: \"\" },\n      email: values.email?.trim() || null,\n      phone: values.phone?.trim() || null,\n      dateOfBirth: values.dateOfBirth?.trim() || null,\n      gender: values.gender?.trim() || null,\n      nationalId: values.nationalId?.trim() || null,\n      taxId: values.taxId?.trim() || null,\n      address: values.address || null,\n      positionId: values.positionId.trim(),\n      departmentId: values.departmentId.trim(),\n      managerId: values.managerId?.trim() || null,\n      employmentStatus: values.employmentStatus || \"active\",\n      employmentType: values.employmentType?.trim() || null,\n      hireDate: values.hireDate.trim(),\n      probationEndDate: values.probationEndDate?.trim() || null,\n      baseSalary: values.baseSalary ? Number(values.baseSalary) : null,\n      currency: values.currency?.trim() || \"VND\",\n      locationId: values.locationId?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await submitEmployee(payload);\n  };\n\n  return (\n    <EmployeeForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/employees\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/EmployeeCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/EmployeeEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `@tanstack/react-query`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { employeeService } from \"@mdl/hrm/client/services/EmployeeService\";\n\nimport EmployeeForm, {\n  type EmployeeFormValues,\n} from \"./components/EmployeeForm/EmployeeForm\";\n\nexport default function EmployeeEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.employee.create.labels\");\n\n  const { data: employeeData, isLoading } = useQuery({\n    queryKey: [\"hrm-employee\", id],\n    queryFn: async () => {\n      const response = await employeeService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Employee not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: updateEmployee,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof employeeService.update>[0],\n    { id: string }\n  >({\n    mutationFn: async (payload) => {\n      const response = await employeeService.update(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdate\"));\n      }\n\n      return { id: response.data.id };\n    },\n    invalidateQueries: [[\"hrm-employees\"], [\"hrm-employee\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/employees/view/${data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: EmployeeFormValues) => {\n    const payload = {\n      id,\n      employeeCode: values.employeeCode.trim(),\n      firstName: values.firstName?.trim() || null,\n      lastName: values.lastName?.trim() || null,\n      fullName: values.fullName || { vi: \"\", en: \"\" },\n      email: values.email?.trim() || null,\n      phone: values.phone?.trim() || null,\n      dateOfBirth: values.dateOfBirth?.trim() || null,\n      gender: values.gender?.trim() || null,\n      nationalId: values.nationalId?.trim() || null,\n      taxId: values.taxId?.trim() || null,\n      address: values.address || null,\n      positionId: values.positionId.trim(),\n      departmentId: values.departmentId.trim(),\n      managerId: values.managerId?.trim() || null,\n      employmentStatus: values.employmentStatus || \"active\",\n      employmentType: values.employmentType?.trim() || null,\n      hireDate: values.hireDate.trim(),\n      probationEndDate: values.probationEndDate?.trim() || null,\n      baseSalary: values.baseSalary ? Number(values.baseSalary) : null,\n      currency: values.currency?.trim() || \"VND\",\n      locationId: values.locationId?.trim() || null,\n      isActive: values.isActive ?? true,\n    };\n\n    await updateEmployee(payload);\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!employeeData) {\n    return <div>Employee not found</div>;\n  }\n\n  return (\n    <EmployeeForm\n      defaultValues={{\n        employeeCode: employeeData.employeeCode,\n        firstName: employeeData.firstName || \"\",\n        lastName: employeeData.lastName || \"\",\n        fullName: (employeeData.fullName as any) || { vi: \"\", en: \"\" },\n        email: employeeData.email || \"\",\n        phone: employeeData.phone || \"\",\n        dateOfBirth: employeeData.dateOfBirth || \"\",\n        gender: employeeData.gender || \"\",\n        nationalId: employeeData.nationalId || \"\",\n        taxId: employeeData.taxId || \"\",\n        positionId: employeeData.positionId,\n        departmentId: employeeData.departmentId,\n        managerId: employeeData.managerId || \"\",\n        employmentStatus: employeeData.employmentStatus,\n        employmentType: employeeData.employmentType || \"\",\n        hireDate: employeeData.hireDate,\n        probationEndDate: employeeData.probationEndDate || \"\",\n        baseSalary: employeeData.baseSalary?.toString() || \"\",\n        currency: employeeData.currency || \"VND\",\n        locationId: employeeData.locationId || \"\",\n        isActive: employeeData.isActive ?? true,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/employees/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/EmployeeViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":50,"fix":{"range":[254,254],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { employeeService } from \"@mdl/hrm/client/services/EmployeeService\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function EmployeeViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.employee.view.labels\");\n  const getLocalizedText = useLocalizedText();\n\n  const { data: employee, isLoading } = useQuery({\n    queryKey: [\"hrm-employee\", id],\n    queryFn: async () => {\n      const response = await employeeService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Employee not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!employee) {\n    return <div>Employee not found</div>;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-2xl font-bold\">{t(\"title\")}</h1>\n        <div className=\"flex gap-2\">\n          <Button\n            size=\"sm\"\n            variant=\"light\"\n            onPress={() => router.push(\"/workspace/modules/hrm/employees\")}\n          >\n            {t(\"backToList\")}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"sm\"\n            onPress={() =>\n              router.push(`/workspace/modules/hrm/employees/edit/${id}`)\n            }\n          >\n            {t(\"edit\")}\n          </Button>\n        </div>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">{t(\"basicInfo\")}</h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <div>\n              <div className=\"text-sm text-default-500\">\n                {t(\"employeeCode\")}\n              </div>\n              <div className=\"text-base\">{employee.employeeCode}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"fullName\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(employee.fullName as any)}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"email\")}</div>\n              <div className=\"text-base\">{employee.email || \"—\"}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"phone\")}</div>\n              <div className=\"text-base\">{employee.phone || \"—\"}</div>\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {t(\"employmentInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"department\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(employee.department?.name as any) || \"—\"}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"position\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(employee.position?.name as any) || \"—\"}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"hireDate\")}</div>\n              <div className=\"text-base\">{employee.hireDate || \"—\"}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">\n                {t(\"employmentStatus\")}\n              </div>\n              <div className=\"text-base\">\n                {employee.employmentStatus || \"—\"}\n              </div>\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/EmployeesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[489,489],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Employee } from \"@mdl/hrm/client/interface/Employee\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype EmployeeRow = Employee & {\n  hireDate?: number | string | null;\n  createdAt?: number | string | null;\n};\n\nexport default function EmployeesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.employee.list\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<EmployeeRow>[]>(\n    () => [\n      {\n        key: \"employeeCode\",\n        label: t(\"employeeCode\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/employees/view/${row.id}`}>\n              {row.employeeCode}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"fullName\",\n        label: t(\"fullName\"),\n        render: (value) => getLocalizedText(value as any),\n      },\n      {\n        key: \"email\",\n        label: t(\"email\"),\n      },\n      {\n        key: \"phone\",\n        label: t(\"phone\"),\n      },\n      {\n        key: \"employmentStatus\",\n        label: t(\"status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"active\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"hireDate\",\n        label: t(\"hireDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/employees/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"view\"),\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: t(\"edit\"),\n                  href: `/workspace/modules/hrm/employees/edit/${row.id}`,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [t, tDataTable, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<EmployeeRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"newEmployee\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/employees/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"employee\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/components/EmployeeForm/EmployeeForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[203,203],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `@heroui/react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[95,509],"text":"import { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":45,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { EmployeeFormValues } from \"../../validation/employeeValidation\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\n\nimport { createEmployeeValidation } from \"../../validation/employeeValidation\";\n\nexport type { EmployeeFormValues };\n\ninterface EmployeeFormProps {\n  onSubmit: (values: EmployeeFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<EmployeeFormValues>;\n}\n\nexport default function EmployeeForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: EmployeeFormProps) {\n  const t = useTranslations(\"hrm.employee.create.validation\");\n  const tLabels = useTranslations(\"hrm.employee.create.labels\");\n\n  // Create validation schemas with translation\n  const validation = useMemo(() => createEmployeeValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<EmployeeFormValues>({\n    resolver: valibotResolver(validation.employeeFormSchema) as any,\n    defaultValues: {\n      isActive: true,\n      employmentStatus: \"active\",\n      currency: \"VND\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<EmployeeFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      {/* Action Buttons - Sticky */}\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tLabels(\"cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tLabels(\"save\")}\n        </Button>\n      </div>\n\n      {/* Basic Information */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"basicInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"employeeCode\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"employeeCode\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"fullName\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"fullName\")}\n                  size=\"sm\"\n                  value={field.value || { vi: \"\", en: \"\" }}\n                  onChange={field.onChange}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"firstName\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"firstName\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"lastName\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"lastName\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"email\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"email\")}\n                  size=\"sm\"\n                  type=\"email\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"phone\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"phone\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n\n      {/* Employment Information */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"employmentInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"departmentId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"department\")}\n                  model=\"department.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"positionId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"position\")}\n                  model=\"position.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"managerId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"manager\")}\n                  model=\"employee.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"hireDate\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"hireDate\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"employmentStatus\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"employmentStatus\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"baseSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"baseSalary\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n\n      {/* Additional Information */}\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"additionalInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"dateOfBirth\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"dateOfBirth\")}\n                  size=\"sm\"\n                  type=\"date\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"gender\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"gender\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Employees/validation/employeeValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EmployeeFormValues' is defined but never used. Allowed unused vars must match /^_.*?$/u.","line":111,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  boolean,\n  custom,\n  minLength,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n  type InferOutput,\n} from \"valibot\";\n\n/**\n * Translation function type\n */\ntype TranslateFn = (key: string, values?: Record<string, any>) => string;\n\n/**\n * Create validation schemas with translation support\n */\nexport function createEmployeeValidation(t: TranslateFn) {\n  // Employee code validation\n  const employeeCodeSchema = pipe(\n    string(),\n    trim(),\n    minLength(1, t(\"validation.employeeCode.required\")),\n  );\n\n  // Full name validation (object with vi/en) - using custom validation\n  const fullNameSchema = custom<{ vi?: string; en?: string }>((value) => {\n    if (!value || typeof value !== \"object\") return false;\n    const obj = value as any;\n\n    return (\n      (obj.vi !== undefined &&\n        typeof obj.vi === \"string\" &&\n        obj.vi.trim() !== \"\") ||\n      (obj.en !== undefined &&\n        typeof obj.en === \"string\" &&\n        obj.en.trim() !== \"\")\n    );\n  }, t(\"validation.fullName.required\"));\n\n  // Email validation\n  const emailSchema = pipe(\n    string(),\n    trim(),\n    custom(\n      (value) =>\n        value === \"\" || /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(String(value)),\n      t(\"validation.email.invalid\"),\n    ),\n  );\n\n  // Phone validation\n  const phoneSchema = pipe(string(), trim());\n\n  // Date validation\n  const dateSchema = pipe(string(), trim());\n\n  // Main form schema\n  const employeeFormSchema = object({\n    employeeCode: employeeCodeSchema,\n    firstName: optional(pipe(string(), trim())),\n    lastName: optional(pipe(string(), trim())),\n    fullName: fullNameSchema,\n    email: optional(emailSchema),\n    phone: optional(phoneSchema),\n    dateOfBirth: optional(dateSchema),\n    gender: optional(pipe(string(), trim())),\n    nationalId: optional(pipe(string(), trim())),\n    taxId: optional(pipe(string(), trim())),\n    address: optional(object({})),\n    positionId: pipe(\n      string(),\n      trim(),\n      minLength(1, t(\"validation.positionId.required\")),\n    ),\n    departmentId: pipe(\n      string(),\n      trim(),\n      minLength(1, t(\"validation.departmentId.required\")),\n    ),\n    managerId: optional(pipe(string(), trim())),\n    employmentStatus: optional(pipe(string(), trim())),\n    employmentType: optional(pipe(string(), trim())),\n    hireDate: pipe(\n      string(),\n      trim(),\n      minLength(1, t(\"validation.hireDate.required\")),\n    ),\n    probationEndDate: optional(dateSchema),\n    baseSalary: optional(\n      pipe(\n        string(),\n        trim(),\n        custom((value) => {\n          if (value === \"\") return true;\n          const num = Number(value);\n\n          return !Number.isNaN(num) && num >= 0;\n        }, t(\"validation.baseSalary.invalid\")),\n      ),\n    ),\n    currency: optional(pipe(string(), trim())),\n    locationId: optional(pipe(string(), trim())),\n    isActive: optional(boolean()),\n  });\n\n  // Form values type\n  type EmployeeFormValues = InferOutput<typeof employeeFormSchema>;\n\n  return {\n    employeeFormSchema,\n  };\n}\n\nexport type EmployeeFormValues = InferOutput<\n  ReturnType<typeof createEmployeeValidation>[\"employeeFormSchema\"]\n>;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/JobRequisitionCreatePage/JobRequisitionCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":88,"fix":{"range":[172,172],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,218],"text":"import { useTranslations } from \"next-intl\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[15,263],"text":"import { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport JobRequisitionForm, {\n  type JobRequisitionFormValues,\n} from \"../components/JobRequisitionForm/JobRequisitionForm\";\n\nexport default function JobRequisitionCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.jobRequisitions\");\n\n  const {\n    handleSubmit: submitJobRequisition,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof jobRequisitionService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await jobRequisitionService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateJobRequisition\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-job-requisitions\"]],\n    onSuccess: (data) => {\n      router.push(\n        `/workspace/modules/hrm/job-requisitions/view/${data.data.id}`,\n      );\n    },\n  });\n\n  const handleSubmit = async (values: JobRequisitionFormValues) => {\n    await submitJobRequisition({\n      requisitionNumber: String(values.requisitionNumber).trim(),\n      title:\n        values.title &&\n        typeof values.title === \"object\" &&\n        !Array.isArray(values.title) &&\n        (\"vi\" in values.title || \"en\" in values.title)\n          ? (values.title as { vi?: string; en?: string })\n          : { vi: \"\", en: \"\" },\n      description:\n        values.description &&\n        typeof values.description === \"object\" &&\n        !Array.isArray(values.description) &&\n        (values.description === null ||\n          \"vi\" in values.description ||\n          \"en\" in values.description)\n          ? (values.description as { vi?: string; en?: string } | null)\n          : null,\n      departmentId: String(values.departmentId).trim(),\n      positionId: String(values.positionId).trim(),\n      numberOfOpenings:\n        typeof values.numberOfOpenings === \"number\"\n          ? values.numberOfOpenings\n          : 1,\n      priority:\n        typeof values.priority === \"string\" ? values.priority : \"normal\",\n      employmentType:\n        typeof values.employmentType === \"string\"\n          ? values.employmentType\n          : null,\n      minSalary: typeof values.minSalary === \"number\" ? values.minSalary : null,\n      maxSalary: typeof values.maxSalary === \"number\" ? values.maxSalary : null,\n      currency: typeof values.currency === \"string\" ? values.currency : \"VND\",\n      requirements:\n        typeof values.requirements === \"string\"\n          ? values.requirements.trim()\n          : null,\n      status: typeof values.status === \"string\" ? values.status : \"draft\",\n      openedDate:\n        typeof values.openedDate === \"string\" ? values.openedDate.trim() : null,\n      closedDate:\n        typeof values.closedDate === \"string\" ? values.closedDate.trim() : null,\n      hiringManagerId:\n        typeof values.hiringManagerId === \"string\"\n          ? values.hiringManagerId.trim()\n          : null,\n      recruiterId:\n        typeof values.recruiterId === \"string\"\n          ? values.recruiterId.trim()\n          : null,\n      notes: typeof values.notes === \"string\" ? values.notes.trim() : null,\n    });\n  };\n\n  return (\n    <JobRequisitionForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/job-requisitions\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/JobRequisitionCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/JobRequisitionEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[230,230],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,281],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,326],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,382],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport JobRequisitionForm, {\n  type JobRequisitionFormValues,\n} from \"./components/JobRequisitionForm/JobRequisitionForm\";\n\nexport default function JobRequisitionEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.jobRequisitions\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: jobRequisitionData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-job-requisitions\", id],\n    queryFn: async () => {\n      const response = await jobRequisitionService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadJobRequisition\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitJobRequisition,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof jobRequisitionService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await jobRequisitionService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateJobRequisition\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-job-requisitions\"], [\"hrm-job-requisitions\", id]],\n    onSuccess: (data) => {\n      router.push(\n        `/workspace/modules/hrm/job-requisitions/view/${data.data.id}`,\n      );\n    },\n  });\n\n  const handleSubmit = async (values: JobRequisitionFormValues) => {\n    await submitJobRequisition({\n      id,\n      requisitionNumber: String(values.requisitionNumber).trim(),\n      title:\n        values.title &&\n        typeof values.title === \"object\" &&\n        !Array.isArray(values.title) &&\n        (\"vi\" in values.title || \"en\" in values.title)\n          ? (values.title as { vi?: string; en?: string })\n          : undefined,\n      description:\n        values.description &&\n        typeof values.description === \"object\" &&\n        !Array.isArray(values.description) &&\n        (values.description === null ||\n          \"vi\" in values.description ||\n          \"en\" in values.description)\n          ? (values.description as { vi?: string; en?: string } | null)\n          : null,\n      departmentId:\n        typeof values.departmentId === \"string\"\n          ? values.departmentId.trim()\n          : undefined,\n      positionId:\n        typeof values.positionId === \"string\"\n          ? values.positionId.trim()\n          : undefined,\n      numberOfOpenings:\n        typeof values.numberOfOpenings === \"number\"\n          ? values.numberOfOpenings\n          : undefined,\n      priority:\n        typeof values.priority === \"string\" ? values.priority : undefined,\n      employmentType:\n        typeof values.employmentType === \"string\"\n          ? values.employmentType\n          : null,\n      minSalary: typeof values.minSalary === \"number\" ? values.minSalary : null,\n      maxSalary: typeof values.maxSalary === \"number\" ? values.maxSalary : null,\n      currency:\n        typeof values.currency === \"string\" ? values.currency : undefined,\n      requirements:\n        typeof values.requirements === \"string\"\n          ? values.requirements.trim()\n          : null,\n      status: typeof values.status === \"string\" ? values.status : undefined,\n      openedDate:\n        typeof values.openedDate === \"string\" ? values.openedDate.trim() : null,\n      closedDate:\n        typeof values.closedDate === \"string\" ? values.closedDate.trim() : null,\n      hiringManagerId:\n        typeof values.hiringManagerId === \"string\"\n          ? values.hiringManagerId.trim()\n          : null,\n      recruiterId:\n        typeof values.recruiterId === \"string\"\n          ? values.recruiterId.trim()\n          : null,\n      notes: typeof values.notes === \"string\" ? values.notes.trim() : null,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!jobRequisitionData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <JobRequisitionForm\n      defaultValues={{\n        requisitionNumber: jobRequisitionData.requisitionNumber,\n        title: (jobRequisitionData.title as any) || { vi: \"\", en: \"\" },\n        description: jobRequisitionData.description as any,\n        departmentId: jobRequisitionData.departmentId,\n        positionId: jobRequisitionData.positionId,\n        numberOfOpenings: jobRequisitionData.numberOfOpenings,\n        priority: jobRequisitionData.priority || \"normal\",\n        employmentType: jobRequisitionData.employmentType || \"\",\n        minSalary: jobRequisitionData.minSalary || undefined,\n        maxSalary: jobRequisitionData.maxSalary || undefined,\n        currency: jobRequisitionData.currency || \"VND\",\n        requirements: jobRequisitionData.requirements || \"\",\n        status: jobRequisitionData.status,\n        openedDate: jobRequisitionData.openedDate || \"\",\n        closedDate: jobRequisitionData.closedDate || \"\",\n        hiringManagerId: jobRequisitionData.hiringManagerId || \"\",\n        recruiterId: jobRequisitionData.recruiterId || \"\",\n        notes: jobRequisitionData.notes || \"\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/job-requisitions/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/JobRequisitionViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":88,"fix":{"range":[253,253],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/JobRequisitionService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":88,"fix":{"range":[166,343],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[342,342],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { jobRequisitionService } from \"@mdl/hrm/client/services/JobRequisitionService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nexport default function JobRequisitionViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.jobRequisitions\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: jobRequisitionData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-job-requisitions\", id],\n    queryFn: async () => {\n      const response = await jobRequisitionService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadJobRequisition\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!jobRequisitionData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/job-requisitions\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/job-requisitions/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.requisitionNumber\")}\n              value={jobRequisitionData.requisitionNumber}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.title\")}\n              value={getLocalizedText(jobRequisitionData.title)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.department\")}\n              value={getLocalizedText(jobRequisitionData.department?.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.position\")}\n              value={getLocalizedText(jobRequisitionData.position?.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.numberOfOpenings\")}\n              value={jobRequisitionData.numberOfOpenings.toString()}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.priority\")}\n              value={jobRequisitionData.priority || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={jobRequisitionData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.employmentType\")}\n              value={jobRequisitionData.employmentType || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.minSalary\")}\n              value={jobRequisitionData.minSalary?.toLocaleString() || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.maxSalary\")}\n              value={jobRequisitionData.maxSalary?.toLocaleString() || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.currency\")}\n              value={jobRequisitionData.currency || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.openedDate\")}\n              value={formatDate(jobRequisitionData.openedDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.closedDate\")}\n              value={formatDate(jobRequisitionData.closedDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.hiringManager\")}\n              value={jobRequisitionData.hiringManagerId || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.recruiter\")}\n              value={jobRequisitionData.recruiterId || \"—\"}\n            />\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.requirements\")}\n                value={jobRequisitionData.requirements || \"—\"}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.notes\")}\n                value={jobRequisitionData.notes || \"—\"}\n              />\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/JobRequisitionsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { JobRequisitionDto } from \"@mdl/hrm/client/interface/JobRequisition\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype JobRequisitionRow = JobRequisitionDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function JobRequisitionsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.jobRequisitions\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<JobRequisitionRow>[]>(\n    () => [\n      {\n        key: \"requisitionNumber\",\n        label: t(\"labels.requisitionNumber\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/hrm/job-requisitions/view/${row.id}`}\n            >\n              {value}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"title\",\n        label: t(\"labels.title\"),\n        render: (value) => getLocalizedText(value),\n      },\n      {\n        key: \"department\",\n        label: t(\"labels.department\"),\n        render: (value, row) => getLocalizedText(row.department?.name),\n      },\n      {\n        key: \"position\",\n        label: t(\"labels.position\"),\n        render: (value, row) => getLocalizedText(row.position?.name),\n      },\n      {\n        key: \"numberOfOpenings\",\n        label: t(\"labels.numberOfOpenings\"),\n      },\n      {\n        key: \"priority\",\n        label: t(\"labels.priority\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"normal\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"openedDate\",\n        label: t(\"labels.openedDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/job-requisitions/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<JobRequisitionRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/job-requisitions/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.job-requisition\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/components/JobRequisitionForm/JobRequisitionForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[157,157],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[15,526],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":48,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DatePicker,\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createJobRequisitionValidation,\n  type JobRequisitionFormValues,\n} from \"../../validation/jobRequisitionValidation\";\n\nexport type { JobRequisitionFormValues };\n\ninterface JobRequisitionFormProps {\n  onSubmit: (values: JobRequisitionFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<JobRequisitionFormValues>;\n}\n\nexport default function JobRequisitionForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: JobRequisitionFormProps) {\n  const t = useTranslations(\"hrm.jobRequisitions\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createJobRequisitionValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<JobRequisitionFormValues>({\n    resolver: valibotResolver(validation.jobRequisitionFormSchema) as any,\n    defaultValues: {\n      status: \"draft\",\n      priority: \"normal\",\n      currency: \"VND\",\n      numberOfOpenings: 1,\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<JobRequisitionFormValues> = async (\n    values,\n  ) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"requisitionNumber\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.requisitionNumber\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"title\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.title\")}\n                  size=\"sm\"\n                  value={field.value as any}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"departmentId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.department\")}\n                  model=\"hrm.department.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"positionId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.position\")}\n                  model=\"hrm.position.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"numberOfOpenings\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.numberOfOpenings\")}\n                  min={1}\n                  size=\"sm\"\n                  value={field.value ?? 1}\n                  onValueChange={(val) => field.onChange(val ?? 1)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"priority\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.priority\")}\n                  model=\"base-priority\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"employmentType\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employmentType\")}\n                  model=\"base-employment-type\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-job-requisition-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"minSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.minSalary\")}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ?? null}\n                  onValueChange={(val) => field.onChange(val ?? undefined)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"maxSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.maxSalary\")}\n                  min={0}\n                  size=\"sm\"\n                  value={field.value ?? null}\n                  onValueChange={(val) => field.onChange(val ?? undefined)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"currency\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.currency\")}\n                  model=\"base-currency\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"openedDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.openedDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"closedDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.closedDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"hiringManagerId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.hiringManager\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"recruiterId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.recruiter\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"requirements\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.requirements\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.notes\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/JobRequisitions/validation/jobRequisitionValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/LeaveRequestCreatePage/LeaveRequestCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\n\nimport LeaveRequestForm, {\n  type LeaveRequestFormValues,\n} from \"../components/LeaveRequestForm/LeaveRequestForm\";\n\nexport default function LeaveRequestCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.leaveRequests\");\n\n  const {\n    handleSubmit: submitLeaveRequest,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof leaveRequestService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await leaveRequestService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateLeaveRequest\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-leave-requests\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/leave-requests/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: LeaveRequestFormValues) => {\n    await submitLeaveRequest({\n      employeeId: values.employeeId.trim(),\n      leaveTypeId: values.leaveTypeId.trim(),\n      startDate: values.startDate.trim(),\n      endDate: values.endDate.trim(),\n      days: values.days,\n      reason: values.reason?.trim() || null,\n      status: values.status || \"pending\",\n    });\n  };\n\n  return (\n    <LeaveRequestForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/leave-requests\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/LeaveRequestCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/LeaveRequestEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":84,"fix":{"range":[226,226],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,277],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,322],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,378],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport LeaveRequestForm, {\n  type LeaveRequestFormValues,\n} from \"./components/LeaveRequestForm/LeaveRequestForm\";\n\nexport default function LeaveRequestEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.leaveRequests\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: leaveRequestData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-leave-requests\", id],\n    queryFn: async () => {\n      const response = await leaveRequestService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadLeaveRequest\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitLeaveRequest,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof leaveRequestService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await leaveRequestService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateLeaveRequest\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-leave-requests\"], [\"hrm-leave-requests\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/leave-requests/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: LeaveRequestFormValues) => {\n    await submitLeaveRequest({\n      id,\n      employeeId: values.employeeId.trim(),\n      leaveTypeId: values.leaveTypeId.trim(),\n      startDate: values.startDate.trim(),\n      endDate: values.endDate.trim(),\n      days: values.days,\n      reason: values.reason?.trim() || null,\n      status: values.status || \"pending\",\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!leaveRequestData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <LeaveRequestForm\n      defaultValues={{\n        employeeId: leaveRequestData.employeeId,\n        leaveTypeId: leaveRequestData.leaveTypeId,\n        startDate: leaveRequestData.startDate,\n        endDate: leaveRequestData.endDate,\n        days: leaveRequestData.days,\n        reason: leaveRequestData.reason || \"\",\n        status: leaveRequestData.status,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/leave-requests/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/LeaveRequestViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":84,"fix":{"range":[249,249],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/LeaveRequestService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":84,"fix":{"range":[166,339],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[338,338],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { leaveRequestService } from \"@mdl/hrm/client/services/LeaveRequestService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nexport default function LeaveRequestViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.leaveRequests\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: leaveRequestData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-leave-requests\", id],\n    queryFn: async () => {\n      const response = await leaveRequestService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadLeaveRequest\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!leaveRequestData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/leave-requests\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/leave-requests/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.employee\")}\n              value={\n                getLocalizedText(leaveRequestData.employee?.fullName) ||\n                leaveRequestData.employee?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.leaveType\")}\n              value={getLocalizedText(leaveRequestData.leaveType?.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.startDate\")}\n              value={formatDate(leaveRequestData.startDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.endDate\")}\n              value={formatDate(leaveRequestData.endDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.days\")}\n              value={`${leaveRequestData.days} ${t(\"labels.day\")}`}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={leaveRequestData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.reason\")}\n              value={leaveRequestData.reason || \"—\"}\n            />\n            {leaveRequestData.approvedAt && (\n              <IBaseDigitViewer\n                label={t(\"labels.approvedAt\")}\n                value={formatDate(leaveRequestData.approvedAt)}\n              />\n            )}\n            {leaveRequestData.rejectedAt && (\n              <>\n                <IBaseDigitViewer\n                  label={t(\"labels.rejectedAt\")}\n                  value={formatDate(leaveRequestData.rejectedAt)}\n                />\n                <IBaseDigitViewer\n                  label={t(\"labels.rejectionReason\")}\n                  value={leaveRequestData.rejectionReason || \"—\"}\n                />\n              </>\n            )}\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/LeaveRequestsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { LeaveRequestDto } from \"@mdl/hrm/client/interface/LeaveRequest\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype LeaveRequestRow = LeaveRequestDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function LeaveRequestsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.leaveRequests\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<LeaveRequestRow>[]>(\n    () => [\n      {\n        key: \"employee\",\n        label: t(\"labels.employee\"),\n        render: (value, row) => {\n          if (!row?.id) return null;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/hrm/leave-requests/view/${row.id}`}\n            >\n              {getLocalizedText(row.employee?.fullName) ||\n                row.employee?.employeeCode ||\n                \"—\"}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"leaveType\",\n        label: t(\"labels.leaveType\"),\n        render: (value, row) => getLocalizedText(row.leaveType?.name),\n      },\n      {\n        key: \"startDate\",\n        label: t(\"labels.startDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"endDate\",\n        label: t(\"labels.endDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"days\",\n        label: t(\"labels.days\"),\n        render: (value) => `${value} ${t(\"labels.day\")}`,\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"pending\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/leave-requests/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<LeaveRequestRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/leave-requests/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.leave-request\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/components/LeaveRequestForm/LeaveRequestForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[117,117],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[15,499],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  DatePicker,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":48,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DatePicker,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createLeaveRequestValidation,\n  type LeaveRequestFormValues,\n} from \"../../validation/leaveRequestValidation\";\n\nexport type { LeaveRequestFormValues };\n\ninterface LeaveRequestFormProps {\n  onSubmit: (values: LeaveRequestFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<LeaveRequestFormValues>;\n}\n\nexport default function LeaveRequestForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: LeaveRequestFormProps) {\n  const t = useTranslations(\"hrm.leaveRequests\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createLeaveRequestValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    watch,\n    setValue,\n    formState: { errors },\n  } = useForm<LeaveRequestFormValues>({\n    resolver: valibotResolver(validation.leaveRequestFormSchema) as any,\n    defaultValues: {\n      status: \"pending\",\n      days: 1,\n      ...defaultValues,\n    },\n  });\n\n  const startDate = watch(\"startDate\");\n  const endDate = watch(\"endDate\");\n\n  const calculateDays = useCallback(() => {\n    if (startDate && endDate) {\n      const start = new Date(startDate);\n      const end = new Date(endDate);\n      const diffTime = Math.abs(end.getTime() - start.getTime());\n      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;\n\n      if (diffDays > 0) {\n        setValue(\"days\", diffDays);\n      }\n    }\n  }, [startDate, endDate, setValue]);\n\n  const onSubmitForm: SubmitHandler<LeaveRequestFormValues> = async (\n    values,\n  ) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employee\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"leaveTypeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.leaveType\")}\n                  model=\"hrm.leave-type.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"startDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.startDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) => {\n                    field.onChange(val ? val.toString() : null);\n                    calculateDays();\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"endDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.endDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) => {\n                    field.onChange(val ? val.toString() : null);\n                    calculateDays();\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"days\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  readOnly\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.days\")}\n                  min={1}\n                  size=\"sm\"\n                  value={field.value}\n                  onValueChange={(val) => field.onChange(val ?? 1)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-leave-request-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"reason\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.reason\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveRequests/validation/leaveRequestValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/LeaveTypeCreatePage/LeaveTypeCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":78,"fix":{"range":[162,162],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,208],"text":"import { useTranslations } from \"next-intl\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[15,253],"text":"import { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport LeaveTypeForm, {\n  type LeaveTypeFormValues,\n} from \"../components/LeaveTypeForm/LeaveTypeForm\";\n\nexport default function LeaveTypeCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.leaveTypes\");\n\n  const {\n    handleSubmit: submitLeaveType,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof leaveTypeService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await leaveTypeService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateLeaveType\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-leave-types\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/leave-types/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: LeaveTypeFormValues) => {\n    await submitLeaveType({\n      code: typeof values.code === \"string\" ? values.code.trim() : \"\",\n      name:\n        values.name &&\n        typeof values.name === \"object\" &&\n        !Array.isArray(values.name) &&\n        (\"vi\" in values.name || \"en\" in values.name)\n          ? (values.name as { vi?: string; en?: string })\n          : { vi: \"\", en: \"\" },\n      description:\n        values.description &&\n        typeof values.description === \"object\" &&\n        !Array.isArray(values.description) &&\n        (values.description === null ||\n          \"vi\" in values.description ||\n          \"en\" in values.description)\n          ? (values.description as { vi?: string; en?: string } | null)\n          : null,\n      accrualType:\n        typeof values.accrualType === \"string\" ? values.accrualType.trim() : \"\",\n      accrualRate:\n        typeof values.accrualRate === \"number\" ? values.accrualRate : null,\n      maxAccrual:\n        typeof values.maxAccrual === \"number\" ? values.maxAccrual : null,\n      carryForward: values.carryForward === \"true\",\n      maxCarryForward:\n        typeof values.maxCarryForward === \"number\"\n          ? values.maxCarryForward\n          : null,\n      requiresApproval: values.requiresApproval === \"true\",\n      isPaid: values.isPaid === \"true\",\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  return (\n    <LeaveTypeForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/leave-types\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/LeaveTypeCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/LeaveTypeEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":78,"fix":{"range":[220,220],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,271],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,316],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,372],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport LeaveTypeForm, {\n  type LeaveTypeFormValues,\n} from \"./components/LeaveTypeForm/LeaveTypeForm\";\n\nexport default function LeaveTypeEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.leaveTypes\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: leaveTypeData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-leave-types\", id],\n    queryFn: async () => {\n      const response = await leaveTypeService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadLeaveType\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitLeaveType,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof leaveTypeService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await leaveTypeService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateLeaveType\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-leave-types\"], [\"hrm-leave-types\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/leave-types/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: LeaveTypeFormValues) => {\n    await submitLeaveType({\n      id,\n      code: typeof values.code === \"string\" ? values.code.trim() : undefined,\n      name:\n        values.name &&\n        typeof values.name === \"object\" &&\n        !Array.isArray(values.name) &&\n        (\"vi\" in values.name || \"en\" in values.name)\n          ? (values.name as { vi?: string; en?: string })\n          : undefined,\n      description:\n        values.description &&\n        typeof values.description === \"object\" &&\n        !Array.isArray(values.description) &&\n        (values.description === null ||\n          \"vi\" in values.description ||\n          \"en\" in values.description)\n          ? (values.description as { vi?: string; en?: string } | null)\n          : null,\n      accrualType:\n        typeof values.accrualType === \"string\"\n          ? values.accrualType.trim()\n          : undefined,\n      accrualRate:\n        typeof values.accrualRate === \"number\" ? values.accrualRate : null,\n      maxAccrual:\n        typeof values.maxAccrual === \"number\" ? values.maxAccrual : null,\n      carryForward: values.carryForward === \"true\",\n      maxCarryForward:\n        typeof values.maxCarryForward === \"number\"\n          ? values.maxCarryForward\n          : null,\n      requiresApproval: values.requiresApproval === \"true\",\n      isPaid: values.isPaid === \"true\",\n      isActive: values.isActive === \"true\",\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!leaveTypeData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <LeaveTypeForm\n      defaultValues={{\n        code: leaveTypeData.code,\n        name: (leaveTypeData.name as any) || { vi: \"\", en: \"\" },\n        description: leaveTypeData.description as any,\n        accrualType: leaveTypeData.accrualType,\n        accrualRate: leaveTypeData.accrualRate || undefined,\n        maxAccrual: leaveTypeData.maxAccrual || undefined,\n        carryForward: leaveTypeData.carryForward ? \"true\" : \"false\",\n        maxCarryForward: leaveTypeData.maxCarryForward || undefined,\n        requiresApproval: leaveTypeData.requiresApproval ? \"true\" : \"false\",\n        isPaid: leaveTypeData.isPaid ? \"true\" : \"false\",\n        isActive: leaveTypeData.isActive ? \"true\" : \"false\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/leave-types/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/LeaveTypeViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":78,"fix":{"range":[243,243],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/LeaveTypeService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":78,"fix":{"range":[166,333],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[332,332],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { leaveTypeService } from \"@mdl/hrm/client/services/LeaveTypeService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function LeaveTypeViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.leaveTypes\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: leaveTypeData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-leave-types\", id],\n    queryFn: async () => {\n      const response = await leaveTypeService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadLeaveType\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!leaveTypeData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/leave-types\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/leave-types/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.code\")}\n              value={leaveTypeData.code}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.name\")}\n              value={getLocalizedText(leaveTypeData.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.accrualType\")}\n              value={leaveTypeData.accrualType}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.accrualRate\")}\n              value={\n                leaveTypeData.accrualRate\n                  ? `${leaveTypeData.accrualRate} days`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.maxAccrual\")}\n              value={\n                leaveTypeData.maxAccrual\n                  ? `${leaveTypeData.maxAccrual} days`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.carryForward\")}\n              value={\n                leaveTypeData.carryForward ? tCommon(\"yes\") : tCommon(\"no\")\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.maxCarryForward\")}\n              value={\n                leaveTypeData.maxCarryForward\n                  ? `${leaveTypeData.maxCarryForward} days`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.requiresApproval\")}\n              value={\n                leaveTypeData.requiresApproval ? tCommon(\"yes\") : tCommon(\"no\")\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.isPaid\")}\n              value={leaveTypeData.isPaid ? tCommon(\"yes\") : tCommon(\"no\")}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.isActive\")}\n              value={\n                leaveTypeData.isActive ? tCommon(\"active\") : tCommon(\"inactive\")\n              }\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/LeaveTypesListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":53,"fix":{"range":[254,254],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,293],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,338],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[370,370],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,371],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { LeaveTypeDto } from \"@mdl/hrm/client/interface/LeaveType\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype LeaveTypeRow = LeaveTypeDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function LeaveTypesListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.leaveTypes\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<LeaveTypeRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"labels.code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/leave-types/view/${row.id}`}>\n              {value}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: t(\"labels.name\"),\n        render: (value) => getLocalizedText(value),\n      },\n      {\n        key: \"accrualType\",\n        label: t(\"labels.accrualType\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"accrualRate\",\n        label: t(\"labels.accrualRate\"),\n        render: (value) => (value ? `${value} days` : \"—\"),\n      },\n      {\n        key: \"isActive\",\n        label: t(\"labels.isActive\"),\n        render: (value) => (\n          <Chip color={value ? \"success\" : \"default\"} size=\"sm\" variant=\"flat\">\n            {value ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/leave-types/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<LeaveTypeRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/leave-types/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.leave-type\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/components/LeaveTypeForm/LeaveTypeForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[143,143],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,469],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":46,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Checkbox, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createLeaveTypeValidation,\n  type LeaveTypeFormValues,\n} from \"../../validation/leaveTypeValidation\";\n\nexport type { LeaveTypeFormValues };\n\ninterface LeaveTypeFormProps {\n  onSubmit: (values: LeaveTypeFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<LeaveTypeFormValues>;\n}\n\nexport default function LeaveTypeForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: LeaveTypeFormProps) {\n  const t = useTranslations(\"hrm.leaveTypes\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createLeaveTypeValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<LeaveTypeFormValues>({\n    resolver: valibotResolver(validation.leaveTypeFormSchema) as any,\n    defaultValues: {\n      carryForward: \"false\",\n      requiresApproval: \"true\",\n      isPaid: \"true\",\n      isActive: \"true\",\n      accrualType: \"monthly\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<LeaveTypeFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"code\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.code\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"name\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.name\")}\n                  size=\"sm\"\n                  value={field.value as any}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"accrualType\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.accrualType\")}\n                  model=\"base-accrual-type\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"accrualRate\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.accrualRate\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : null}\n                  onValueChange={(val) => field.onChange(val ?? null)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"maxAccrual\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.maxAccrual\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : null}\n                  onValueChange={(val) => field.onChange(val ?? null)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"maxCarryForward\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.maxCarryForward\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : null}\n                  onValueChange={(val) => field.onChange(val ?? null)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"carryForward\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.carryForward\")}\n                </Checkbox>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"requiresApproval\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.requiresApproval\")}\n                </Checkbox>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"isPaid\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.isPaid\")}\n                </Checkbox>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"isActive\"\n              render={({ field }) => (\n                <Checkbox\n                  isSelected={field.value === \"true\"}\n                  onValueChange={(val) =>\n                    field.onChange(val ? \"true\" : \"false\")\n                  }\n                >\n                  {t(\"labels.isActive\")}\n                </Checkbox>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"description\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.description\")}\n                    size=\"sm\"\n                    value={field.value ? JSON.stringify(field.value) : \"\"}\n                    onValueChange={(val) =>\n                      field.onChange(val ? {} : undefined)\n                    }\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/LeaveTypes/validation/leaveTypeValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/PayrollCreatePage/PayrollCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":74,"fix":{"range":[158,158],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[15,204],"text":"import { useTranslations } from \"next-intl\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/hooks/useCreateUpdate`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":45,"fix":{"range":[15,249],"text":"import { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\n\nimport PayrollForm, {\n  type PayrollFormValues,\n} from \"../components/PayrollForm/PayrollForm\";\n\nexport default function PayrollCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.payroll\");\n\n  const {\n    handleSubmit: submitPayroll,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof payrollService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await payrollService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreatePayroll\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-payroll\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/payroll/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: PayrollFormValues) => {\n    await submitPayroll({\n      payrollPeriodId:\n        typeof values.payrollPeriodId === \"string\"\n          ? values.payrollPeriodId.trim()\n          : \"\",\n      employeeId:\n        typeof values.employeeId === \"string\" ? values.employeeId.trim() : \"\",\n      baseSalary: typeof values.baseSalary === \"number\" ? values.baseSalary : 0,\n      overtimePay:\n        typeof values.overtimePay === \"number\" ? values.overtimePay : 0,\n      bonuses: typeof values.bonuses === \"number\" ? values.bonuses : 0,\n      otherEarnings:\n        typeof values.otherEarnings === \"number\" ? values.otherEarnings : 0,\n      socialInsurance:\n        typeof values.socialInsurance === \"number\" ? values.socialInsurance : 0,\n      healthInsurance:\n        typeof values.healthInsurance === \"number\" ? values.healthInsurance : 0,\n      unemploymentInsurance:\n        typeof values.unemploymentInsurance === \"number\"\n          ? values.unemploymentInsurance\n          : 0,\n      personalIncomeTax:\n        typeof values.personalIncomeTax === \"number\"\n          ? values.personalIncomeTax\n          : 0,\n      workingDays:\n        typeof values.workingDays === \"number\" ? values.workingDays : 0,\n      workingHours:\n        typeof values.workingHours === \"number\" ? values.workingHours : 0,\n      overtimeHours:\n        typeof values.overtimeHours === \"number\" ? values.overtimeHours : 0,\n      status: typeof values.status === \"string\" ? values.status : \"draft\",\n      notes: typeof values.notes === \"string\" ? values.notes.trim() : null,\n    });\n  };\n\n  return (\n    <PayrollForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/payroll\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/PayrollCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/PayrollEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":74,"fix":{"range":[216,216],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[15,267],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":45,"fix":{"range":[15,312],"text":"import { useTranslations } from \"next-intl\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next/navigation` import should occur before import of `@base/client/components`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":56,"fix":{"range":[15,368],"text":"import { useParams, useRouter } from \"next/navigation\";\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { LoadingOverlay } from \"@base/client/components\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\n\nimport PayrollForm, {\n  type PayrollFormValues,\n} from \"./components/PayrollForm/PayrollForm\";\n\nexport default function PayrollEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.payroll\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: payrollData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-payroll\", id],\n    queryFn: async () => {\n      const response = await payrollService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadPayroll\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitPayroll,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof payrollService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await payrollService.update(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdatePayroll\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-payroll\"], [\"hrm-payroll\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/payroll/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: PayrollFormValues) => {\n    await submitPayroll({\n      id,\n      payrollPeriodId:\n        typeof values.payrollPeriodId === \"string\"\n          ? values.payrollPeriodId.trim()\n          : undefined,\n      employeeId:\n        typeof values.employeeId === \"string\"\n          ? values.employeeId.trim()\n          : undefined,\n      baseSalary:\n        typeof values.baseSalary === \"number\" ? values.baseSalary : undefined,\n      overtimePay:\n        typeof values.overtimePay === \"number\" ? values.overtimePay : undefined,\n      bonuses: typeof values.bonuses === \"number\" ? values.bonuses : undefined,\n      otherEarnings:\n        typeof values.otherEarnings === \"number\"\n          ? values.otherEarnings\n          : undefined,\n      socialInsurance:\n        typeof values.socialInsurance === \"number\"\n          ? values.socialInsurance\n          : undefined,\n      healthInsurance:\n        typeof values.healthInsurance === \"number\"\n          ? values.healthInsurance\n          : undefined,\n      unemploymentInsurance:\n        typeof values.unemploymentInsurance === \"number\"\n          ? values.unemploymentInsurance\n          : undefined,\n      personalIncomeTax:\n        typeof values.personalIncomeTax === \"number\"\n          ? values.personalIncomeTax\n          : undefined,\n      workingDays:\n        typeof values.workingDays === \"number\" ? values.workingDays : undefined,\n      workingHours:\n        typeof values.workingHours === \"number\"\n          ? values.workingHours\n          : undefined,\n      overtimeHours:\n        typeof values.overtimeHours === \"number\"\n          ? values.overtimeHours\n          : undefined,\n      status: typeof values.status === \"string\" ? values.status : undefined,\n      notes: values.notes?.trim() || null,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!payrollData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <PayrollForm\n      defaultValues={{\n        payrollPeriodId: payrollData.payrollPeriodId,\n        employeeId: payrollData.employeeId,\n        baseSalary: payrollData.baseSalary,\n        overtimePay: payrollData.overtimePay,\n        bonuses: payrollData.bonuses,\n        otherEarnings: payrollData.otherEarnings,\n        socialInsurance: payrollData.socialInsurance,\n        healthInsurance: payrollData.healthInsurance,\n        unemploymentInsurance: payrollData.unemploymentInsurance,\n        personalIncomeTax: payrollData.personalIncomeTax,\n        workingDays: payrollData.workingDays,\n        workingHours: payrollData.workingHours,\n        overtimeHours: payrollData.overtimeHours,\n        status: payrollData.status,\n        notes: payrollData.notes || \"\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(`/workspace/modules/hrm/payroll/view/${id}`)}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/PayrollListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":53,"fix":{"range":[254,254],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,293],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,338],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[370,370],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,371],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { PayrollDto } from \"@mdl/hrm/client/interface/Payroll\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype PayrollRow = PayrollDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function PayrollListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.payroll\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<PayrollRow>[]>(\n    () => [\n      {\n        key: \"employee\",\n        label: t(\"labels.employee\"),\n        render: (value, row) => {\n          if (!row?.id) return null;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/payroll/view/${row.id}`}>\n              {getLocalizedText(row.employee?.fullName) ||\n                row.employee?.employeeCode ||\n                \"—\"}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"payrollPeriod\",\n        label: t(\"labels.payrollPeriod\"),\n        render: (value, row) => row.payrollPeriod?.code || \"—\",\n      },\n      {\n        key: \"grossSalary\",\n        label: t(\"labels.grossSalary\"),\n        render: (value) => (value ? value.toLocaleString() : \"—\"),\n      },\n      {\n        key: \"totalDeductions\",\n        label: t(\"labels.totalDeductions\"),\n        render: (value) => (value ? value.toLocaleString() : \"—\"),\n      },\n      {\n        key: \"netSalary\",\n        label: t(\"labels.netSalary\"),\n        render: (value) => (value ? value.toLocaleString() : \"—\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/payroll/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<PayrollRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/payroll/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.payroll\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/PayrollViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":74,"fix":{"range":[239,239],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/PayrollService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":74,"fix":{"range":[166,329],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[328,328],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { payrollService } from \"@mdl/hrm/client/services/PayrollService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function PayrollViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.payroll\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: payrollData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-payroll\", id],\n    queryFn: async () => {\n      const response = await payrollService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadPayroll\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!payrollData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/payroll\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/payroll/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.employee\")}\n              value={\n                getLocalizedText(payrollData.employee?.fullName) ||\n                payrollData.employee?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.payrollPeriod\")}\n              value={payrollData.payrollPeriod?.code || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.baseSalary\")}\n              value={payrollData.baseSalary?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.overtimePay\")}\n              value={payrollData.overtimePay?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.bonuses\")}\n              value={payrollData.bonuses?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.otherEarnings\")}\n              value={payrollData.otherEarnings?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.grossSalary\")}\n              value={payrollData.grossSalary?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.socialInsurance\")}\n              value={payrollData.socialInsurance?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.healthInsurance\")}\n              value={payrollData.healthInsurance?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.unemploymentInsurance\")}\n              value={payrollData.unemploymentInsurance?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.personalIncomeTax\")}\n              value={payrollData.personalIncomeTax?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.totalDeductions\")}\n              value={payrollData.totalDeductions?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.netSalary\")}\n              value={payrollData.netSalary?.toLocaleString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.workingDays\")}\n              value={payrollData.workingDays?.toString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.workingHours\")}\n              value={payrollData.workingHours?.toString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.overtimeHours\")}\n              value={payrollData.overtimeHours?.toString() || \"0\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={payrollData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.notes\")}\n              value={payrollData.notes || \"—\"}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/components/PayrollForm/PayrollForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":34,"fix":{"range":[103,103],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":34,"fix":{"range":[15,419],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":44,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\n\nimport {\n  createPayrollValidation,\n  type PayrollFormValues,\n} from \"../../validation/payrollValidation\";\n\nexport type { PayrollFormValues };\n\ninterface PayrollFormProps {\n  onSubmit: (values: PayrollFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<PayrollFormValues>;\n}\n\nexport default function PayrollForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: PayrollFormProps) {\n  const t = useTranslations(\"hrm.payroll\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createPayrollValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<PayrollFormValues>({\n    resolver: valibotResolver(validation.payrollFormSchema) as any,\n    defaultValues: {\n      status: \"draft\",\n      overtimePay: 0,\n      bonuses: 0,\n      otherEarnings: 0,\n      socialInsurance: 0,\n      healthInsurance: 0,\n      unemploymentInsurance: 0,\n      personalIncomeTax: 0,\n      workingDays: 0,\n      workingHours: 0,\n      overtimeHours: 0,\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<PayrollFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"payrollPeriodId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.payrollPeriod\")}\n                  model=\"hrm.payroll-period.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employee\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"baseSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.baseSalary\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"overtimePay\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.overtimePay\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"bonuses\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.bonuses\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"otherEarnings\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.otherEarnings\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"socialInsurance\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.socialInsurance\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"healthInsurance\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.healthInsurance\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"unemploymentInsurance\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.unemploymentInsurance\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"personalIncomeTax\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.personalIncomeTax\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"workingDays\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.workingDays\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"workingHours\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.workingHours\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"overtimeHours\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.overtimeHours\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-payroll-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.notes\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Payroll/validation/payrollValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/PerformanceReviewCreatePage/PerformanceReviewCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { performanceReviewService } from \"@mdl/hrm/client/services/PerformanceReviewService\";\n\nimport PerformanceReviewForm, {\n  type PerformanceReviewFormValues,\n} from \"../components/PerformanceReviewForm/PerformanceReviewForm\";\n\nexport default function PerformanceReviewCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.performanceReviews\");\n\n  const {\n    handleSubmit: submitPerformanceReview,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof performanceReviewService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await performanceReviewService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreatePerformanceReview\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-performance-reviews\"]],\n    onSuccess: (data) => {\n      router.push(\n        `/workspace/modules/hrm/performance-reviews/view/${data.data.id}`,\n      );\n    },\n  });\n\n  const handleSubmit = async (values: PerformanceReviewFormValues) => {\n    await submitPerformanceReview({\n      employeeId: values.employeeId.trim(),\n      reviewType: values.reviewType.trim(),\n      reviewPeriod: values.reviewPeriod?.trim() || null,\n      reviewDate: values.reviewDate.trim(),\n      reviewerId: values.reviewerId.trim(),\n      overallRating: values.overallRating || null,\n      strengths: values.strengths?.trim() || null,\n      areasForImprovement: values.areasForImprovement?.trim() || null,\n      goals: values.goals || null,\n      feedback: values.feedback?.trim() || null,\n      employeeComments: values.employeeComments?.trim() || null,\n      status: values.status || \"draft\",\n    });\n  };\n\n  return (\n    <PerformanceReviewForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/performance-reviews\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/PerformanceReviewCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/PerformanceReviewEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":56,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { performanceReviewService } from \"@mdl/hrm/client/services/PerformanceReviewService\";\nimport { LoadingOverlay } from \"@base/client/components\";\n\nimport PerformanceReviewForm, {\n  type PerformanceReviewFormValues,\n} from \"./components/PerformanceReviewForm/PerformanceReviewForm\";\n\nexport default function PerformanceReviewEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.performanceReviews\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: performanceReviewData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-performance-reviews\", id],\n    queryFn: async () => {\n      const response = await performanceReviewService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadPerformanceReview\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitPerformanceReview,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof performanceReviewService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await performanceReviewService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdatePerformanceReview\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [\n      [\"hrm-performance-reviews\"],\n      [\"hrm-performance-reviews\", id],\n    ],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/.../view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: PerformanceReviewFormValues) => {\n    await submitPerformanceReview({\n      id,\n      employeeId: values.employeeId.trim(),\n      reviewType: values.reviewType.trim(),\n      reviewPeriod: values.reviewPeriod?.trim() || null,\n      reviewDate: values.reviewDate.trim(),\n      reviewerId: values.reviewerId.trim(),\n      overallRating: values.overallRating || null,\n      strengths: values.strengths?.trim() || null,\n      areasForImprovement: values.areasForImprovement?.trim() || null,\n      goals: values.goals || null,\n      feedback: values.feedback?.trim() || null,\n      employeeComments: values.employeeComments?.trim() || null,\n      status: values.status || \"draft\",\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!performanceReviewData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <PerformanceReviewForm\n      defaultValues={{\n        employeeId: performanceReviewData.employeeId,\n        reviewType: performanceReviewData.reviewType,\n        reviewPeriod: performanceReviewData.reviewPeriod || \"\",\n        reviewDate: performanceReviewData.reviewDate,\n        reviewerId: performanceReviewData.reviewerId,\n        overallRating: performanceReviewData.overallRating || undefined,\n        strengths: performanceReviewData.strengths || \"\",\n        areasForImprovement: performanceReviewData.areasForImprovement || \"\",\n        feedback: performanceReviewData.feedback || \"\",\n        employeeComments: performanceReviewData.employeeComments || \"\",\n        status: performanceReviewData.status,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/performance-reviews/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/PerformanceReviewViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":94,"fix":{"range":[259,259],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/PerformanceReviewService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":94,"fix":{"range":[166,349],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { performanceReviewService } from \"@mdl/hrm/client/services/PerformanceReviewService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[348,348],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { performanceReviewService } from \"@mdl/hrm/client/services/PerformanceReviewService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nexport default function PerformanceReviewViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.performanceReviews\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: performanceReviewData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-performance-reviews\", id],\n    queryFn: async () => {\n      const response = await performanceReviewService.getById(id);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToLoadPerformanceReview\"),\n        );\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!performanceReviewData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() =>\n            router.push(\"/workspace/modules/hrm/performance-reviews\")\n          }\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/performance-reviews/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.employee\")}\n              value={\n                getLocalizedText(performanceReviewData.employee?.fullName) ||\n                performanceReviewData.employee?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.reviewType\")}\n              value={performanceReviewData.reviewType}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.reviewPeriod\")}\n              value={performanceReviewData.reviewPeriod || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.reviewDate\")}\n              value={formatDate(performanceReviewData.reviewDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.reviewer\")}\n              value={\n                getLocalizedText(performanceReviewData.reviewer?.fullName) ||\n                performanceReviewData.reviewer?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.overallRating\")}\n              value={\n                performanceReviewData.overallRating\n                  ? `${performanceReviewData.overallRating}/5`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={performanceReviewData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.completedDate\")}\n              value={formatDate(performanceReviewData.completedDate)}\n            />\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.strengths\")}\n                value={performanceReviewData.strengths || \"—\"}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.areasForImprovement\")}\n                value={performanceReviewData.areasForImprovement || \"—\"}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.feedback\")}\n                value={performanceReviewData.feedback || \"—\"}\n              />\n            </div>\n            <div className=\"md:col-span-2\">\n              <IBaseDigitViewer\n                label={t(\"labels.employeeComments\")}\n                value={performanceReviewData.employeeComments || \"—\"}\n              />\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/PerformanceReviewsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { PerformanceReviewDto } from \"@mdl/hrm/client/interface/PerformanceReview\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype PerformanceReviewRow = PerformanceReviewDto & {\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function PerformanceReviewsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.performanceReviews\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<PerformanceReviewRow>[]>(\n    () => [\n      {\n        key: \"employee\",\n        label: t(\"labels.employee\"),\n        render: (value, row) => {\n          if (!row?.id) return null;\n\n          return (\n            <LinkAs\n              href={`/workspace/modules/hrm/performance-reviews/view/${row.id}`}\n            >\n              {getLocalizedText(row.employee?.fullName) ||\n                row.employee?.employeeCode ||\n                \"—\"}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"reviewType\",\n        label: t(\"labels.reviewType\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"reviewPeriod\",\n        label: t(\"labels.reviewPeriod\"),\n        render: (value) => value || \"—\",\n      },\n      {\n        key: \"reviewDate\",\n        label: t(\"labels.reviewDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"reviewer\",\n        label: t(\"labels.reviewer\"),\n        render: (value, row) =>\n          getLocalizedText(row.reviewer?.fullName) ||\n          row.reviewer?.employeeCode ||\n          \"—\",\n      },\n      {\n        key: \"overallRating\",\n        label: t(\"labels.overallRating\"),\n        render: (value) => (value ? `${value}/5` : \"—\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"draft\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/performance-reviews/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<PerformanceReviewRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/performance-reviews/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.performance-review\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/components/PerformanceReviewForm/PerformanceReviewForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[131,131],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `@heroui/react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,500],"text":"import { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n  DatePicker,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":47,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n  DatePicker,\n} from \"@base/client/components\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\n\nimport {\n  createPerformanceReviewValidation,\n  type PerformanceReviewFormValues,\n} from \"../../validation/performanceReviewValidation\";\n\nexport type { PerformanceReviewFormValues };\n\ninterface PerformanceReviewFormProps {\n  onSubmit: (values: PerformanceReviewFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<PerformanceReviewFormValues>;\n}\n\nexport default function PerformanceReviewForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: PerformanceReviewFormProps) {\n  const t = useTranslations(\"hrm.performanceReviews\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createPerformanceReviewValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<PerformanceReviewFormValues>({\n    resolver: valibotResolver(validation.performanceReviewFormSchema) as any,\n    defaultValues: {\n      status: \"draft\",\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<PerformanceReviewFormValues> = async (\n    values,\n  ) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employee\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"reviewType\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.reviewType\")}\n                  model=\"base-review-type\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"reviewPeriod\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.reviewPeriod\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"reviewDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.reviewDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"reviewerId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.reviewer\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"overallRating\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.overallRating\")}\n                  max={5}\n                  min={1}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : null}\n                  onValueChange={(val) => field.onChange(val ?? null)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-performance-review-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"strengths\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.strengths\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"areasForImprovement\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.areasForImprovement\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"feedback\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.feedback\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"employeeComments\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.employeeComments\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/PerformanceReviews/validation/performanceReviewValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/PositionCreatePage/PositionCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { positionService } from \"@mdl/hrm/client/services/PositionService\";\n\nimport PositionForm, {\n  type PositionFormValues,\n} from \"../components/PositionForm/PositionForm\";\n\nexport default function PositionCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.position.create.labels\");\n\n  const {\n    handleSubmit: submitPosition,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof positionService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await positionService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToCreate\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-positions\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/positions/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: PositionFormValues) => {\n    const payload = {\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      departmentId: values.departmentId.trim(),\n      jobFamily: values.jobFamily?.trim() || null,\n      jobGrade: values.jobGrade?.trim() || null,\n      reportsTo: values.reportsTo?.trim() || null,\n      minSalary: values.minSalary ? Number(values.minSalary) : null,\n      maxSalary: values.maxSalary ? Number(values.maxSalary) : null,\n      isActive: values.isActive ?? true,\n    };\n\n    await submitPosition(payload);\n  };\n\n  return (\n    <PositionForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/positions\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/PositionCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/PositionEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `@tanstack/react-query`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":50,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { positionService } from \"@mdl/hrm/client/services/PositionService\";\n\nimport PositionForm, {\n  type PositionFormValues,\n} from \"./components/PositionForm/PositionForm\";\n\nexport default function PositionEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.position.create.labels\");\n\n  const { data: positionData, isLoading } = useQuery({\n    queryKey: [\"hrm-position\", id],\n    queryFn: async () => {\n      const response = await positionService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Position not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: updatePosition,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof positionService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await positionService.update({ ...payload, id });\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToUpdate\"));\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-positions\"], [\"hrm-position\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/positions/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: PositionFormValues) => {\n    const payload = {\n      code: values.code.trim(),\n      name: values.name || { vi: \"\", en: \"\" },\n      description: values.description || null,\n      departmentId: values.departmentId.trim(),\n      jobFamily: values.jobFamily?.trim() || null,\n      jobGrade: values.jobGrade?.trim() || null,\n      reportsTo: values.reportsTo?.trim() || null,\n      minSalary: values.minSalary ? Number(values.minSalary) : null,\n      maxSalary: values.maxSalary ? Number(values.maxSalary) : null,\n      isActive: values.isActive ?? true,\n    };\n\n    await updatePosition({ ...payload, id });\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!positionData) {\n    return <div>Position not found</div>;\n  }\n\n  return (\n    <PositionForm\n      defaultValues={{\n        code: positionData.code,\n        name: (positionData.name as any) || { vi: \"\", en: \"\" },\n        description: (positionData.description as any) || undefined,\n        departmentId: positionData.departmentId,\n        jobFamily: positionData.jobFamily || \"\",\n        jobGrade: positionData.jobGrade || \"\",\n        reportsTo: positionData.reportsTo || \"\",\n        minSalary: positionData.minSalary?.toString() || \"\",\n        maxSalary: positionData.maxSalary?.toString() || \"\",\n        isActive: positionData.isActive ?? true,\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/positions/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/PositionViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":50,"fix":{"range":[254,254],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { positionService } from \"@mdl/hrm/client/services/PositionService\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\nexport default function PositionViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.position.view.labels\");\n  const getLocalizedText = useLocalizedText();\n\n  const { data: position, isLoading } = useQuery({\n    queryKey: [\"hrm-position\", id],\n    queryFn: async () => {\n      const response = await positionService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Position not found\");\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!position) {\n    return <div>Position not found</div>;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-2xl font-bold\">{t(\"title\")}</h1>\n        <div className=\"flex gap-2\">\n          <Button\n            size=\"sm\"\n            variant=\"light\"\n            onPress={() => router.push(\"/workspace/modules/hrm/positions\")}\n          >\n            {t(\"backToList\")}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"sm\"\n            onPress={() =>\n              router.push(`/workspace/modules/hrm/positions/edit/${id}`)\n            }\n          >\n            {t(\"edit\")}\n          </Button>\n        </div>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">{t(\"basicInfo\")}</h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"code\")}</div>\n              <div className=\"text-base\">{position.code}</div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"name\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(position.name as any)}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"department\")}</div>\n              <div className=\"text-base\">\n                {getLocalizedText(position.department?.name as any) || \"—\"}\n              </div>\n            </div>\n            <div>\n              <div className=\"text-sm text-default-500\">{t(\"jobFamily\")}</div>\n              <div className=\"text-base\">{position.jobFamily || \"—\"}</div>\n            </div>\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/PositionsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":75,"fix":{"range":[308,308],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":38,"fix":{"range":[15,347],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":45,"fix":{"range":[15,392],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[424,424],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[15,425],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Position } from \"@mdl/hrm/client/interface/Position\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype PositionRow = Position & {\n  createdAt?: number | string | null;\n};\n\nexport default function PositionsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.position.list\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<PositionRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/positions/view/${row.id}`}>\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"name\",\n        label: t(\"name\"),\n        render: (value) => getLocalizedText(value as any),\n      },\n      {\n        key: \"department\",\n        label: t(\"department\"),\n        render: (_, row) =>\n          getLocalizedText(row.department?.name as any) || \"—\",\n      },\n      {\n        key: \"isActive\",\n        label: t(\"status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value ? \"active\" : \"inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/positions/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"view\"),\n                  href: viewLink,\n                },\n                {\n                  key: \"edit\",\n                  label: t(\"edit\"),\n                  href: `/workspace/modules/hrm/positions/edit/${row.id}`,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [t, tDataTable, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<PositionRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"newPosition\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/positions/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"position\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/components/PositionForm/PositionForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[203,203],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `@heroui/react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":34,"fix":{"range":[95,509],"text":"import { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":44,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { PositionFormValues } from \"../../validation/positionValidation\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelectAsync,\n} from \"@base/client/components\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\n\nimport { createPositionValidation } from \"../../validation/positionValidation\";\n\nexport type { PositionFormValues };\n\ninterface PositionFormProps {\n  onSubmit: (values: PositionFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<PositionFormValues>;\n}\n\nexport default function PositionForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: PositionFormProps) {\n  const t = useTranslations(\"hrm.position.create.validation\");\n  const tLabels = useTranslations(\"hrm.position.create.labels\");\n\n  const validation = useMemo(() => createPositionValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<PositionFormValues>({\n    resolver: valibotResolver(validation.positionFormSchema) as any,\n    defaultValues: {\n      isActive: true,\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<PositionFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tLabels(\"cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tLabels(\"save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-4\">\n            {tLabels(\"basicInfo\")}\n          </h2>\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"code\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"code\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"name\"\n              render={({ field, fieldState }) => (\n                <IBaseInputMultipleLang\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"name\")}\n                  size=\"sm\"\n                  value={field.value || { vi: \"\", en: \"\" }}\n                  onChange={field.onChange}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"departmentId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"department\")}\n                  model=\"department.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"reportsTo\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"reportsTo\")}\n                  model=\"position.dropdown\"\n                  selectedKey={field.value}\n                  size=\"sm\"\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"jobFamily\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"jobFamily\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"jobGrade\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"jobGrade\")}\n                  size=\"sm\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"minSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"minSalary\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n\n            <Controller\n              control={control}\n              name=\"maxSalary\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={tLabels(\"maxSalary\")}\n                  size=\"sm\"\n                  type=\"number\"\n                />\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Positions/validation/positionValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/TimesheetCreatePage/TimesheetCreatePageClient.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,175],"text":"import { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":45,"fix":{"range":[174,174],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useTranslations } from \"next-intl\";\nimport { useRouter } from \"next/navigation\";\nimport { timesheetService } from \"@mdl/hrm/client/services/TimesheetService\";\n\nimport TimesheetForm, {\n  type TimesheetFormValues,\n} from \"../components/TimesheetForm/TimesheetForm\";\n\nexport default function TimesheetCreatePageClient(): React.ReactNode {\n  const router = useRouter();\n  const t = useTranslations(\"hrm.timesheets\");\n\n  const {\n    handleSubmit: submitTimesheet,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof timesheetService.create>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await timesheetService.create(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToCreateTimesheet\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-timesheets\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/timesheets/view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: TimesheetFormValues) => {\n    await submitTimesheet({\n      employeeId: values.employeeId.trim(),\n      rosterId: values.rosterId?.trim() || null,\n      workDate: values.workDate.trim(),\n      shiftId: values.shiftId?.trim() || null,\n      checkInTime: values.checkInTime?.trim() || null,\n      checkOutTime: values.checkOutTime?.trim() || null,\n      breakDuration: values.breakDuration || 0,\n      status: values.status || \"pending\",\n      checkInMethod: values.checkInMethod?.trim() || null,\n      checkOutMethod: values.checkOutMethod?.trim() || null,\n      checkInLocation: values.checkInLocation?.trim() || null,\n      checkOutLocation: values.checkOutLocation?.trim() || null,\n      notes: values.notes?.trim() || null,\n    });\n  };\n\n  return (\n    <TimesheetForm\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() => router.push(\"/workspace/modules/hrm/timesheets\")}\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/TimesheetCreatePage/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/TimesheetEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `next/navigation`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":70,"fix":{"range":[15,236],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":56,"fix":{"range":[235,235],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { timesheetService } from \"@mdl/hrm/client/services/TimesheetService\";\nimport { LoadingOverlay } from \"@base/client/components\";\n\nimport TimesheetForm, {\n  type TimesheetFormValues,\n} from \"./components/TimesheetForm/TimesheetForm\";\n\nexport default function TimesheetEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.timesheets\");\n  const tCommon = useTranslations(\"common\");\n\n  const {\n    data: timesheetData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-timesheets\", id],\n    queryFn: async () => {\n      const response = await timesheetService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadTimesheet\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  const {\n    handleSubmit: submitTimesheet,\n    error: submitError,\n    isPending,\n  } = useCreateUpdate<\n    Parameters<typeof timesheetService.update>[0],\n    { data: { id: string } }\n  >({\n    mutationFn: async (payload) => {\n      const response = await timesheetService.update(payload);\n\n      if (!response.data) {\n        throw new Error(\n          response.message ?? t(\"errors.failedToUpdateTimesheet\"),\n        );\n      }\n\n      return { data: { id: response.data.id } };\n    },\n    invalidateQueries: [[\"hrm-timesheets\"], [\"hrm-timesheets\", id]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/hrm/.../view/${data.data.id}`);\n    },\n  });\n\n  const handleSubmit = async (values: TimesheetFormValues) => {\n    await submitTimesheet({\n      id,\n      employeeId: values.employeeId.trim(),\n      rosterId: values.rosterId?.trim() || null,\n      workDate: values.workDate.trim(),\n      shiftId: values.shiftId?.trim() || null,\n      checkInTime: values.checkInTime?.trim() || null,\n      checkOutTime: values.checkOutTime?.trim() || null,\n      breakDuration: values.breakDuration || 0,\n      status: values.status || \"pending\",\n      checkInMethod: values.checkInMethod?.trim() || null,\n      checkOutMethod: values.checkOutMethod?.trim() || null,\n      checkInLocation: values.checkInLocation?.trim() || null,\n      checkOutLocation: values.checkOutLocation?.trim() || null,\n      notes: values.notes?.trim() || null,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!timesheetData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <TimesheetForm\n      defaultValues={{\n        employeeId: timesheetData.employeeId,\n        rosterId: timesheetData.rosterId || \"\",\n        workDate: timesheetData.workDate,\n        shiftId: timesheetData.shiftId || \"\",\n        checkInTime: timesheetData.checkInTime\n          ? new Date(timesheetData.checkInTime).toISOString().slice(0, 16)\n          : \"\",\n        checkOutTime: timesheetData.checkOutTime\n          ? new Date(timesheetData.checkOutTime).toISOString().slice(0, 16)\n          : \"\",\n        breakDuration: timesheetData.breakDuration || 0,\n        status: timesheetData.status,\n        checkInMethod: timesheetData.checkInMethod || \"\",\n        checkOutMethod: timesheetData.checkOutMethod || \"\",\n        checkInLocation: timesheetData.checkInLocation || \"\",\n        checkOutLocation: timesheetData.checkOutLocation || \"\",\n        notes: timesheetData.notes || \"\",\n      }}\n      isSubmitting={isPending}\n      submitError={submitError}\n      onCancel={() =>\n        router.push(`/workspace/modules/hrm/timesheets/view/${id}`)\n      }\n      onSubmit={handleSubmit}\n    />\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/TimesheetViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":56,"fix":{"range":[165,165],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":78,"fix":{"range":[243,243],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@mdl/hrm/client/services/TimesheetService` import should occur after import of `@heroui/react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":78,"fix":{"range":[166,333],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { timesheetService } from \"@mdl/hrm/client/services/TimesheetService\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[332,332],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useTranslations } from \"next-intl\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { timesheetService } from \"@mdl/hrm/client/services/TimesheetService\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { LoadingOverlay, IBaseDigitViewer } from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nexport default function TimesheetViewPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams();\n  const id = params.id as string;\n  const t = useTranslations(\"hrm.timesheets\");\n  const tCommon = useTranslations(\"common\");\n  const getLocalizedText = useLocalizedText();\n\n  const {\n    data: timesheetData,\n    isLoading,\n    isError,\n    error,\n  } = useQuery({\n    queryKey: [\"hrm-timesheets\", id],\n    queryFn: async () => {\n      const response = await timesheetService.getById(id);\n\n      if (!response.data) {\n        throw new Error(response.message ?? t(\"errors.failedToLoadTimesheet\"));\n      }\n\n      return response.data;\n    },\n    enabled: !!id,\n  });\n\n  if (isLoading) {\n    return <LoadingOverlay isLoading={true} />;\n  }\n\n  if (isError) {\n    return (\n      <div className=\"text-danger-500\">\n        {tCommon(\"errors.failedToLoadData\")}: {error?.message}\n      </div>\n    );\n  }\n\n  if (!timesheetData) {\n    return (\n      <div className=\"text-warning-500\">{tCommon(\"errors.dataNotFound\")}</div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/hrm/timesheets\")}\n        >\n          {tCommon(\"actions.backToList\")}\n        </Button>\n        <Button\n          color=\"primary\"\n          size=\"sm\"\n          onPress={() =>\n            router.push(`/workspace/modules/hrm/timesheets/edit/${id}`)\n          }\n        >\n          {tCommon(\"actions.edit\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <IBaseDigitViewer\n              label={t(\"labels.employee\")}\n              value={\n                getLocalizedText(timesheetData.employee?.fullName) ||\n                timesheetData.employee?.employeeCode\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.workDate\")}\n              value={formatDate(timesheetData.workDate)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.shift\")}\n              value={getLocalizedText(timesheetData.shift?.name)}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkInTime\")}\n              value={\n                timesheetData.checkInTime\n                  ? formatDate(timesheetData.checkInTime)\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkOutTime\")}\n              value={\n                timesheetData.checkOutTime\n                  ? formatDate(timesheetData.checkOutTime)\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.actualHours\")}\n              value={\n                timesheetData.actualHours\n                  ? `${timesheetData.actualHours}h`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.regularHours\")}\n              value={\n                timesheetData.regularHours\n                  ? `${timesheetData.regularHours}h`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.overtimeHours\")}\n              value={\n                timesheetData.overtimeHours\n                  ? `${timesheetData.overtimeHours}h`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.breakDuration\")}\n              value={\n                timesheetData.breakDuration\n                  ? `${timesheetData.breakDuration} phút`\n                  : \"—\"\n              }\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.status\")}\n              value={timesheetData.status}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkInMethod\")}\n              value={timesheetData.checkInMethod || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkOutMethod\")}\n              value={timesheetData.checkOutMethod || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkInLocation\")}\n              value={timesheetData.checkInLocation || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.checkOutLocation\")}\n              value={timesheetData.checkOutLocation || \"—\"}\n            />\n            <IBaseDigitViewer\n              label={t(\"labels.notes\")}\n              value={timesheetData.notes || \"—\"}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/TimesheetsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[319,319],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,358],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,403],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[435,435],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,436],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n  ViewListDataTable,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { TimesheetDto } from \"@mdl/hrm/client/interface/Timesheet\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n\ntype TimesheetRow = TimesheetDto & {\n  workDate?: string | null;\n  createdAt?: number | string | null;\n  updatedAt?: number | string | null;\n};\n\nexport default function TimesheetsListPage(): React.ReactNode {\n  const tDataTable = useTranslations(\"dataTable\");\n  const t = useTranslations(\"hrm.timesheets\");\n  const getLocalizedText = useLocalizedText();\n\n  const columns = useMemo<DataTableColumn<TimesheetRow>[]>(\n    () => [\n      {\n        key: \"employee\",\n        label: t(\"labels.employee\"),\n        render: (value, row) => {\n          if (!row?.id) return null;\n\n          return (\n            <LinkAs href={`/workspace/modules/hrm/timesheets/view/${row.id}`}>\n              {getLocalizedText(row.employee?.fullName) ||\n                row.employee?.employeeCode ||\n                \"—\"}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"workDate\",\n        label: t(\"labels.workDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"shift\",\n        label: t(\"labels.shift\"),\n        render: (value, row) => getLocalizedText(row.shift?.name),\n      },\n      {\n        key: \"checkInTime\",\n        label: t(\"labels.checkInTime\"),\n        render: (value) => (value ? formatDate(value) : \"—\"),\n      },\n      {\n        key: \"checkOutTime\",\n        label: t(\"labels.checkOutTime\"),\n        render: (value) => (value ? formatDate(value) : \"—\"),\n      },\n      {\n        key: \"actualHours\",\n        label: t(\"labels.actualHours\"),\n        render: (value) => (value ? `${value}h` : \"—\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"labels.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {value || \"pending\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/hrm/timesheets/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: tDataTable(\"columns.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [tDataTable, t, getLocalizedText],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<TimesheetRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"create\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/hrm/timesheets/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"hrm.timesheet\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/components/TimesheetForm/TimesheetForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[131,131],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `@heroui/react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":34,"fix":{"range":[15,500],"text":"import { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n  DatePicker,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errors' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":47,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseInputNumber,\n  IBaseSingleSelectAsync,\n  DatePicker,\n} from \"@base/client/components\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { parseDate } from \"@internationalized/date\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { Controller, useForm, type SubmitHandler } from \"react-hook-form\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\n\nimport {\n  createTimesheetValidation,\n  type TimesheetFormValues,\n} from \"../../validation/timesheetValidation\";\n\nexport type { TimesheetFormValues };\n\ninterface TimesheetFormProps {\n  onSubmit: (values: TimesheetFormValues) => Promise<void>;\n  onCancel?: () => void;\n  submitError?: string | null;\n  isSubmitting?: boolean;\n  defaultValues?: Partial<TimesheetFormValues>;\n}\n\nexport default function TimesheetForm({\n  onSubmit,\n  onCancel,\n  submitError,\n  isSubmitting = false,\n  defaultValues,\n}: TimesheetFormProps) {\n  const t = useTranslations(\"hrm.timesheets\");\n  const tCommon = useTranslations(\"common\");\n\n  const validation = useMemo(() => createTimesheetValidation(t), [t]);\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<TimesheetFormValues>({\n    resolver: valibotResolver(validation.timesheetFormSchema) as any,\n    defaultValues: {\n      status: \"pending\",\n      breakDuration: 0,\n      ...defaultValues,\n    },\n  });\n\n  const onSubmitForm: SubmitHandler<TimesheetFormValues> = async (values) => {\n    await onSubmit(values);\n  };\n\n  return (\n    <form className=\"space-y-3\" onSubmit={handleSubmit(onSubmitForm)}>\n      {submitError ? (\n        <div className=\"mb-3 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n          {submitError}\n        </div>\n      ) : null}\n\n      <div className=\"sticky top-0 z-10 flex justify-end gap-3 py-2 mb-3 bg-background border-b border-divider -mx-4 px-4\">\n        {onCancel && (\n          <Button size=\"sm\" variant=\"light\" onPress={onCancel}>\n            {tCommon(\"actions.cancel\")}\n          </Button>\n        )}\n        <Button\n          color=\"primary\"\n          disabled={isSubmitting}\n          isLoading={isSubmitting}\n          size=\"sm\"\n          type=\"submit\"\n        >\n          {tCommon(\"actions.save\")}\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"p-4\">\n          <h2 className=\"text-base font-semibold mb-2\">{t(\"generalInfo\")}</h2>\n          <div className=\"grid gap-2 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"employeeId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  isRequired\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.employee\")}\n                  model=\"hrm.employee.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"workDate\"\n              render={({ field, fieldState }) => (\n                <DatePicker\n                  isRequired\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.workDate\")}\n                  value={\n                    field.value\n                      ? typeof field.value === \"string\"\n                        ? parseDate(field.value)\n                        : field.value\n                      : null\n                  }\n                  onChange={(val) =>\n                    field.onChange(val ? val.toString() : null)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"shiftId\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.shift\")}\n                  model=\"hrm.shift.dropdown\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"checkInTime\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.checkInTime\")}\n                  size=\"sm\"\n                  type=\"datetime-local\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"checkOutTime\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.checkOutTime\")}\n                  size=\"sm\"\n                  type=\"datetime-local\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"breakDuration\"\n              render={({ field, fieldState }) => (\n                <IBaseInputNumber\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.breakDuration\")}\n                  min={0}\n                  size=\"sm\"\n                  value={typeof field.value === \"number\" ? field.value : 0}\n                  onValueChange={(val) => field.onChange(val ?? 0)}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"status\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.status\")}\n                  model=\"base-timesheet-status\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"checkInMethod\"\n              render={({ field, fieldState }) => (\n                <IBaseSingleSelectAsync\n                  callWhen=\"mount\"\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.checkInMethod\")}\n                  model=\"base-check-method\"\n                  selectedKey={field.value}\n                  onSelectionChange={(key) => {\n                    field.onChange(key || undefined);\n                  }}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"checkInLocation\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.checkInLocation\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"checkOutLocation\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label={t(\"labels.checkOutLocation\")}\n                  size=\"sm\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <div className=\"md:col-span-2\">\n                  <Textarea\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label={t(\"labels.notes\")}\n                    size=\"sm\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/pages/Timesheets/validation/timesheetValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/CandidateService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/CertificateService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/ContractService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/CourseService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/DepartmentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/EmployeeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/JobRequisitionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/LeaveRequestService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/LeaveTypeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/PayrollService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/PerformanceReviewService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/PositionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/client/services/TimesheetService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/AuditLog/AuditLogModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":54,"fix":{"range":[0,113],"text":"import { and, eq, gte, lte, sql } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, gte, lte, sql } from \"drizzle-orm\";\n\nimport { NewHrmTbAuditLog, hrm_tb_audit_logs } from \"../../schemas\";\n\nexport interface AuditLogRow {\n  id: string;\n  entityType: string;\n  entityId: string;\n  action: string;\n  performedBy: string;\n  ipAddress?: string | null;\n  userAgent?: string | null;\n  changes?: unknown;\n  metadata?: unknown;\n  createdAt: number;\n}\n\nexport interface AuditLogInput {\n  entityType: string;\n  entityId: string;\n  action: string;\n  performedBy: string;\n  ipAddress?: string | null;\n  userAgent?: string | null;\n  changes?: unknown;\n  metadata?: unknown;\n}\n\nexport interface AuditLogQuery {\n  entityType?: string;\n  entityId?: string;\n  action?: string;\n  performedBy?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}\n\nexport default class AuditLogModel extends BaseModel<typeof hrm_tb_audit_logs> {\n  constructor() {\n    super(hrm_tb_audit_logs);\n  }\n\n  createAuditLog = async (payload: AuditLogInput): Promise<AuditLogRow> => {\n    const insertData: NewHrmTbAuditLog = {\n      entityType: payload.entityType,\n      entityId: payload.entityId,\n      action: payload.action,\n      performedBy: payload.performedBy,\n      ipAddress: payload.ipAddress ?? null,\n      userAgent: payload.userAgent ?? null,\n      changes: payload.changes ?? null,\n      metadata: payload.metadata ?? null,\n      createdAt: new Date(),\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning();\n\n    return {\n      id: created.id,\n      entityType: created.entityType,\n      entityId: created.entityId,\n      action: created.action,\n      performedBy: created.performedBy,\n      ipAddress: created.ipAddress ?? undefined,\n      userAgent: created.userAgent ?? undefined,\n      changes: created.changes ?? undefined,\n      metadata: created.metadata ?? undefined,\n      createdAt: created.createdAt.getTime(),\n    };\n  };\n\n  queryAuditLogs = async (\n    query: AuditLogQuery,\n  ): Promise<{ logs: AuditLogRow[]; total: number }> => {\n    const conditions = [];\n\n    if (query.entityType) {\n      conditions.push(eq(this.table.entityType, query.entityType));\n    }\n    if (query.entityId) {\n      conditions.push(eq(this.table.entityId, query.entityId));\n    }\n    if (query.action) {\n      conditions.push(eq(this.table.action, query.action));\n    }\n    if (query.performedBy) {\n      conditions.push(eq(this.table.performedBy, query.performedBy));\n    }\n    if (query.startDate) {\n      conditions.push(gte(this.table.createdAt, query.startDate));\n    }\n    if (query.endDate) {\n      conditions.push(lte(this.table.createdAt, query.endDate));\n    }\n\n    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n    const [logs, totalResult] = await Promise.all([\n      this.db\n        .select()\n        .from(this.table)\n        .where(whereClause)\n        .orderBy(this.table.createdAt)\n        .limit(query.limit ?? 100)\n        .offset(query.offset ?? 0),\n      this.db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(this.table)\n        .where(whereClause),\n    ]);\n\n    return {\n      logs: logs.map((log) => ({\n        id: log.id,\n        entityType: log.entityType,\n        entityId: log.entityId,\n        action: log.action,\n        performedBy: log.performedBy,\n        ipAddress: log.ipAddress ?? undefined,\n        userAgent: log.userAgent ?? undefined,\n        changes: log.changes ?? undefined,\n        metadata: log.metadata ?? undefined,\n        createdAt: log.createdAt.getTime(),\n      })),\n      total: totalResult[0]?.count ?? 0,\n    };\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/AuditLog/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/BenefitPackage/BenefitPackageModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbBenefitPackage, hrm_tb_benefit_packages } from \"../../schemas\";\n\nexport interface BenefitPackageRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  benefitType: string;\n  coverage?: unknown;\n  cost?: number | null;\n  currency?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface BenefitPackageInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  benefitType: string;\n  coverage?: unknown;\n  cost?: number | null;\n  currency?: string | null;\n  isActive?: boolean;\n}\n\nexport default class BenefitPackageModel extends BaseModel<\n  typeof hrm_tb_benefit_packages\n> {\n  constructor() {\n    super(hrm_tb_benefit_packages);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getBenefitPackageById = async (\n    id: string,\n  ): Promise<BenefitPackageRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      benefitType: row.benefitType,\n      coverage: row.coverage,\n      cost: row.cost ?? undefined,\n      currency: row.currency ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<BenefitPackageRow | null> => {\n    return this.getBenefitPackageById(params.id);\n  };\n\n  createBenefitPackage = async (\n    payload: BenefitPackageInput,\n  ): Promise<BenefitPackageRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbBenefitPackage = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      benefitType: payload.benefitType,\n      coverage: payload.coverage ?? null,\n      cost: payload.cost ?? null,\n      currency: payload.currency ?? \"VND\",\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create benefit package\");\n\n    const benefitPackage = await this.getBenefitPackageById(created.id);\n\n    if (!benefitPackage)\n      throw new Error(\"Failed to load benefit package after creation\");\n\n    return benefitPackage;\n  };\n\n  updateBenefitPackage = async (\n    id: string,\n    payload: Partial<BenefitPackageInput>,\n  ): Promise<BenefitPackageRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.benefitType !== undefined)\n      updateData.benefitType = payload.benefitType;\n    if (payload.coverage !== undefined)\n      updateData.coverage = payload.coverage ?? null;\n    if (payload.cost !== undefined) updateData.cost = payload.cost ?? null;\n    if (payload.currency !== undefined)\n      updateData.currency = payload.currency ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getBenefitPackageById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<BenefitPackageInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.benefitType !== undefined) {\n      normalizedPayload.benefitType = String(payload.benefitType);\n    }\n    if (payload.coverage !== undefined) {\n      normalizedPayload.coverage = payload.coverage;\n    }\n    if (payload.cost !== undefined) {\n      normalizedPayload.cost =\n        payload.cost === null || payload.cost === \"\"\n          ? null\n          : Number(payload.cost);\n    }\n    if (payload.currency !== undefined) {\n      normalizedPayload.currency =\n        payload.currency === null || payload.currency === \"\"\n          ? null\n          : String(payload.currency);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateBenefitPackage(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/BenefitPackage/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Candidate/CandidateModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbCandidate, hrm_tb_candidates } from \"../../schemas\";\nimport { hrm_tb_job_requisitions } from \"../../schemas/hrm.job-requisition\";\n\nconst requisition = alias(hrm_tb_job_requisitions, \"requisition\");\n\nexport interface CandidateRow {\n  id: string;\n  requisitionId: string;\n  requisition?: {\n    id: string;\n    requisitionNumber?: string;\n    title?: unknown;\n  } | null;\n  firstName?: string | null;\n  lastName?: string | null;\n  fullName?: unknown;\n  email?: string | null;\n  phone?: string | null;\n  dateOfBirth?: string | null;\n  gender?: string | null;\n  address?: unknown;\n  cvUrl?: string | null;\n  coverLetter?: string | null;\n  source?: string | null;\n  status: string;\n  stage?: string | null;\n  rating?: number | null;\n  notes?: string | null;\n  appliedDate?: number | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface CandidateInput {\n  requisitionId: string;\n  firstName?: string | null;\n  lastName?: string | null;\n  fullName: LocaleDataType<string>;\n  email?: string | null;\n  phone?: string | null;\n  dateOfBirth?: string | null;\n  gender?: string | null;\n  address?: unknown;\n  cvUrl?: string | null;\n  coverLetter?: string | null;\n  source?: string | null;\n  status?: string;\n  stage?: string | null;\n  rating?: number | null;\n  notes?: string | null;\n}\n\nexport default class CandidateModel extends BaseModel<\n  typeof hrm_tb_candidates\n> {\n  constructor() {\n    super(hrm_tb_candidates);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getCandidateById = async (id: string): Promise<CandidateRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        requisitionId: this.table.requisitionId,\n        requisitionNumber: requisition.requisitionNumber,\n        requisitionTitle: requisition.title,\n        firstName: this.table.firstName,\n        lastName: this.table.lastName,\n        fullName: this.table.fullName,\n        email: this.table.email,\n        phone: this.table.phone,\n        dateOfBirth: this.table.dateOfBirth,\n        gender: this.table.gender,\n        address: this.table.address,\n        cvUrl: this.table.cvUrl,\n        coverLetter: this.table.coverLetter,\n        source: this.table.source,\n        status: this.table.status,\n        stage: this.table.stage,\n        rating: this.table.rating,\n        notes: this.table.notes,\n        appliedDate: this.table.appliedDate,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(requisition, eq(this.table.requisitionId, requisition.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      requisitionId: row.requisitionId,\n      requisition: row.requisitionId\n        ? {\n            id: row.requisitionId,\n            requisitionNumber: row.requisitionNumber ?? undefined,\n            title: row.requisitionTitle ?? undefined,\n          }\n        : null,\n      firstName: row.firstName ?? undefined,\n      lastName: row.lastName ?? undefined,\n      fullName: row.fullName,\n      email: row.email ?? undefined,\n      phone: row.phone ?? undefined,\n      dateOfBirth: row.dateOfBirth ?? undefined,\n      gender: row.gender ?? undefined,\n      address: row.address,\n      cvUrl: row.cvUrl ?? undefined,\n      coverLetter: row.coverLetter ?? undefined,\n      source: row.source ?? undefined,\n      status: row.status,\n      stage: row.stage ?? undefined,\n      rating: row.rating ?? undefined,\n      notes: row.notes ?? undefined,\n      appliedDate: row.appliedDate?.getTime(),\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<CandidateRow | null> => {\n    return this.getCandidateById(params.id);\n  };\n\n  createCandidate = async (payload: CandidateInput): Promise<CandidateRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbCandidate = {\n      requisitionId: payload.requisitionId,\n      firstName: payload.firstName ?? null,\n      lastName: payload.lastName ?? null,\n      fullName: payload.fullName,\n      email: payload.email ?? null,\n      phone: payload.phone ?? null,\n      dateOfBirth: payload.dateOfBirth ?? null,\n      gender: payload.gender ?? null,\n      address: payload.address ?? null,\n      cvUrl: payload.cvUrl ?? null,\n      coverLetter: payload.coverLetter ?? null,\n      source: payload.source ?? null,\n      status: payload.status ?? \"applied\",\n      stage: payload.stage ?? null,\n      rating: payload.rating ?? null,\n      notes: payload.notes ?? null,\n      appliedDate: now,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create candidate\");\n\n    const candidate = await this.getCandidateById(created.id);\n\n    if (!candidate) throw new Error(\"Failed to load candidate after creation\");\n\n    return candidate;\n  };\n\n  updateCandidate = async (\n    id: string,\n    payload: Partial<CandidateInput>,\n  ): Promise<CandidateRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.requisitionId !== undefined)\n      updateData.requisitionId = payload.requisitionId;\n    if (payload.firstName !== undefined)\n      updateData.firstName = payload.firstName ?? null;\n    if (payload.lastName !== undefined)\n      updateData.lastName = payload.lastName ?? null;\n    if (payload.fullName !== undefined) updateData.fullName = payload.fullName;\n    if (payload.email !== undefined) updateData.email = payload.email ?? null;\n    if (payload.phone !== undefined) updateData.phone = payload.phone ?? null;\n    if (payload.dateOfBirth !== undefined)\n      updateData.dateOfBirth = payload.dateOfBirth ?? null;\n    if (payload.gender !== undefined)\n      updateData.gender = payload.gender ?? null;\n    if (payload.address !== undefined)\n      updateData.address = payload.address ?? null;\n    if (payload.cvUrl !== undefined) updateData.cvUrl = payload.cvUrl ?? null;\n    if (payload.coverLetter !== undefined)\n      updateData.coverLetter = payload.coverLetter ?? null;\n    if (payload.source !== undefined)\n      updateData.source = payload.source ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.stage !== undefined) updateData.stage = payload.stage ?? null;\n    if (payload.rating !== undefined)\n      updateData.rating = payload.rating ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getCandidateById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<CandidateInput> = {};\n\n    if (payload.requisitionId !== undefined) {\n      normalizedPayload.requisitionId = String(payload.requisitionId);\n    }\n    if (payload.firstName !== undefined) {\n      normalizedPayload.firstName =\n        payload.firstName === null || payload.firstName === \"\"\n          ? null\n          : String(payload.firstName);\n    }\n    if (payload.lastName !== undefined) {\n      normalizedPayload.lastName =\n        payload.lastName === null || payload.lastName === \"\"\n          ? null\n          : String(payload.lastName);\n    }\n    if (payload.fullName !== undefined) {\n      normalizedPayload.fullName = this.normalizeLocaleInput(\n        payload.fullName,\n      ) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.email !== undefined) {\n      normalizedPayload.email =\n        payload.email === null || payload.email === \"\"\n          ? null\n          : String(payload.email);\n    }\n    if (payload.phone !== undefined) {\n      normalizedPayload.phone =\n        payload.phone === null || payload.phone === \"\"\n          ? null\n          : String(payload.phone);\n    }\n    if (payload.dateOfBirth !== undefined) {\n      normalizedPayload.dateOfBirth =\n        payload.dateOfBirth === null || payload.dateOfBirth === \"\"\n          ? null\n          : String(payload.dateOfBirth);\n    }\n    if (payload.gender !== undefined) {\n      normalizedPayload.gender =\n        payload.gender === null || payload.gender === \"\"\n          ? null\n          : String(payload.gender);\n    }\n    if (payload.address !== undefined) {\n      normalizedPayload.address = payload.address;\n    }\n    if (payload.cvUrl !== undefined) {\n      normalizedPayload.cvUrl =\n        payload.cvUrl === null || payload.cvUrl === \"\"\n          ? null\n          : String(payload.cvUrl);\n    }\n    if (payload.coverLetter !== undefined) {\n      normalizedPayload.coverLetter =\n        payload.coverLetter === null || payload.coverLetter === \"\"\n          ? null\n          : String(payload.coverLetter);\n    }\n    if (payload.source !== undefined) {\n      normalizedPayload.source =\n        payload.source === null || payload.source === \"\"\n          ? null\n          : String(payload.source);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.stage !== undefined) {\n      normalizedPayload.stage =\n        payload.stage === null || payload.stage === \"\"\n          ? null\n          : String(payload.stage);\n    }\n    if (payload.rating !== undefined) {\n      normalizedPayload.rating =\n        payload.rating === null || payload.rating === \"\"\n          ? null\n          : Number(payload.rating);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateCandidate(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Candidate/CandidateViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_candidates } from \"../../schemas\";\nimport { hrm_tb_job_requisitions } from \"../../schemas/hrm.job-requisition\";\n\nconst requisition = alias(hrm_tb_job_requisitions, \"requisition\");\n\nexport interface CandidateRow {\n  id: string;\n  requisitionId: string;\n  requisition?: {\n    id: string;\n    requisitionNumber?: string;\n    title?: unknown;\n  } | null;\n  fullName?: unknown;\n  email?: string | null;\n  phone?: string | null;\n  status: string;\n  stage?: string | null;\n  rating?: number | null;\n  appliedDate?: number | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass CandidateViewListModel extends BaseViewListModel<\n  typeof hrm_tb_candidates,\n  CandidateRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_candidates.id, sort: true }],\n      [\n        \"requisitionId\",\n        { column: hrm_tb_candidates.requisitionId, sort: true },\n      ],\n      [\"fullName\", { column: hrm_tb_candidates.fullName, sort: true }],\n      [\"email\", { column: hrm_tb_candidates.email, sort: true }],\n      [\"phone\", { column: hrm_tb_candidates.phone, sort: true }],\n      [\"status\", { column: hrm_tb_candidates.status, sort: true }],\n      [\"stage\", { column: hrm_tb_candidates.stage, sort: true }],\n      [\"rating\", { column: hrm_tb_candidates.rating, sort: true }],\n      [\"appliedDate\", { column: hrm_tb_candidates.appliedDate, sort: true }],\n      [\"createdAt\", { column: hrm_tb_candidates.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_candidates.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_candidates });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"fullName\", (text: string) => ilike(hrm_tb_candidates.fullName, text)],\n      [\"email\", (text: string) => ilike(hrm_tb_candidates.email, text)],\n      [\"phone\", (text: string) => ilike(hrm_tb_candidates.phone, text)],\n      [\n        \"requisitionNumber\",\n        (text: string) => ilike(requisition.requisitionNumber, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): CandidateRow => ({\n    id: row.id,\n    requisitionId: row.requisitionId,\n    requisition: row.requisitionId\n      ? {\n          id: row.requisitionId,\n          requisitionNumber: row.requisitionNumber ?? undefined,\n          title: row.requisitionTitle ?? undefined,\n        }\n      : null,\n    fullName: row.fullName,\n    email: row.email ?? undefined,\n    phone: row.phone ?? undefined,\n    status: row.status,\n    stage: row.stage ?? undefined,\n    rating: row.rating ?? undefined,\n    appliedDate: row.appliedDate?.getTime(),\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<CandidateRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(requisition, eq(this.table.requisitionId, requisition.id)),\n    );\n  };\n}\n\nexport default CandidateViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Candidate/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Certificate/CertificateModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbCertificate, hrm_tb_certificates } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface CertificateRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  name?: unknown;\n  issuer: string;\n  certificateNumber?: string | null;\n  issueDate: string;\n  expiryDate?: string | null;\n  documentUrl?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface CertificateInput {\n  employeeId: string;\n  name: LocaleDataType<string>;\n  issuer: string;\n  certificateNumber?: string | null;\n  issueDate: string;\n  expiryDate?: string | null;\n  documentUrl?: string | null;\n  isActive?: boolean;\n}\n\nexport default class CertificateModel extends BaseModel<\n  typeof hrm_tb_certificates\n> {\n  constructor() {\n    super(hrm_tb_certificates);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getCertificateById = async (id: string): Promise<CertificateRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        name: this.table.name,\n        issuer: this.table.issuer,\n        certificateNumber: this.table.certificateNumber,\n        issueDate: this.table.issueDate,\n        expiryDate: this.table.expiryDate,\n        documentUrl: this.table.documentUrl,\n        isActive: this.table.isActive,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      name: row.name,\n      issuer: row.issuer,\n      certificateNumber: row.certificateNumber ?? undefined,\n      issueDate: row.issueDate,\n      expiryDate: row.expiryDate ?? undefined,\n      documentUrl: row.documentUrl ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<CertificateRow | null> => {\n    return this.getCertificateById(params.id);\n  };\n\n  createCertificate = async (\n    payload: CertificateInput,\n  ): Promise<CertificateRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbCertificate = {\n      employeeId: payload.employeeId,\n      name: payload.name,\n      issuer: payload.issuer,\n      certificateNumber: payload.certificateNumber ?? null,\n      issueDate: payload.issueDate,\n      expiryDate: payload.expiryDate ?? null,\n      documentUrl: payload.documentUrl ?? null,\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create certificate\");\n\n    const certificate = await this.getCertificateById(created.id);\n\n    if (!certificate)\n      throw new Error(\"Failed to load certificate after creation\");\n\n    return certificate;\n  };\n\n  updateCertificate = async (\n    id: string,\n    payload: Partial<CertificateInput>,\n  ): Promise<CertificateRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.issuer !== undefined) updateData.issuer = payload.issuer;\n    if (payload.certificateNumber !== undefined)\n      updateData.certificateNumber = payload.certificateNumber ?? null;\n    if (payload.issueDate !== undefined)\n      updateData.issueDate = payload.issueDate;\n    if (payload.expiryDate !== undefined)\n      updateData.expiryDate = payload.expiryDate ?? null;\n    if (payload.documentUrl !== undefined)\n      updateData.documentUrl = payload.documentUrl ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getCertificateById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<CertificateInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.issuer !== undefined) {\n      normalizedPayload.issuer = String(payload.issuer);\n    }\n    if (payload.certificateNumber !== undefined) {\n      normalizedPayload.certificateNumber =\n        payload.certificateNumber === null || payload.certificateNumber === \"\"\n          ? null\n          : String(payload.certificateNumber);\n    }\n    if (payload.issueDate !== undefined) {\n      normalizedPayload.issueDate = String(payload.issueDate);\n    }\n    if (payload.expiryDate !== undefined) {\n      normalizedPayload.expiryDate =\n        payload.expiryDate === null || payload.expiryDate === \"\"\n          ? null\n          : String(payload.expiryDate);\n    }\n    if (payload.documentUrl !== undefined) {\n      normalizedPayload.documentUrl =\n        payload.documentUrl === null || payload.documentUrl === \"\"\n          ? null\n          : String(payload.documentUrl);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateCertificate(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Certificate/CertificateViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_certificates } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface CertificateRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  name?: unknown;\n  issuer: string;\n  certificateNumber?: string | null;\n  issueDate: string;\n  expiryDate?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass CertificateViewListModel extends BaseViewListModel<\n  typeof hrm_tb_certificates,\n  CertificateRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_certificates.id, sort: true }],\n      [\"employeeId\", { column: hrm_tb_certificates.employeeId, sort: true }],\n      [\"name\", { column: hrm_tb_certificates.name, sort: true }],\n      [\"issuer\", { column: hrm_tb_certificates.issuer, sort: true }],\n      [\"issueDate\", { column: hrm_tb_certificates.issueDate, sort: true }],\n      [\"expiryDate\", { column: hrm_tb_certificates.expiryDate, sort: true }],\n      [\"isActive\", { column: hrm_tb_certificates.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_certificates.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_certificates.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_certificates });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"employeeCode\", (text: string) => ilike(employee.employeeCode, text)],\n      [\"fullName\", (text: string) => ilike(employee.fullName, text)],\n      [\"issuer\", (text: string) => ilike(hrm_tb_certificates.issuer, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): CertificateRow => ({\n    id: row.id,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    name: row.name,\n    issuer: row.issuer,\n    certificateNumber: row.certificateNumber ?? undefined,\n    issueDate: row.issueDate,\n    expiryDate: row.expiryDate ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<CertificateRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(employee, eq(this.table.employeeId, employee.id)),\n    );\n  };\n}\n\nexport default CertificateViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Certificate/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/ComplianceReport/ComplianceReportModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":34,"fix":{"range":[0,93],"text":"import { eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport {\n  NewHrmTbComplianceReport,\n  hrm_tb_compliance_reports,\n} from \"../../schemas\";\n\nexport interface ComplianceReportRow {\n  id: string;\n  reportNumber: string;\n  reportType: string;\n  reportingPeriod: string;\n  reportDate: string;\n  submittedDate?: string | null;\n  status: string;\n  fileUrl?: string | null;\n  data?: unknown;\n  notes?: string | null;\n  approvedBy?: string | null;\n  approvedAt?: number | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface ComplianceReportInput {\n  reportNumber: string;\n  reportType: string;\n  reportingPeriod: string;\n  reportDate: string;\n  submittedDate?: string | null;\n  status?: string;\n  fileUrl?: string | null;\n  data?: unknown;\n  notes?: string | null;\n}\n\nexport default class ComplianceReportModel extends BaseModel<\n  typeof hrm_tb_compliance_reports\n> {\n  constructor() {\n    super(hrm_tb_compliance_reports);\n  }\n\n  getComplianceReportById = async (\n    id: string,\n  ): Promise<ComplianceReportRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      reportNumber: row.reportNumber,\n      reportType: row.reportType,\n      reportingPeriod: row.reportingPeriod,\n      reportDate: row.reportDate,\n      submittedDate: row.submittedDate ?? undefined,\n      status: row.status,\n      fileUrl: row.fileUrl ?? undefined,\n      data: row.data,\n      notes: row.notes ?? undefined,\n      approvedBy: row.approvedBy ?? undefined,\n      approvedAt: row.approvedAt?.getTime(),\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<ComplianceReportRow | null> => {\n    return this.getComplianceReportById(params.id);\n  };\n\n  createComplianceReport = async (\n    payload: ComplianceReportInput,\n  ): Promise<ComplianceReportRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbComplianceReport = {\n      reportNumber: payload.reportNumber,\n      reportType: payload.reportType,\n      reportingPeriod: payload.reportingPeriod,\n      reportDate: payload.reportDate,\n      submittedDate: payload.submittedDate ?? null,\n      status: payload.status ?? \"draft\",\n      fileUrl: payload.fileUrl ?? null,\n      data: payload.data ?? null,\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create compliance report\");\n\n    const report = await this.getComplianceReportById(created.id);\n\n    if (!report)\n      throw new Error(\"Failed to load compliance report after creation\");\n\n    return report;\n  };\n\n  updateComplianceReport = async (\n    id: string,\n    payload: Partial<ComplianceReportInput>,\n  ): Promise<ComplianceReportRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.reportNumber !== undefined)\n      updateData.reportNumber = payload.reportNumber;\n    if (payload.reportType !== undefined)\n      updateData.reportType = payload.reportType;\n    if (payload.reportingPeriod !== undefined)\n      updateData.reportingPeriod = payload.reportingPeriod;\n    if (payload.reportDate !== undefined)\n      updateData.reportDate = payload.reportDate;\n    if (payload.submittedDate !== undefined)\n      updateData.submittedDate = payload.submittedDate ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.fileUrl !== undefined)\n      updateData.fileUrl = payload.fileUrl ?? null;\n    if (payload.data !== undefined) updateData.data = payload.data ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getComplianceReportById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<ComplianceReportInput> = {};\n\n    if (payload.reportNumber !== undefined) {\n      normalizedPayload.reportNumber = String(payload.reportNumber);\n    }\n    if (payload.reportType !== undefined) {\n      normalizedPayload.reportType = String(payload.reportType);\n    }\n    if (payload.reportingPeriod !== undefined) {\n      normalizedPayload.reportingPeriod = String(payload.reportingPeriod);\n    }\n    if (payload.reportDate !== undefined) {\n      normalizedPayload.reportDate = String(payload.reportDate);\n    }\n    if (payload.submittedDate !== undefined) {\n      normalizedPayload.submittedDate =\n        payload.submittedDate === null || payload.submittedDate === \"\"\n          ? null\n          : String(payload.submittedDate);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.fileUrl !== undefined) {\n      normalizedPayload.fileUrl =\n        payload.fileUrl === null || payload.fileUrl === \"\"\n          ? null\n          : String(payload.fileUrl);\n    }\n    if (payload.data !== undefined) {\n      normalizedPayload.data = payload.data;\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateComplianceReport(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/ComplianceReport/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Contract/ContractModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbContract, hrm_tb_contracts } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst signedByEmployee = alias(hrm_tb_employees, \"signed_by_employee\");\n\nexport interface ContractRow {\n  id: string;\n  contractNumber: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  contractType: string;\n  startDate: string;\n  endDate?: string | null;\n  baseSalary: number;\n  currency?: string | null;\n  workingHours?: number | null;\n  probationPeriod?: number | null;\n  probationEndDate?: string | null;\n  status: string;\n  documentUrl?: string | null;\n  signedDate?: string | null;\n  signedBy?: string | null;\n  signedByEmployee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  notes?: string | null;\n  metadata?: unknown;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface ContractInput {\n  contractNumber: string;\n  employeeId: string;\n  contractType: string;\n  startDate: string;\n  endDate?: string | null;\n  baseSalary: number;\n  currency?: string | null;\n  workingHours?: number | null;\n  probationPeriod?: number | null;\n  probationEndDate?: string | null;\n  status?: string;\n  documentUrl?: string | null;\n  signedDate?: string | null;\n  signedBy?: string | null;\n  notes?: string | null;\n  metadata?: unknown;\n  isActive?: boolean;\n}\n\nexport default class ContractModel extends BaseModel<typeof hrm_tb_contracts> {\n  constructor() {\n    super(hrm_tb_contracts);\n  }\n\n  getContractById = async (id: string): Promise<ContractRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        contractNumber: this.table.contractNumber,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        contractType: this.table.contractType,\n        startDate: this.table.startDate,\n        endDate: this.table.endDate,\n        baseSalary: this.table.baseSalary,\n        currency: this.table.currency,\n        workingHours: this.table.workingHours,\n        probationPeriod: this.table.probationPeriod,\n        probationEndDate: this.table.probationEndDate,\n        status: this.table.status,\n        documentUrl: this.table.documentUrl,\n        signedDate: this.table.signedDate,\n        signedBy: this.table.signedBy,\n        signedByCode: signedByEmployee.employeeCode,\n        signedByFullName: signedByEmployee.fullName,\n        notes: this.table.notes,\n        metadata: this.table.metadata,\n        isActive: this.table.isActive,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .leftJoin(signedByEmployee, eq(this.table.signedBy, signedByEmployee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      contractNumber: row.contractNumber,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      contractType: row.contractType,\n      startDate: row.startDate,\n      endDate: row.endDate ?? undefined,\n      baseSalary: row.baseSalary,\n      currency: row.currency ?? undefined,\n      workingHours: row.workingHours ?? undefined,\n      probationPeriod: row.probationPeriod ?? undefined,\n      probationEndDate: row.probationEndDate ?? undefined,\n      status: row.status,\n      documentUrl: row.documentUrl ?? undefined,\n      signedDate: row.signedDate ?? undefined,\n      signedBy: row.signedBy ?? undefined,\n      signedByEmployee: row.signedBy\n        ? {\n            id: row.signedBy,\n            employeeCode: row.signedByCode ?? undefined,\n            fullName: row.signedByFullName ?? undefined,\n          }\n        : null,\n      notes: row.notes ?? undefined,\n      metadata: row.metadata,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<ContractRow | null> => {\n    return this.getContractById(params.id);\n  };\n\n  createContract = async (payload: ContractInput): Promise<ContractRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbContract = {\n      contractNumber: payload.contractNumber,\n      employeeId: payload.employeeId,\n      contractType: payload.contractType,\n      startDate: payload.startDate,\n      endDate: payload.endDate ?? null,\n      baseSalary: payload.baseSalary,\n      currency: payload.currency ?? \"VND\",\n      workingHours: payload.workingHours ?? 40,\n      probationPeriod: payload.probationPeriod ?? null,\n      probationEndDate: payload.probationEndDate ?? null,\n      status: payload.status ?? \"active\",\n      documentUrl: payload.documentUrl ?? null,\n      signedDate: payload.signedDate ?? null,\n      signedBy: payload.signedBy ?? null,\n      notes: payload.notes ?? null,\n      metadata: payload.metadata ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create contract\");\n    }\n\n    const row = await this.getContractById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load contract after creation\");\n    }\n\n    return row;\n  };\n\n  updateContract = async (\n    id: string,\n    payload: Partial<ContractInput>,\n  ): Promise<ContractRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.contractNumber !== undefined)\n      updateData.contractNumber = payload.contractNumber;\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.contractType !== undefined)\n      updateData.contractType = payload.contractType;\n    if (payload.startDate !== undefined)\n      updateData.startDate = payload.startDate;\n    if (payload.endDate !== undefined)\n      updateData.endDate = payload.endDate ?? null;\n    if (payload.baseSalary !== undefined)\n      updateData.baseSalary = payload.baseSalary;\n    if (payload.currency !== undefined)\n      updateData.currency = payload.currency ?? null;\n    if (payload.workingHours !== undefined)\n      updateData.workingHours = payload.workingHours ?? null;\n    if (payload.probationPeriod !== undefined)\n      updateData.probationPeriod = payload.probationPeriod ?? null;\n    if (payload.probationEndDate !== undefined)\n      updateData.probationEndDate = payload.probationEndDate ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.documentUrl !== undefined)\n      updateData.documentUrl = payload.documentUrl ?? null;\n    if (payload.signedDate !== undefined)\n      updateData.signedDate = payload.signedDate ?? null;\n    if (payload.signedBy !== undefined)\n      updateData.signedBy = payload.signedBy ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n    if (payload.metadata !== undefined)\n      updateData.metadata = payload.metadata ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getContractById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<ContractInput> = {};\n\n    if (payload.contractNumber !== undefined) {\n      normalizedPayload.contractNumber = String(payload.contractNumber);\n    }\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.contractType !== undefined) {\n      normalizedPayload.contractType = String(payload.contractType);\n    }\n    if (payload.startDate !== undefined) {\n      normalizedPayload.startDate = String(payload.startDate);\n    }\n    if (payload.endDate !== undefined) {\n      normalizedPayload.endDate =\n        payload.endDate === null || payload.endDate === \"\"\n          ? null\n          : String(payload.endDate);\n    }\n    if (payload.baseSalary !== undefined) {\n      normalizedPayload.baseSalary = Number(payload.baseSalary);\n    }\n    if (payload.currency !== undefined) {\n      normalizedPayload.currency =\n        payload.currency === null || payload.currency === \"\"\n          ? null\n          : String(payload.currency);\n    }\n    if (payload.workingHours !== undefined) {\n      normalizedPayload.workingHours =\n        payload.workingHours === null || payload.workingHours === \"\"\n          ? null\n          : Number(payload.workingHours);\n    }\n    if (payload.probationPeriod !== undefined) {\n      normalizedPayload.probationPeriod =\n        payload.probationPeriod === null || payload.probationPeriod === \"\"\n          ? null\n          : Number(payload.probationPeriod);\n    }\n    if (payload.probationEndDate !== undefined) {\n      normalizedPayload.probationEndDate =\n        payload.probationEndDate === null || payload.probationEndDate === \"\"\n          ? null\n          : String(payload.probationEndDate);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.documentUrl !== undefined) {\n      normalizedPayload.documentUrl =\n        payload.documentUrl === null || payload.documentUrl === \"\"\n          ? null\n          : String(payload.documentUrl);\n    }\n    if (payload.signedDate !== undefined) {\n      normalizedPayload.signedDate =\n        payload.signedDate === null || payload.signedDate === \"\"\n          ? null\n          : String(payload.signedDate);\n    }\n    if (payload.signedBy !== undefined) {\n      normalizedPayload.signedBy =\n        payload.signedBy === null || payload.signedBy === \"\"\n          ? null\n          : String(payload.signedBy);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n    if (payload.metadata !== undefined) {\n      normalizedPayload.metadata = payload.metadata;\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateContract(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Contract/ContractViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_contracts } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface ContractRow {\n  id: string;\n  contractNumber: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  contractType: string;\n  startDate: string;\n  endDate?: string | null;\n  baseSalary: number;\n  status: string;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass ContractViewListModel extends BaseViewListModel<\n  typeof hrm_tb_contracts,\n  ContractRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_contracts.id, sort: true }],\n      [\n        \"contractNumber\",\n        { column: hrm_tb_contracts.contractNumber, sort: true },\n      ],\n      [\"employeeId\", { column: hrm_tb_contracts.employeeId, sort: true }],\n      [\"contractType\", { column: hrm_tb_contracts.contractType, sort: true }],\n      [\"startDate\", { column: hrm_tb_contracts.startDate, sort: true }],\n      [\"endDate\", { column: hrm_tb_contracts.endDate, sort: true }],\n      [\"baseSalary\", { column: hrm_tb_contracts.baseSalary, sort: true }],\n      [\"status\", { column: hrm_tb_contracts.status, sort: true }],\n      [\"isActive\", { column: hrm_tb_contracts.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_contracts.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_contracts.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_contracts });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"contractNumber\",\n        (text: string) => ilike(hrm_tb_contracts.contractNumber, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): ContractRow => ({\n    id: row.id,\n    contractNumber: row.contractNumber,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    contractType: row.contractType,\n    startDate: row.startDate,\n    endDate: row.endDate ?? undefined,\n    baseSalary: row.baseSalary,\n    status: row.status,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<ContractRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(employee, eq(this.table.employeeId, employee.id)),\n    );\n  };\n}\n\nexport default ContractViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Contract/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Course/CourseModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbCourse, hrm_tb_courses } from \"../../schemas\";\n\nexport interface CourseRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  category?: string | null;\n  duration?: number | null;\n  format?: string | null;\n  instructor?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface CourseInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  category?: string | null;\n  duration?: number | null;\n  format?: string | null;\n  instructor?: string | null;\n  isActive?: boolean;\n}\n\nexport default class CourseModel extends BaseModel<typeof hrm_tb_courses> {\n  constructor() {\n    super(hrm_tb_courses);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getCourseById = async (id: string): Promise<CourseRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      category: row.category ?? undefined,\n      duration: row.duration ?? undefined,\n      format: row.format ?? undefined,\n      instructor: row.instructor ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<CourseRow | null> => {\n    return this.getCourseById(params.id);\n  };\n\n  createCourse = async (payload: CourseInput): Promise<CourseRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbCourse = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      category: payload.category ?? null,\n      duration: payload.duration ?? null,\n      format: payload.format ?? null,\n      instructor: payload.instructor ?? null,\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create course\");\n\n    const course = await this.getCourseById(created.id);\n\n    if (!course) throw new Error(\"Failed to load course after creation\");\n\n    return course;\n  };\n\n  updateCourse = async (\n    id: string,\n    payload: Partial<CourseInput>,\n  ): Promise<CourseRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.category !== undefined)\n      updateData.category = payload.category ?? null;\n    if (payload.duration !== undefined)\n      updateData.duration = payload.duration ?? null;\n    if (payload.format !== undefined)\n      updateData.format = payload.format ?? null;\n    if (payload.instructor !== undefined)\n      updateData.instructor = payload.instructor ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getCourseById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<CourseInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.category !== undefined) {\n      normalizedPayload.category =\n        payload.category === null || payload.category === \"\"\n          ? null\n          : String(payload.category);\n    }\n    if (payload.duration !== undefined) {\n      normalizedPayload.duration =\n        payload.duration === null || payload.duration === \"\"\n          ? null\n          : Number(payload.duration);\n    }\n    if (payload.format !== undefined) {\n      normalizedPayload.format =\n        payload.format === null || payload.format === \"\"\n          ? null\n          : String(payload.format);\n    }\n    if (payload.instructor !== undefined) {\n      normalizedPayload.instructor =\n        payload.instructor === null || payload.instructor === \"\"\n          ? null\n          : String(payload.instructor);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateCourse(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Course/CourseViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_courses } from \"../../schemas\";\n\nexport interface CourseRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  category?: string | null;\n  duration?: number | null;\n  format?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass CourseViewListModel extends BaseViewListModel<\n  typeof hrm_tb_courses,\n  CourseRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_courses.id, sort: true }],\n      [\"code\", { column: hrm_tb_courses.code, sort: true }],\n      [\"name\", { column: hrm_tb_courses.name, sort: true }],\n      [\"category\", { column: hrm_tb_courses.category, sort: true }],\n      [\"duration\", { column: hrm_tb_courses.duration, sort: true }],\n      [\"isActive\", { column: hrm_tb_courses.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_courses.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_courses.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_courses });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_courses.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_courses.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): CourseRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    category: row.category ?? undefined,\n    duration: row.duration ?? undefined,\n    format: row.format ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<CourseRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default CourseViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Course/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Department/DepartmentDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_departments } from \"../../schemas\";\n\nexport interface DepartmentDropdownRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  isActive?: boolean;\n}\n\nclass DepartmentDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_departments,\n  DepartmentDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_departments.id, sort: true }],\n      [\"code\", { column: hrm_tb_departments.code, sort: true }],\n      [\"name\", { column: hrm_tb_departments.name, sort: true }],\n      [\"isActive\", { column: hrm_tb_departments.isActive, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_departments });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_departments.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_departments.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): DepartmentDropdownRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    isActive: row.isActive ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<DepartmentDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default DepartmentDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Department/DepartmentModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbDepartment, hrm_tb_departments } from \"../../schemas\";\n\nconst parentDepartment = alias(hrm_tb_departments, \"parent_department\");\n\nexport interface DepartmentRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  level?: number;\n  isActive?: boolean;\n  parent?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  managerId?: string | null;\n  locationId?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface DepartmentInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  parentId?: string | null;\n  level?: number | null;\n  managerId?: string | null;\n  locationId?: string | null;\n  isActive?: boolean;\n}\n\nexport default class DepartmentModel extends BaseModel<\n  typeof hrm_tb_departments\n> {\n  constructor() {\n    super(hrm_tb_departments);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getDepartmentById = async (id: string): Promise<DepartmentRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        code: this.table.code,\n        name: this.table.name,\n        description: this.table.description,\n        level: this.table.level,\n        isActive: this.table.isActive,\n        parentId: this.table.parentId,\n        parentName: parentDepartment.name,\n        managerId: this.table.managerId,\n        locationId: this.table.locationId,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(parentDepartment, eq(this.table.parentId, parentDepartment.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      level: row.level ?? undefined,\n      isActive: row.isActive ?? undefined,\n      parent: row.parentId\n        ? {\n            id: row.parentId,\n            name: row.parentName ?? undefined,\n          }\n        : null,\n      managerId: row.managerId ?? undefined,\n      locationId: row.locationId ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<DepartmentRow | null> => {\n    return this.getDepartmentById(params.id);\n  };\n\n  createDepartment = async (\n    payload: DepartmentInput,\n  ): Promise<DepartmentRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbDepartment = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      parentId: payload.parentId ?? null,\n      managerId: payload.managerId ?? null,\n      locationId: payload.locationId ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    if (payload.level !== undefined && payload.level !== null) {\n      insertData.level = payload.level;\n    }\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create department\");\n    }\n\n    const row = await this.getDepartmentById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load department after creation\");\n    }\n\n    return row;\n  };\n\n  updateDepartment = async (\n    id: string,\n    payload: Partial<DepartmentInput>,\n  ): Promise<DepartmentRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.parentId !== undefined)\n      updateData.parentId = payload.parentId ?? null;\n    if (payload.level !== undefined) {\n      if (payload.level !== null) {\n        updateData.level = payload.level;\n      }\n    }\n    if (payload.managerId !== undefined)\n      updateData.managerId = payload.managerId ?? null;\n    if (payload.locationId !== undefined)\n      updateData.locationId = payload.locationId ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getDepartmentById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<DepartmentInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.parentId !== undefined) {\n      normalizedPayload.parentId =\n        payload.parentId === null || payload.parentId === \"\"\n          ? null\n          : String(payload.parentId);\n    }\n    if (payload.level !== undefined) {\n      normalizedPayload.level =\n        payload.level === null || payload.level === \"\"\n          ? null\n          : Number(payload.level);\n    }\n    if (payload.managerId !== undefined) {\n      normalizedPayload.managerId =\n        payload.managerId === null || payload.managerId === \"\"\n          ? null\n          : String(payload.managerId);\n    }\n    if (payload.locationId !== undefined) {\n      normalizedPayload.locationId =\n        payload.locationId === null || payload.locationId === \"\"\n          ? null\n          : String(payload.locationId);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateDepartment(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Department/DepartmentViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_departments } from \"../../schemas\";\n\nconst parentDepartment = alias(hrm_tb_departments, \"parent_department\");\n\nexport interface DepartmentRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  level?: number;\n  isActive?: boolean;\n  parent?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  managerId?: string | null;\n  locationId?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass DepartmentViewListModel extends BaseViewListModel<\n  typeof hrm_tb_departments,\n  DepartmentRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_departments.id, sort: true }],\n      [\"code\", { column: hrm_tb_departments.code, sort: true }],\n      [\"name\", { column: hrm_tb_departments.name, sort: true }],\n      [\"description\", { column: hrm_tb_departments.description, sort: false }],\n      [\"level\", { column: hrm_tb_departments.level, sort: true }],\n      [\"isActive\", { column: hrm_tb_departments.isActive, sort: true }],\n      [\"parentId\", { column: hrm_tb_departments.parentId, sort: true }],\n      [\"managerId\", { column: hrm_tb_departments.managerId, sort: true }],\n      [\"locationId\", { column: hrm_tb_departments.locationId, sort: true }],\n      [\"createdAt\", { column: hrm_tb_departments.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_departments.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_departments });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_departments.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_departments.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): DepartmentRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    description: row.description,\n    level: row.level ?? undefined,\n    isActive: row.isActive ?? undefined,\n    parent: row.parentId\n      ? {\n          id: row.parentId,\n          name: row.parentName ?? undefined,\n        }\n      : null,\n    managerId: row.managerId ?? undefined,\n    locationId: row.locationId ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<DepartmentRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(\n        parentDepartment,\n        eq(this.table.parentId, parentDepartment.id),\n      ),\n    );\n  };\n}\n\nexport default DepartmentViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Department/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Document/DocumentModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbDocument, hrm_tb_documents } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface DocumentRow {\n  id: string;\n  documentNumber?: string | null;\n  documentType: string;\n  title?: unknown;\n  description?: unknown;\n  employeeId?: string | null;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  fileUrl: string;\n  fileSize?: number | null;\n  mimeType?: string | null;\n  signedDate?: number | null;\n  expiryDate?: number | null;\n  isDigitalSignature?: boolean;\n  metadata?: unknown;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface DocumentInput {\n  documentNumber?: string | null;\n  documentType: string;\n  title: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  employeeId?: string | null;\n  fileUrl: string;\n  fileSize?: number | null;\n  mimeType?: string | null;\n  signedDate?: string | null;\n  expiryDate?: string | null;\n  isDigitalSignature?: boolean;\n  metadata?: unknown;\n  isActive?: boolean;\n}\n\nexport default class DocumentModel extends BaseModel<typeof hrm_tb_documents> {\n  constructor() {\n    super(hrm_tb_documents);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getDocumentById = async (id: string): Promise<DocumentRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        documentNumber: this.table.documentNumber,\n        documentType: this.table.documentType,\n        title: this.table.title,\n        description: this.table.description,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        fileUrl: this.table.fileUrl,\n        fileSize: this.table.fileSize,\n        mimeType: this.table.mimeType,\n        signedDate: this.table.signedDate,\n        expiryDate: this.table.expiryDate,\n        isDigitalSignature: this.table.isDigitalSignature,\n        metadata: this.table.metadata,\n        isActive: this.table.isActive,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      documentNumber: row.documentNumber ?? undefined,\n      documentType: row.documentType,\n      title: row.title,\n      description: row.description,\n      employeeId: row.employeeId ?? undefined,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      fileUrl: row.fileUrl,\n      fileSize: row.fileSize ?? undefined,\n      mimeType: row.mimeType ?? undefined,\n      signedDate: row.signedDate?.getTime(),\n      expiryDate: row.expiryDate?.getTime(),\n      isDigitalSignature: row.isDigitalSignature ?? undefined,\n      metadata: row.metadata,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<DocumentRow | null> => {\n    return this.getDocumentById(params.id);\n  };\n\n  createDocument = async (payload: DocumentInput): Promise<DocumentRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbDocument = {\n      documentNumber: payload.documentNumber ?? null,\n      documentType: payload.documentType,\n      title: payload.title,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      employeeId: payload.employeeId ?? null,\n      fileUrl: payload.fileUrl,\n      fileSize: payload.fileSize ?? null,\n      mimeType: payload.mimeType ?? null,\n      signedDate: payload.signedDate ? new Date(payload.signedDate) : null,\n      expiryDate: payload.expiryDate ? new Date(payload.expiryDate) : null,\n      isDigitalSignature: payload.isDigitalSignature ?? false,\n      metadata: payload.metadata ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create document\");\n    }\n\n    const row = await this.getDocumentById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load document after creation\");\n    }\n\n    return row;\n  };\n\n  updateDocument = async (\n    id: string,\n    payload: Partial<DocumentInput>,\n  ): Promise<DocumentRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.documentNumber !== undefined)\n      updateData.documentNumber = payload.documentNumber ?? null;\n    if (payload.documentType !== undefined)\n      updateData.documentType = payload.documentType;\n    if (payload.title !== undefined) updateData.title = payload.title;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId ?? null;\n    if (payload.fileUrl !== undefined) updateData.fileUrl = payload.fileUrl;\n    if (payload.fileSize !== undefined)\n      updateData.fileSize = payload.fileSize ?? null;\n    if (payload.mimeType !== undefined)\n      updateData.mimeType = payload.mimeType ?? null;\n    if (payload.signedDate !== undefined)\n      updateData.signedDate = payload.signedDate\n        ? new Date(payload.signedDate)\n        : null;\n    if (payload.expiryDate !== undefined)\n      updateData.expiryDate = payload.expiryDate\n        ? new Date(payload.expiryDate)\n        : null;\n    if (payload.isDigitalSignature !== undefined)\n      updateData.isDigitalSignature = payload.isDigitalSignature;\n    if (payload.metadata !== undefined)\n      updateData.metadata = payload.metadata ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getDocumentById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<DocumentInput> = {};\n\n    if (payload.documentNumber !== undefined) {\n      normalizedPayload.documentNumber =\n        payload.documentNumber === null || payload.documentNumber === \"\"\n          ? null\n          : String(payload.documentNumber);\n    }\n    if (payload.documentType !== undefined) {\n      normalizedPayload.documentType = String(payload.documentType);\n    }\n    if (payload.title !== undefined) {\n      normalizedPayload.title = this.normalizeLocaleInput(payload.title) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId =\n        payload.employeeId === null || payload.employeeId === \"\"\n          ? null\n          : String(payload.employeeId);\n    }\n    if (payload.fileUrl !== undefined) {\n      normalizedPayload.fileUrl = String(payload.fileUrl);\n    }\n    if (payload.fileSize !== undefined) {\n      normalizedPayload.fileSize =\n        payload.fileSize === null || payload.fileSize === \"\"\n          ? null\n          : Number(payload.fileSize);\n    }\n    if (payload.mimeType !== undefined) {\n      normalizedPayload.mimeType =\n        payload.mimeType === null || payload.mimeType === \"\"\n          ? null\n          : String(payload.mimeType);\n    }\n    if (payload.signedDate !== undefined) {\n      normalizedPayload.signedDate =\n        payload.signedDate === null || payload.signedDate === \"\"\n          ? null\n          : String(payload.signedDate);\n    }\n    if (payload.expiryDate !== undefined) {\n      normalizedPayload.expiryDate =\n        payload.expiryDate === null || payload.expiryDate === \"\"\n          ? null\n          : String(payload.expiryDate);\n    }\n    if (payload.isDigitalSignature !== undefined) {\n      normalizedPayload.isDigitalSignature = Boolean(\n        payload.isDigitalSignature,\n      );\n    }\n    if (payload.metadata !== undefined) {\n      normalizedPayload.metadata = payload.metadata;\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateDocument(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Document/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Employee/EmployeeDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_employees } from \"../../schemas\";\n\nexport interface EmployeeDropdownRow {\n  id: string;\n  employeeCode: string;\n  fullName?: unknown;\n  isActive?: boolean;\n}\n\nclass EmployeeDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_employees,\n  EmployeeDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_employees.id, sort: true }],\n      [\"employeeCode\", { column: hrm_tb_employees.employeeCode, sort: true }],\n      [\"fullName\", { column: hrm_tb_employees.fullName, sort: true }],\n      [\"isActive\", { column: hrm_tb_employees.isActive, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_employees });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"employeeCode\",\n        (text: string) => ilike(hrm_tb_employees.employeeCode, text),\n      ],\n      [\"fullName\", (text: string) => ilike(hrm_tb_employees.fullName, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): EmployeeDropdownRow => ({\n    id: row.id,\n    employeeCode: row.employeeCode,\n    fullName: row.fullName,\n    isActive: row.isActive ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<EmployeeDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default EmployeeDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Employee/EmployeeModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbEmployee, hrm_tb_employees } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\nimport { hrm_tb_positions } from \"../../schemas/hrm.position\";\n\nconst department = alias(hrm_tb_departments, \"department\");\nconst position = alias(hrm_tb_positions, \"position\");\nconst manager = alias(hrm_tb_employees, \"manager\");\n\nexport interface EmployeeRow {\n  id: string;\n  employeeCode: string;\n  firstName?: string | null;\n  lastName?: string | null;\n  fullName?: unknown;\n  email?: string | null;\n  phone?: string | null;\n  dateOfBirth?: string | null;\n  gender?: string | null;\n  nationalId?: string | null;\n  taxId?: string | null;\n  address?: unknown;\n  positionId: string;\n  position?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  managerId?: string | null;\n  manager?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  employmentStatus: string;\n  employmentType?: string | null;\n  hireDate: string;\n  probationEndDate?: string | null;\n  baseSalary?: number | null;\n  currency?: string | null;\n  locationId?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface EmployeeInput {\n  employeeCode: string;\n  firstName?: string | null;\n  lastName?: string | null;\n  fullName: LocaleDataType<string>;\n  email?: string | null;\n  phone?: string | null;\n  dateOfBirth?: string | null;\n  gender?: string | null;\n  nationalId?: string | null;\n  taxId?: string | null;\n  address?: unknown;\n  positionId: string;\n  departmentId: string;\n  managerId?: string | null;\n  employmentStatus?: string;\n  employmentType?: string | null;\n  hireDate: string;\n  probationEndDate?: string | null;\n  baseSalary?: number | null;\n  currency?: string | null;\n  locationId?: string | null;\n  isActive?: boolean;\n}\n\nexport default class EmployeeModel extends BaseModel<typeof hrm_tb_employees> {\n  constructor() {\n    super(hrm_tb_employees);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getEmployeeById = async (id: string): Promise<EmployeeRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeCode: this.table.employeeCode,\n        firstName: this.table.firstName,\n        lastName: this.table.lastName,\n        fullName: this.table.fullName,\n        email: this.table.email,\n        phone: this.table.phone,\n        dateOfBirth: this.table.dateOfBirth,\n        gender: this.table.gender,\n        nationalId: this.table.nationalId,\n        taxId: this.table.taxId,\n        address: this.table.address,\n        positionId: this.table.positionId,\n        positionName: position.name,\n        departmentId: this.table.departmentId,\n        departmentName: department.name,\n        managerId: this.table.managerId,\n        managerCode: manager.employeeCode,\n        managerFullName: manager.fullName,\n        employmentStatus: this.table.employmentStatus,\n        employmentType: this.table.employmentType,\n        hireDate: this.table.hireDate,\n        probationEndDate: this.table.probationEndDate,\n        baseSalary: this.table.baseSalary,\n        currency: this.table.currency,\n        locationId: this.table.locationId,\n        isActive: this.table.isActive,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(position, eq(this.table.positionId, position.id))\n      .leftJoin(department, eq(this.table.departmentId, department.id))\n      .leftJoin(manager, eq(this.table.managerId, manager.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      employeeCode: row.employeeCode,\n      firstName: row.firstName ?? undefined,\n      lastName: row.lastName ?? undefined,\n      fullName: row.fullName,\n      email: row.email ?? undefined,\n      phone: row.phone ?? undefined,\n      dateOfBirth: row.dateOfBirth ?? undefined,\n      gender: row.gender ?? undefined,\n      nationalId: row.nationalId ?? undefined,\n      taxId: row.taxId ?? undefined,\n      address: row.address,\n      positionId: row.positionId,\n      position: row.positionId\n        ? {\n            id: row.positionId,\n            name: row.positionName ?? undefined,\n          }\n        : null,\n      departmentId: row.departmentId,\n      department: row.departmentId\n        ? {\n            id: row.departmentId,\n            name: row.departmentName ?? undefined,\n          }\n        : null,\n      managerId: row.managerId ?? undefined,\n      manager: row.managerId\n        ? {\n            id: row.managerId,\n            employeeCode: row.managerCode ?? undefined,\n            fullName: row.managerFullName ?? undefined,\n          }\n        : null,\n      employmentStatus: row.employmentStatus,\n      employmentType: row.employmentType ?? undefined,\n      hireDate: row.hireDate,\n      probationEndDate: row.probationEndDate ?? undefined,\n      baseSalary: row.baseSalary ?? undefined,\n      currency: row.currency ?? undefined,\n      locationId: row.locationId ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<EmployeeRow | null> => {\n    return this.getEmployeeById(params.id);\n  };\n\n  createEmployee = async (payload: EmployeeInput): Promise<EmployeeRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbEmployee = {\n      employeeCode: payload.employeeCode,\n      firstName: payload.firstName ?? null,\n      lastName: payload.lastName ?? null,\n      fullName: payload.fullName,\n      email: payload.email ?? null,\n      phone: payload.phone ?? null,\n      dateOfBirth: payload.dateOfBirth ?? null,\n      gender: payload.gender ?? null,\n      nationalId: payload.nationalId ?? null,\n      taxId: payload.taxId ?? null,\n      address: payload.address ?? null,\n      positionId: payload.positionId,\n      departmentId: payload.departmentId,\n      managerId: payload.managerId ?? null,\n      employmentStatus: payload.employmentStatus ?? \"active\",\n      employmentType: payload.employmentType ?? null,\n      hireDate: payload.hireDate,\n      probationEndDate: payload.probationEndDate ?? null,\n      baseSalary: payload.baseSalary ?? null,\n      currency: payload.currency ?? \"VND\",\n      locationId: payload.locationId ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create employee\");\n    }\n\n    const row = await this.getEmployeeById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load employee after creation\");\n    }\n\n    return row;\n  };\n\n  updateEmployee = async (\n    id: string,\n    payload: Partial<EmployeeInput>,\n  ): Promise<EmployeeRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeCode !== undefined)\n      updateData.employeeCode = payload.employeeCode;\n    if (payload.firstName !== undefined)\n      updateData.firstName = payload.firstName ?? null;\n    if (payload.lastName !== undefined)\n      updateData.lastName = payload.lastName ?? null;\n    if (payload.fullName !== undefined) updateData.fullName = payload.fullName;\n    if (payload.email !== undefined) updateData.email = payload.email ?? null;\n    if (payload.phone !== undefined) updateData.phone = payload.phone ?? null;\n    if (payload.dateOfBirth !== undefined)\n      updateData.dateOfBirth = payload.dateOfBirth ?? null;\n    if (payload.gender !== undefined)\n      updateData.gender = payload.gender ?? null;\n    if (payload.nationalId !== undefined)\n      updateData.nationalId = payload.nationalId ?? null;\n    if (payload.taxId !== undefined) updateData.taxId = payload.taxId ?? null;\n    if (payload.address !== undefined)\n      updateData.address = payload.address ?? null;\n    if (payload.positionId !== undefined)\n      updateData.positionId = payload.positionId;\n    if (payload.departmentId !== undefined)\n      updateData.departmentId = payload.departmentId;\n    if (payload.managerId !== undefined)\n      updateData.managerId = payload.managerId ?? null;\n    if (payload.employmentStatus !== undefined)\n      updateData.employmentStatus = payload.employmentStatus;\n    if (payload.employmentType !== undefined)\n      updateData.employmentType = payload.employmentType ?? null;\n    if (payload.hireDate !== undefined) updateData.hireDate = payload.hireDate;\n    if (payload.probationEndDate !== undefined)\n      updateData.probationEndDate = payload.probationEndDate ?? null;\n    if (payload.baseSalary !== undefined)\n      updateData.baseSalary = payload.baseSalary ?? null;\n    if (payload.currency !== undefined)\n      updateData.currency = payload.currency ?? null;\n    if (payload.locationId !== undefined)\n      updateData.locationId = payload.locationId ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getEmployeeById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<EmployeeInput> = {};\n\n    if (payload.employeeCode !== undefined) {\n      normalizedPayload.employeeCode = String(payload.employeeCode);\n    }\n    if (payload.firstName !== undefined) {\n      normalizedPayload.firstName =\n        payload.firstName === null || payload.firstName === \"\"\n          ? null\n          : String(payload.firstName);\n    }\n    if (payload.lastName !== undefined) {\n      normalizedPayload.lastName =\n        payload.lastName === null || payload.lastName === \"\"\n          ? null\n          : String(payload.lastName);\n    }\n    if (payload.fullName !== undefined) {\n      normalizedPayload.fullName = this.normalizeLocaleInput(\n        payload.fullName,\n      ) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.email !== undefined) {\n      normalizedPayload.email =\n        payload.email === null || payload.email === \"\"\n          ? null\n          : String(payload.email);\n    }\n    if (payload.phone !== undefined) {\n      normalizedPayload.phone =\n        payload.phone === null || payload.phone === \"\"\n          ? null\n          : String(payload.phone);\n    }\n    if (payload.dateOfBirth !== undefined) {\n      normalizedPayload.dateOfBirth =\n        payload.dateOfBirth === null || payload.dateOfBirth === \"\"\n          ? null\n          : String(payload.dateOfBirth);\n    }\n    if (payload.gender !== undefined) {\n      normalizedPayload.gender =\n        payload.gender === null || payload.gender === \"\"\n          ? null\n          : String(payload.gender);\n    }\n    if (payload.nationalId !== undefined) {\n      normalizedPayload.nationalId =\n        payload.nationalId === null || payload.nationalId === \"\"\n          ? null\n          : String(payload.nationalId);\n    }\n    if (payload.taxId !== undefined) {\n      normalizedPayload.taxId =\n        payload.taxId === null || payload.taxId === \"\"\n          ? null\n          : String(payload.taxId);\n    }\n    if (payload.address !== undefined) {\n      normalizedPayload.address = payload.address;\n    }\n    if (payload.positionId !== undefined) {\n      normalizedPayload.positionId = String(payload.positionId);\n    }\n    if (payload.departmentId !== undefined) {\n      normalizedPayload.departmentId = String(payload.departmentId);\n    }\n    if (payload.managerId !== undefined) {\n      normalizedPayload.managerId =\n        payload.managerId === null || payload.managerId === \"\"\n          ? null\n          : String(payload.managerId);\n    }\n    if (payload.employmentStatus !== undefined) {\n      normalizedPayload.employmentStatus = String(payload.employmentStatus);\n    }\n    if (payload.employmentType !== undefined) {\n      normalizedPayload.employmentType =\n        payload.employmentType === null || payload.employmentType === \"\"\n          ? null\n          : String(payload.employmentType);\n    }\n    if (payload.hireDate !== undefined) {\n      normalizedPayload.hireDate = String(payload.hireDate);\n    }\n    if (payload.probationEndDate !== undefined) {\n      normalizedPayload.probationEndDate =\n        payload.probationEndDate === null || payload.probationEndDate === \"\"\n          ? null\n          : String(payload.probationEndDate);\n    }\n    if (payload.baseSalary !== undefined) {\n      normalizedPayload.baseSalary =\n        payload.baseSalary === null || payload.baseSalary === \"\"\n          ? null\n          : Number(payload.baseSalary);\n    }\n    if (payload.currency !== undefined) {\n      normalizedPayload.currency =\n        payload.currency === null || payload.currency === \"\"\n          ? null\n          : String(payload.currency);\n    }\n    if (payload.locationId !== undefined) {\n      normalizedPayload.locationId =\n        payload.locationId === null || payload.locationId === \"\"\n          ? null\n          : String(payload.locationId);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateEmployee(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Employee/EmployeeViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_employees } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\nimport { hrm_tb_positions } from \"../../schemas/hrm.position\";\n\nconst department = alias(hrm_tb_departments, \"department\");\nconst position = alias(hrm_tb_positions, \"position\");\n\nexport interface EmployeeRow {\n  id: string;\n  employeeCode: string;\n  fullName?: unknown;\n  email?: string | null;\n  phone?: string | null;\n  positionId: string;\n  position?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  employmentStatus: string;\n  hireDate: string;\n  baseSalary?: number | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass EmployeeViewListModel extends BaseViewListModel<\n  typeof hrm_tb_employees,\n  EmployeeRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_employees.id, sort: true }],\n      [\"employeeCode\", { column: hrm_tb_employees.employeeCode, sort: true }],\n      [\"fullName\", { column: hrm_tb_employees.fullName, sort: true }],\n      [\"email\", { column: hrm_tb_employees.email, sort: true }],\n      [\"phone\", { column: hrm_tb_employees.phone, sort: true }],\n      [\"positionId\", { column: hrm_tb_employees.positionId, sort: true }],\n      [\"departmentId\", { column: hrm_tb_employees.departmentId, sort: true }],\n      [\n        \"employmentStatus\",\n        { column: hrm_tb_employees.employmentStatus, sort: true },\n      ],\n      [\"hireDate\", { column: hrm_tb_employees.hireDate, sort: true }],\n      [\"baseSalary\", { column: hrm_tb_employees.baseSalary, sort: true }],\n      [\"isActive\", { column: hrm_tb_employees.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_employees.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_employees.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_employees });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"employeeCode\",\n        (text: string) => ilike(hrm_tb_employees.employeeCode, text),\n      ],\n      [\"fullName\", (text: string) => ilike(hrm_tb_employees.fullName, text)],\n      [\"email\", (text: string) => ilike(hrm_tb_employees.email, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): EmployeeRow => ({\n    id: row.id,\n    employeeCode: row.employeeCode,\n    fullName: row.fullName,\n    email: row.email ?? undefined,\n    phone: row.phone ?? undefined,\n    positionId: row.positionId,\n    position: row.positionId\n      ? {\n          id: row.positionId,\n          name: row.positionName ?? undefined,\n        }\n      : null,\n    departmentId: row.departmentId,\n    department: row.departmentId\n      ? {\n          id: row.departmentId,\n          name: row.departmentName ?? undefined,\n        }\n      : null,\n    employmentStatus: row.employmentStatus,\n    hireDate: row.hireDate,\n    baseSalary: row.baseSalary ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<EmployeeRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(position, eq(this.table.positionId, position.id))\n        .leftJoin(department, eq(this.table.departmentId, department.id)),\n    );\n  };\n}\n\nexport default EmployeeViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Employee/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Goal/GoalModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbGoal, hrm_tb_goals } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface GoalRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  goalType: string;\n  title?: unknown;\n  description?: unknown;\n  targetValue?: number | null;\n  currentValue: number;\n  unit?: string | null;\n  period: string;\n  startDate: string;\n  endDate: string;\n  status: string;\n  progress: number;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface GoalInput {\n  employeeId: string;\n  goalType: string;\n  title: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  targetValue?: number | null;\n  currentValue?: number;\n  unit?: string | null;\n  period: string;\n  startDate: string;\n  endDate: string;\n  status?: string;\n}\n\nexport default class GoalModel extends BaseModel<typeof hrm_tb_goals> {\n  constructor() {\n    super(hrm_tb_goals);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getGoalById = async (id: string): Promise<GoalRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        goalType: this.table.goalType,\n        title: this.table.title,\n        description: this.table.description,\n        targetValue: this.table.targetValue,\n        currentValue: this.table.currentValue,\n        unit: this.table.unit,\n        period: this.table.period,\n        startDate: this.table.startDate,\n        endDate: this.table.endDate,\n        status: this.table.status,\n        progress: this.table.progress,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    // Calculate progress if target value exists\n    const currentValue = row.currentValue ?? 0;\n    const progress =\n      row.targetValue && row.targetValue > 0\n        ? Math.min(100, Math.round((currentValue / row.targetValue) * 100))\n        : 0;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      goalType: row.goalType,\n      title: row.title,\n      description: row.description,\n      targetValue: row.targetValue ?? undefined,\n      currentValue: row.currentValue ?? 0,\n      unit: row.unit ?? undefined,\n      period: row.period,\n      startDate: row.startDate,\n      endDate: row.endDate,\n      status: row.status,\n      progress: progress,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<GoalRow | null> => {\n    return this.getGoalById(params.id);\n  };\n\n  createGoal = async (payload: GoalInput): Promise<GoalRow> => {\n    const now = new Date();\n    const progress =\n      payload.targetValue && payload.targetValue > 0\n        ? Math.min(\n            100,\n            Math.round(\n              ((payload.currentValue ?? 0) / payload.targetValue) * 100,\n            ),\n          )\n        : 0;\n\n    const insertData: NewHrmTbGoal = {\n      employeeId: payload.employeeId,\n      goalType: payload.goalType,\n      title: payload.title,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      targetValue: payload.targetValue ?? null,\n      currentValue: payload.currentValue ?? 0,\n      unit: payload.unit ?? null,\n      period: payload.period,\n      startDate: payload.startDate,\n      endDate: payload.endDate,\n      status: payload.status ?? \"active\",\n      progress: progress,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create goal\");\n\n    const goal = await this.getGoalById(created.id);\n\n    if (!goal) throw new Error(\"Failed to load goal after creation\");\n\n    return goal;\n  };\n\n  updateGoal = async (\n    id: string,\n    payload: Partial<GoalInput>,\n  ): Promise<GoalRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.goalType !== undefined) updateData.goalType = payload.goalType;\n    if (payload.title !== undefined) updateData.title = payload.title;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.targetValue !== undefined)\n      updateData.targetValue = payload.targetValue ?? null;\n    if (payload.currentValue !== undefined)\n      updateData.currentValue = payload.currentValue;\n    if (payload.unit !== undefined) updateData.unit = payload.unit ?? null;\n    if (payload.period !== undefined) updateData.period = payload.period;\n    if (payload.startDate !== undefined)\n      updateData.startDate = payload.startDate;\n    if (payload.endDate !== undefined) updateData.endDate = payload.endDate;\n    if (payload.status !== undefined) updateData.status = payload.status;\n\n    // Recalculate progress if target or current value changed\n    if (\n      payload.targetValue !== undefined ||\n      payload.currentValue !== undefined\n    ) {\n      const existing = await this.getGoalById(id);\n\n      if (existing) {\n        const targetValue = updateData.targetValue ?? existing.targetValue;\n        const currentValue = updateData.currentValue ?? existing.currentValue;\n\n        if (targetValue && targetValue > 0) {\n          updateData.progress = Math.min(\n            100,\n            Math.round((currentValue / targetValue) * 100),\n          );\n        } else {\n          updateData.progress = 0;\n        }\n      }\n    }\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getGoalById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<GoalInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.goalType !== undefined) {\n      normalizedPayload.goalType = String(payload.goalType);\n    }\n    if (payload.title !== undefined) {\n      normalizedPayload.title = this.normalizeLocaleInput(payload.title) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.targetValue !== undefined) {\n      normalizedPayload.targetValue =\n        payload.targetValue === null || payload.targetValue === \"\"\n          ? null\n          : Number(payload.targetValue);\n    }\n    if (payload.currentValue !== undefined) {\n      normalizedPayload.currentValue = Number(payload.currentValue);\n    }\n    if (payload.unit !== undefined) {\n      normalizedPayload.unit =\n        payload.unit === null || payload.unit === \"\"\n          ? null\n          : String(payload.unit);\n    }\n    if (payload.period !== undefined) {\n      normalizedPayload.period = String(payload.period);\n    }\n    if (payload.startDate !== undefined) {\n      normalizedPayload.startDate = String(payload.startDate);\n    }\n    if (payload.endDate !== undefined) {\n      normalizedPayload.endDate = String(payload.endDate);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n\n    return this.updateGoal(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Goal/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/JobRequisition/JobRequisitionDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_job_requisitions } from \"../../schemas\";\n\nexport interface JobRequisitionDropdownRow {\n  id: string;\n  requisitionNumber: string;\n  title?: unknown;\n  isActive?: boolean;\n}\n\nclass JobRequisitionDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_job_requisitions,\n  JobRequisitionDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_job_requisitions.id, sort: true }],\n      [\n        \"requisitionNumber\",\n        { column: hrm_tb_job_requisitions.requisitionNumber, sort: true },\n      ],\n      [\"title\", { column: hrm_tb_job_requisitions.title, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_job_requisitions });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"requisitionNumber\",\n        (text: string) =>\n          ilike(hrm_tb_job_requisitions.requisitionNumber, text),\n      ],\n      [\"title\", (text: string) => ilike(hrm_tb_job_requisitions.title, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): JobRequisitionDropdownRow => ({\n    id: row.id,\n    requisitionNumber: row.requisitionNumber,\n    title: row.title,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<JobRequisitionDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default JobRequisitionDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/JobRequisition/JobRequisitionModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbJobRequisition, hrm_tb_job_requisitions } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\nimport { hrm_tb_positions } from \"../../schemas/hrm.position\";\n\nconst department = alias(hrm_tb_departments, \"department\");\nconst position = alias(hrm_tb_positions, \"position\");\n\nexport interface JobRequisitionRow {\n  id: string;\n  requisitionNumber: string;\n  title?: unknown;\n  description?: unknown;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  positionId: string;\n  position?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  numberOfOpenings: number;\n  priority?: string | null;\n  employmentType?: string | null;\n  minSalary?: number | null;\n  maxSalary?: number | null;\n  currency?: string | null;\n  requirements?: string | null;\n  status: string;\n  openedDate?: string | null;\n  closedDate?: string | null;\n  hiringManagerId?: string | null;\n  recruiterId?: string | null;\n  notes?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface JobRequisitionInput {\n  requisitionNumber: string;\n  title: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  departmentId: string;\n  positionId: string;\n  numberOfOpenings?: number;\n  priority?: string | null;\n  employmentType?: string | null;\n  minSalary?: number | null;\n  maxSalary?: number | null;\n  currency?: string | null;\n  requirements?: string | null;\n  status?: string;\n  openedDate?: string | null;\n  closedDate?: string | null;\n  hiringManagerId?: string | null;\n  recruiterId?: string | null;\n  notes?: string | null;\n}\n\nexport default class JobRequisitionModel extends BaseModel<\n  typeof hrm_tb_job_requisitions\n> {\n  constructor() {\n    super(hrm_tb_job_requisitions);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getJobRequisitionById = async (\n    id: string,\n  ): Promise<JobRequisitionRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        requisitionNumber: this.table.requisitionNumber,\n        title: this.table.title,\n        description: this.table.description,\n        departmentId: this.table.departmentId,\n        departmentName: department.name,\n        positionId: this.table.positionId,\n        positionName: position.name,\n        numberOfOpenings: this.table.numberOfOpenings,\n        priority: this.table.priority,\n        employmentType: this.table.employmentType,\n        minSalary: this.table.minSalary,\n        maxSalary: this.table.maxSalary,\n        currency: this.table.currency,\n        requirements: this.table.requirements,\n        status: this.table.status,\n        openedDate: this.table.openedDate,\n        closedDate: this.table.closedDate,\n        hiringManagerId: this.table.hiringManagerId,\n        recruiterId: this.table.recruiterId,\n        notes: this.table.notes,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(department, eq(this.table.departmentId, department.id))\n      .leftJoin(position, eq(this.table.positionId, position.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      requisitionNumber: row.requisitionNumber,\n      title: row.title,\n      description: row.description,\n      departmentId: row.departmentId,\n      department: row.departmentId\n        ? {\n            id: row.departmentId,\n            name: row.departmentName ?? undefined,\n          }\n        : null,\n      positionId: row.positionId,\n      position: row.positionId\n        ? {\n            id: row.positionId,\n            name: row.positionName ?? undefined,\n          }\n        : null,\n      numberOfOpenings: row.numberOfOpenings,\n      priority: row.priority ?? undefined,\n      employmentType: row.employmentType ?? undefined,\n      minSalary: row.minSalary ?? undefined,\n      maxSalary: row.maxSalary ?? undefined,\n      currency: row.currency ?? undefined,\n      requirements: row.requirements ?? undefined,\n      status: row.status,\n      openedDate: row.openedDate ?? undefined,\n      closedDate: row.closedDate ?? undefined,\n      hiringManagerId: row.hiringManagerId ?? undefined,\n      recruiterId: row.recruiterId ?? undefined,\n      notes: row.notes ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<JobRequisitionRow | null> => {\n    return this.getJobRequisitionById(params.id);\n  };\n\n  createJobRequisition = async (\n    payload: JobRequisitionInput,\n  ): Promise<JobRequisitionRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbJobRequisition = {\n      requisitionNumber: payload.requisitionNumber,\n      title: payload.title,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      departmentId: payload.departmentId,\n      positionId: payload.positionId,\n      numberOfOpenings: payload.numberOfOpenings ?? 1,\n      priority: payload.priority ?? \"normal\",\n      employmentType: payload.employmentType ?? null,\n      minSalary: payload.minSalary ?? null,\n      maxSalary: payload.maxSalary ?? null,\n      currency: payload.currency ?? \"VND\",\n      requirements: payload.requirements ?? null,\n      status: payload.status ?? \"draft\",\n      openedDate: payload.openedDate ?? null,\n      closedDate: payload.closedDate ?? null,\n      hiringManagerId: payload.hiringManagerId ?? null,\n      recruiterId: payload.recruiterId ?? null,\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create job requisition\");\n\n    const requisition = await this.getJobRequisitionById(created.id);\n\n    if (!requisition)\n      throw new Error(\"Failed to load job requisition after creation\");\n\n    return requisition;\n  };\n\n  updateJobRequisition = async (\n    id: string,\n    payload: Partial<JobRequisitionInput>,\n  ): Promise<JobRequisitionRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.requisitionNumber !== undefined)\n      updateData.requisitionNumber = payload.requisitionNumber;\n    if (payload.title !== undefined) updateData.title = payload.title;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.departmentId !== undefined)\n      updateData.departmentId = payload.departmentId;\n    if (payload.positionId !== undefined)\n      updateData.positionId = payload.positionId;\n    if (payload.numberOfOpenings !== undefined)\n      updateData.numberOfOpenings = payload.numberOfOpenings;\n    if (payload.priority !== undefined)\n      updateData.priority = payload.priority ?? null;\n    if (payload.employmentType !== undefined)\n      updateData.employmentType = payload.employmentType ?? null;\n    if (payload.minSalary !== undefined)\n      updateData.minSalary = payload.minSalary ?? null;\n    if (payload.maxSalary !== undefined)\n      updateData.maxSalary = payload.maxSalary ?? null;\n    if (payload.currency !== undefined)\n      updateData.currency = payload.currency ?? null;\n    if (payload.requirements !== undefined)\n      updateData.requirements = payload.requirements ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.openedDate !== undefined)\n      updateData.openedDate = payload.openedDate ?? null;\n    if (payload.closedDate !== undefined)\n      updateData.closedDate = payload.closedDate ?? null;\n    if (payload.hiringManagerId !== undefined)\n      updateData.hiringManagerId = payload.hiringManagerId ?? null;\n    if (payload.recruiterId !== undefined)\n      updateData.recruiterId = payload.recruiterId ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getJobRequisitionById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<JobRequisitionInput> = {};\n\n    if (payload.requisitionNumber !== undefined) {\n      normalizedPayload.requisitionNumber = String(payload.requisitionNumber);\n    }\n    if (payload.title !== undefined) {\n      normalizedPayload.title = this.normalizeLocaleInput(payload.title) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.departmentId !== undefined) {\n      normalizedPayload.departmentId = String(payload.departmentId);\n    }\n    if (payload.positionId !== undefined) {\n      normalizedPayload.positionId = String(payload.positionId);\n    }\n    if (payload.numberOfOpenings !== undefined) {\n      normalizedPayload.numberOfOpenings = Number(payload.numberOfOpenings);\n    }\n    if (payload.priority !== undefined) {\n      normalizedPayload.priority =\n        payload.priority === null || payload.priority === \"\"\n          ? null\n          : String(payload.priority);\n    }\n    if (payload.employmentType !== undefined) {\n      normalizedPayload.employmentType =\n        payload.employmentType === null || payload.employmentType === \"\"\n          ? null\n          : String(payload.employmentType);\n    }\n    if (payload.minSalary !== undefined) {\n      normalizedPayload.minSalary =\n        payload.minSalary === null || payload.minSalary === \"\"\n          ? null\n          : Number(payload.minSalary);\n    }\n    if (payload.maxSalary !== undefined) {\n      normalizedPayload.maxSalary =\n        payload.maxSalary === null || payload.maxSalary === \"\"\n          ? null\n          : Number(payload.maxSalary);\n    }\n    if (payload.currency !== undefined) {\n      normalizedPayload.currency =\n        payload.currency === null || payload.currency === \"\"\n          ? null\n          : String(payload.currency);\n    }\n    if (payload.requirements !== undefined) {\n      normalizedPayload.requirements =\n        payload.requirements === null || payload.requirements === \"\"\n          ? null\n          : String(payload.requirements);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.openedDate !== undefined) {\n      normalizedPayload.openedDate =\n        payload.openedDate === null || payload.openedDate === \"\"\n          ? null\n          : String(payload.openedDate);\n    }\n    if (payload.closedDate !== undefined) {\n      normalizedPayload.closedDate =\n        payload.closedDate === null || payload.closedDate === \"\"\n          ? null\n          : String(payload.closedDate);\n    }\n    if (payload.hiringManagerId !== undefined) {\n      normalizedPayload.hiringManagerId =\n        payload.hiringManagerId === null || payload.hiringManagerId === \"\"\n          ? null\n          : String(payload.hiringManagerId);\n    }\n    if (payload.recruiterId !== undefined) {\n      normalizedPayload.recruiterId =\n        payload.recruiterId === null || payload.recruiterId === \"\"\n          ? null\n          : String(payload.recruiterId);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateJobRequisition(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/JobRequisition/JobRequisitionViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_job_requisitions } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\nimport { hrm_tb_positions } from \"../../schemas/hrm.position\";\n\nconst department = alias(hrm_tb_departments, \"department\");\nconst position = alias(hrm_tb_positions, \"position\");\n\nexport interface JobRequisitionRow {\n  id: string;\n  requisitionNumber: string;\n  title?: unknown;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  positionId: string;\n  position?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  numberOfOpenings: number;\n  priority?: string | null;\n  status: string;\n  openedDate?: string | null;\n  closedDate?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass JobRequisitionViewListModel extends BaseViewListModel<\n  typeof hrm_tb_job_requisitions,\n  JobRequisitionRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_job_requisitions.id, sort: true }],\n      [\n        \"requisitionNumber\",\n        { column: hrm_tb_job_requisitions.requisitionNumber, sort: true },\n      ],\n      [\"title\", { column: hrm_tb_job_requisitions.title, sort: true }],\n      [\n        \"departmentId\",\n        { column: hrm_tb_job_requisitions.departmentId, sort: true },\n      ],\n      [\n        \"positionId\",\n        { column: hrm_tb_job_requisitions.positionId, sort: true },\n      ],\n      [\n        \"numberOfOpenings\",\n        { column: hrm_tb_job_requisitions.numberOfOpenings, sort: true },\n      ],\n      [\"priority\", { column: hrm_tb_job_requisitions.priority, sort: true }],\n      [\"status\", { column: hrm_tb_job_requisitions.status, sort: true }],\n      [\n        \"openedDate\",\n        { column: hrm_tb_job_requisitions.openedDate, sort: true },\n      ],\n      [\"createdAt\", { column: hrm_tb_job_requisitions.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_job_requisitions.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_job_requisitions });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"requisitionNumber\",\n        (text: string) =>\n          ilike(hrm_tb_job_requisitions.requisitionNumber, text),\n      ],\n      [\"title\", (text: string) => ilike(hrm_tb_job_requisitions.title, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): JobRequisitionRow => ({\n    id: row.id,\n    requisitionNumber: row.requisitionNumber,\n    title: row.title,\n    departmentId: row.departmentId,\n    department: row.departmentId\n      ? {\n          id: row.departmentId,\n          name: row.departmentName ?? undefined,\n        }\n      : null,\n    positionId: row.positionId,\n    position: row.positionId\n      ? {\n          id: row.positionId,\n          name: row.positionName ?? undefined,\n        }\n      : null,\n    numberOfOpenings: row.numberOfOpenings,\n    priority: row.priority ?? undefined,\n    status: row.status,\n    openedDate: row.openedDate ?? undefined,\n    closedDate: row.closedDate ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<JobRequisitionRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(department, eq(this.table.departmentId, department.id))\n        .leftJoin(position, eq(this.table.positionId, position.id)),\n    );\n  };\n}\n\nexport default JobRequisitionViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/JobRequisition/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveRequest/LeaveRequestModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbLeaveRequest, hrm_tb_leave_requests } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_leave_types } from \"../../schemas/hrm.leave-type\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst leaveType = alias(hrm_tb_leave_types, \"leave_type\");\n\nexport interface LeaveRequestRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  leaveTypeId: string;\n  leaveType?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  startDate: string;\n  endDate: string;\n  days: number;\n  reason?: string | null;\n  status: string;\n  workflowInstanceId?: string | null;\n  approvedBy?: string | null;\n  approvedAt?: number | null;\n  rejectedBy?: string | null;\n  rejectedAt?: number | null;\n  rejectionReason?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface LeaveRequestInput {\n  employeeId: string;\n  leaveTypeId: string;\n  startDate: string;\n  endDate: string;\n  days: number;\n  reason?: string | null;\n  status?: string;\n  workflowInstanceId?: string | null;\n}\n\nexport default class LeaveRequestModel extends BaseModel<\n  typeof hrm_tb_leave_requests\n> {\n  constructor() {\n    super(hrm_tb_leave_requests);\n  }\n\n  getLeaveRequestById = async (id: string): Promise<LeaveRequestRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        leaveTypeId: this.table.leaveTypeId,\n        leaveTypeName: leaveType.name,\n        startDate: this.table.startDate,\n        endDate: this.table.endDate,\n        days: this.table.days,\n        reason: this.table.reason,\n        status: this.table.status,\n        workflowInstanceId: this.table.workflowInstanceId,\n        approvedBy: this.table.approvedBy,\n        approvedAt: this.table.approvedAt,\n        rejectedBy: this.table.rejectedBy,\n        rejectedAt: this.table.rejectedAt,\n        rejectionReason: this.table.rejectionReason,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .leftJoin(leaveType, eq(this.table.leaveTypeId, leaveType.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      leaveTypeId: row.leaveTypeId,\n      leaveType: row.leaveTypeId\n        ? {\n            id: row.leaveTypeId,\n            name: row.leaveTypeName ?? undefined,\n          }\n        : null,\n      startDate: row.startDate,\n      endDate: row.endDate,\n      days: row.days,\n      reason: row.reason ?? undefined,\n      status: row.status,\n      workflowInstanceId: row.workflowInstanceId ?? undefined,\n      approvedBy: row.approvedBy ?? undefined,\n      approvedAt: row.approvedAt?.getTime(),\n      rejectedBy: row.rejectedBy ?? undefined,\n      rejectedAt: row.rejectedAt?.getTime(),\n      rejectionReason: row.rejectionReason ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<LeaveRequestRow | null> => {\n    return this.getLeaveRequestById(params.id);\n  };\n\n  createLeaveRequest = async (\n    payload: LeaveRequestInput,\n  ): Promise<LeaveRequestRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbLeaveRequest = {\n      employeeId: payload.employeeId,\n      leaveTypeId: payload.leaveTypeId,\n      startDate: payload.startDate,\n      endDate: payload.endDate,\n      days: payload.days,\n      reason: payload.reason ?? null,\n      status: payload.status ?? \"pending\",\n      workflowInstanceId: payload.workflowInstanceId ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create leave request\");\n\n    const request = await this.getLeaveRequestById(created.id);\n\n    if (!request)\n      throw new Error(\"Failed to load leave request after creation\");\n\n    return request;\n  };\n\n  updateLeaveRequest = async (\n    id: string,\n    payload: Partial<LeaveRequestInput>,\n  ): Promise<LeaveRequestRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.leaveTypeId !== undefined)\n      updateData.leaveTypeId = payload.leaveTypeId;\n    if (payload.startDate !== undefined)\n      updateData.startDate = payload.startDate;\n    if (payload.endDate !== undefined) updateData.endDate = payload.endDate;\n    if (payload.days !== undefined) updateData.days = payload.days;\n    if (payload.reason !== undefined)\n      updateData.reason = payload.reason ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.workflowInstanceId !== undefined)\n      updateData.workflowInstanceId = payload.workflowInstanceId ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getLeaveRequestById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<LeaveRequestInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.leaveTypeId !== undefined) {\n      normalizedPayload.leaveTypeId = String(payload.leaveTypeId);\n    }\n    if (payload.startDate !== undefined) {\n      normalizedPayload.startDate = String(payload.startDate);\n    }\n    if (payload.endDate !== undefined) {\n      normalizedPayload.endDate = String(payload.endDate);\n    }\n    if (payload.days !== undefined) {\n      normalizedPayload.days = Number(payload.days);\n    }\n    if (payload.reason !== undefined) {\n      normalizedPayload.reason =\n        payload.reason === null || payload.reason === \"\"\n          ? null\n          : String(payload.reason);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.workflowInstanceId !== undefined) {\n      normalizedPayload.workflowInstanceId =\n        payload.workflowInstanceId === null || payload.workflowInstanceId === \"\"\n          ? null\n          : String(payload.workflowInstanceId);\n    }\n\n    return this.updateLeaveRequest(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveRequest/LeaveRequestViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_leave_requests } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_leave_types } from \"../../schemas/hrm.leave-type\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst leaveType = alias(hrm_tb_leave_types, \"leave_type\");\n\nexport interface LeaveRequestRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  leaveTypeId: string;\n  leaveType?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  startDate: string;\n  endDate: string;\n  days: number;\n  status: string;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass LeaveRequestViewListModel extends BaseViewListModel<\n  typeof hrm_tb_leave_requests,\n  LeaveRequestRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_leave_requests.id, sort: true }],\n      [\"employeeId\", { column: hrm_tb_leave_requests.employeeId, sort: true }],\n      [\n        \"leaveTypeId\",\n        { column: hrm_tb_leave_requests.leaveTypeId, sort: true },\n      ],\n      [\"startDate\", { column: hrm_tb_leave_requests.startDate, sort: true }],\n      [\"endDate\", { column: hrm_tb_leave_requests.endDate, sort: true }],\n      [\"days\", { column: hrm_tb_leave_requests.days, sort: true }],\n      [\"status\", { column: hrm_tb_leave_requests.status, sort: true }],\n      [\"createdAt\", { column: hrm_tb_leave_requests.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_leave_requests.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_leave_requests });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"employeeCode\", (text: string) => ilike(employee.employeeCode, text)],\n      [\"fullName\", (text: string) => ilike(employee.fullName, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): LeaveRequestRow => ({\n    id: row.id,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    leaveTypeId: row.leaveTypeId,\n    leaveType: row.leaveTypeId\n      ? {\n          id: row.leaveTypeId,\n          name: row.leaveTypeName ?? undefined,\n        }\n      : null,\n    startDate: row.startDate,\n    endDate: row.endDate,\n    days: row.days,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<LeaveRequestRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(employee, eq(this.table.employeeId, employee.id))\n        .leftJoin(leaveType, eq(this.table.leaveTypeId, leaveType.id)),\n    );\n  };\n}\n\nexport default LeaveRequestViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveRequest/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveType/LeaveTypeDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_leave_types } from \"../../schemas\";\n\nexport interface LeaveTypeDropdownRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  isActive?: boolean;\n}\n\nclass LeaveTypeDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_leave_types,\n  LeaveTypeDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_leave_types.id, sort: true }],\n      [\"code\", { column: hrm_tb_leave_types.code, sort: true }],\n      [\"name\", { column: hrm_tb_leave_types.name, sort: true }],\n      [\"isActive\", { column: hrm_tb_leave_types.isActive, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_leave_types });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_leave_types.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_leave_types.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): LeaveTypeDropdownRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    isActive: row.isActive ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<LeaveTypeDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default LeaveTypeDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveType/LeaveTypeModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbLeaveType, hrm_tb_leave_types } from \"../../schemas\";\n\nexport interface LeaveTypeRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  accrualType: string;\n  accrualRate?: number | null;\n  maxAccrual?: number | null;\n  carryForward?: boolean;\n  maxCarryForward?: number | null;\n  requiresApproval?: boolean;\n  isPaid?: boolean;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface LeaveTypeInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  accrualType: string;\n  accrualRate?: number | null;\n  maxAccrual?: number | null;\n  carryForward?: boolean;\n  maxCarryForward?: number | null;\n  requiresApproval?: boolean;\n  isPaid?: boolean;\n  isActive?: boolean;\n}\n\nexport default class LeaveTypeModel extends BaseModel<\n  typeof hrm_tb_leave_types\n> {\n  constructor() {\n    super(hrm_tb_leave_types);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getLeaveTypeById = async (id: string): Promise<LeaveTypeRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      accrualType: row.accrualType,\n      accrualRate: row.accrualRate ?? undefined,\n      maxAccrual: row.maxAccrual ?? undefined,\n      carryForward: row.carryForward ?? undefined,\n      maxCarryForward: row.maxCarryForward ?? undefined,\n      requiresApproval: row.requiresApproval ?? undefined,\n      isPaid: row.isPaid ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<LeaveTypeRow | null> => {\n    return this.getLeaveTypeById(params.id);\n  };\n\n  createLeaveType = async (payload: LeaveTypeInput): Promise<LeaveTypeRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbLeaveType = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      accrualType: payload.accrualType,\n      accrualRate: payload.accrualRate ?? null,\n      maxAccrual: payload.maxAccrual ?? null,\n      carryForward: payload.carryForward ?? false,\n      maxCarryForward: payload.maxCarryForward ?? null,\n      requiresApproval: payload.requiresApproval ?? true,\n      isPaid: payload.isPaid ?? true,\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create leave type\");\n\n    const leaveType = await this.getLeaveTypeById(created.id);\n\n    if (!leaveType) throw new Error(\"Failed to load leave type after creation\");\n\n    return leaveType;\n  };\n\n  updateLeaveType = async (\n    id: string,\n    payload: Partial<LeaveTypeInput>,\n  ): Promise<LeaveTypeRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.accrualType !== undefined)\n      updateData.accrualType = payload.accrualType;\n    if (payload.accrualRate !== undefined)\n      updateData.accrualRate = payload.accrualRate ?? null;\n    if (payload.maxAccrual !== undefined)\n      updateData.maxAccrual = payload.maxAccrual ?? null;\n    if (payload.carryForward !== undefined)\n      updateData.carryForward = payload.carryForward;\n    if (payload.maxCarryForward !== undefined)\n      updateData.maxCarryForward = payload.maxCarryForward ?? null;\n    if (payload.requiresApproval !== undefined)\n      updateData.requiresApproval = payload.requiresApproval;\n    if (payload.isPaid !== undefined) updateData.isPaid = payload.isPaid;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getLeaveTypeById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<LeaveTypeInput> = {};\n\n    if (payload.code !== undefined)\n      normalizedPayload.code = String(payload.code);\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.accrualType !== undefined) {\n      normalizedPayload.accrualType = String(payload.accrualType);\n    }\n    if (payload.accrualRate !== undefined) {\n      normalizedPayload.accrualRate =\n        payload.accrualRate === null || payload.accrualRate === \"\"\n          ? null\n          : Number(payload.accrualRate);\n    }\n    if (payload.maxAccrual !== undefined) {\n      normalizedPayload.maxAccrual =\n        payload.maxAccrual === null || payload.maxAccrual === \"\"\n          ? null\n          : Number(payload.maxAccrual);\n    }\n    if (payload.carryForward !== undefined) {\n      normalizedPayload.carryForward = Boolean(payload.carryForward);\n    }\n    if (payload.maxCarryForward !== undefined) {\n      normalizedPayload.maxCarryForward =\n        payload.maxCarryForward === null || payload.maxCarryForward === \"\"\n          ? null\n          : Number(payload.maxCarryForward);\n    }\n    if (payload.requiresApproval !== undefined) {\n      normalizedPayload.requiresApproval = Boolean(payload.requiresApproval);\n    }\n    if (payload.isPaid !== undefined) {\n      normalizedPayload.isPaid = Boolean(payload.isPaid);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateLeaveType(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveType/LeaveTypeViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_leave_types } from \"../../schemas\";\n\nexport interface LeaveTypeRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  accrualType: string;\n  accrualRate?: number | null;\n  maxAccrual?: number | null;\n  carryForward?: boolean;\n  requiresApproval?: boolean;\n  isPaid?: boolean;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass LeaveTypeViewListModel extends BaseViewListModel<\n  typeof hrm_tb_leave_types,\n  LeaveTypeRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_leave_types.id, sort: true }],\n      [\"code\", { column: hrm_tb_leave_types.code, sort: true }],\n      [\"name\", { column: hrm_tb_leave_types.name, sort: true }],\n      [\"accrualType\", { column: hrm_tb_leave_types.accrualType, sort: true }],\n      [\"accrualRate\", { column: hrm_tb_leave_types.accrualRate, sort: true }],\n      [\"isActive\", { column: hrm_tb_leave_types.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_leave_types.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_leave_types.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_leave_types });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_leave_types.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_leave_types.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): LeaveTypeRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    accrualType: row.accrualType,\n    accrualRate: row.accrualRate ?? undefined,\n    maxAccrual: row.maxAccrual ?? undefined,\n    carryForward: row.carryForward ?? undefined,\n    requiresApproval: row.requiresApproval ?? undefined,\n    isPaid: row.isPaid ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<LeaveTypeRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default LeaveTypeViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/LeaveType/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Notification/NotificationModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":44,"fix":{"range":[0,167],"text":"import { and, eq, sql } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,212],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, sql } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { and, eq, sql } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbNotification, hrm_tb_notifications } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface NotificationRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  type: string;\n  title?: unknown;\n  message?: unknown;\n  link?: string | null;\n  isRead: boolean;\n  readAt?: number | null;\n  metadata?: unknown;\n  createdAt: number;\n}\n\nexport interface NotificationInput {\n  employeeId: string;\n  type: string;\n  title: LocaleDataType<string>;\n  message: LocaleDataType<string>;\n  link?: string | null;\n  metadata?: unknown;\n}\n\nexport interface NotificationQuery {\n  employeeId: string;\n  isRead?: boolean;\n  type?: string;\n  limit?: number;\n  offset?: number;\n}\n\nexport default class NotificationModel extends BaseModel<\n  typeof hrm_tb_notifications\n> {\n  constructor() {\n    super(hrm_tb_notifications);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getNotificationById = async (id: string): Promise<NotificationRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        type: this.table.type,\n        title: this.table.title,\n        message: this.table.message,\n        link: this.table.link,\n        isRead: this.table.isRead,\n        readAt: this.table.readAt,\n        metadata: this.table.metadata,\n        createdAt: this.table.createdAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      type: row.type,\n      title: row.title,\n      message: row.message,\n      link: row.link ?? undefined,\n      isRead: row.isRead,\n      readAt: row.readAt?.getTime(),\n      metadata: row.metadata,\n      createdAt: row.createdAt.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<NotificationRow | null> => {\n    return this.getNotificationById(params.id);\n  };\n\n  createNotification = async (\n    payload: NotificationInput,\n  ): Promise<NotificationRow> => {\n    const insertData: NewHrmTbNotification = {\n      employeeId: payload.employeeId,\n      type: payload.type,\n      title: payload.title,\n      message: payload.message,\n      link: payload.link ?? null,\n      metadata: payload.metadata ?? null,\n      isRead: false,\n      createdAt: new Date(),\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create notification\");\n\n    const notification = await this.getNotificationById(created.id);\n\n    if (!notification)\n      throw new Error(\"Failed to load notification after creation\");\n\n    return notification;\n  };\n\n  queryNotifications = async (\n    query: NotificationQuery,\n  ): Promise<{ notifications: NotificationRow[]; total: number }> => {\n    const conditions = [eq(this.table.employeeId, query.employeeId)];\n\n    if (query.isRead !== undefined) {\n      conditions.push(eq(this.table.isRead, query.isRead));\n    }\n    if (query.type) {\n      conditions.push(eq(this.table.type, query.type));\n    }\n\n    const whereClause = and(...conditions);\n\n    const [notifications, totalResult] = await Promise.all([\n      this.db\n        .select({\n          id: this.table.id,\n          employeeId: this.table.employeeId,\n          employeeCode: employee.employeeCode,\n          employeeFullName: employee.fullName,\n          type: this.table.type,\n          title: this.table.title,\n          message: this.table.message,\n          link: this.table.link,\n          isRead: this.table.isRead,\n          readAt: this.table.readAt,\n          metadata: this.table.metadata,\n          createdAt: this.table.createdAt,\n        })\n        .from(this.table)\n        .leftJoin(employee, eq(this.table.employeeId, employee.id))\n        .where(whereClause)\n        .orderBy(this.table.createdAt)\n        .limit(query.limit ?? 50)\n        .offset(query.offset ?? 0),\n      this.db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(this.table)\n        .where(whereClause),\n    ]);\n\n    return {\n      notifications: notifications.map((row) => ({\n        id: row.id,\n        employeeId: row.employeeId,\n        employee: row.employeeId\n          ? {\n              id: row.employeeId,\n              employeeCode: row.employeeCode ?? undefined,\n              fullName: row.employeeFullName ?? undefined,\n            }\n          : null,\n        type: row.type,\n        title: row.title,\n        message: row.message,\n        link: row.link ?? undefined,\n        isRead: row.isRead,\n        readAt: row.readAt?.getTime(),\n        metadata: row.metadata,\n        createdAt: row.createdAt.getTime(),\n      })),\n      total: totalResult[0]?.count ?? 0,\n    };\n  };\n\n  markAsRead = async (id: string): Promise<NotificationRow | null> => {\n    await this.db\n      .update(this.table)\n      .set({\n        isRead: true,\n        readAt: new Date(),\n      })\n      .where(eq(this.table.id, id));\n\n    return this.getNotificationById(id);\n  };\n\n  markAllAsRead = async (employeeId: string): Promise<void> => {\n    await this.db\n      .update(this.table)\n      .set({\n        isRead: true,\n        readAt: new Date(),\n      })\n      .where(\n        and(\n          eq(this.table.employeeId, employeeId),\n          eq(this.table.isRead, false),\n        ),\n      );\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Notification/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Offboarding/OffboardingModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbOffboarding, hrm_tb_offboardings } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\n\nexport interface OffboardingRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  resignationDate: string;\n  lastWorkingDate: string;\n  reason?: string | null;\n  reasonDetails?: string | null;\n  exitInterviewDate?: string | null;\n  exitInterviewNotes?: string | null;\n  handoverNotes?: string | null;\n  assetsReturned?: unknown;\n  status: string;\n  completedDate?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface OffboardingInput {\n  employeeId: string;\n  resignationDate: string;\n  lastWorkingDate: string;\n  reason?: string | null;\n  reasonDetails?: string | null;\n  exitInterviewDate?: string | null;\n  exitInterviewNotes?: string | null;\n  handoverNotes?: string | null;\n  assetsReturned?: unknown;\n  status?: string;\n}\n\nexport default class OffboardingModel extends BaseModel<\n  typeof hrm_tb_offboardings\n> {\n  constructor() {\n    super(hrm_tb_offboardings);\n  }\n\n  getOffboardingById = async (id: string): Promise<OffboardingRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        resignationDate: this.table.resignationDate,\n        lastWorkingDate: this.table.lastWorkingDate,\n        reason: this.table.reason,\n        reasonDetails: this.table.reasonDetails,\n        exitInterviewDate: this.table.exitInterviewDate,\n        exitInterviewNotes: this.table.exitInterviewNotes,\n        handoverNotes: this.table.handoverNotes,\n        assetsReturned: this.table.assetsReturned,\n        status: this.table.status,\n        completedDate: this.table.completedDate,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      resignationDate: row.resignationDate,\n      lastWorkingDate: row.lastWorkingDate,\n      reason: row.reason ?? undefined,\n      reasonDetails: row.reasonDetails ?? undefined,\n      exitInterviewDate: row.exitInterviewDate ?? undefined,\n      exitInterviewNotes: row.exitInterviewNotes ?? undefined,\n      handoverNotes: row.handoverNotes ?? undefined,\n      assetsReturned: row.assetsReturned,\n      status: row.status,\n      completedDate: row.completedDate ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<OffboardingRow | null> => {\n    return this.getOffboardingById(params.id);\n  };\n\n  createOffboarding = async (\n    payload: OffboardingInput,\n  ): Promise<OffboardingRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbOffboarding = {\n      employeeId: payload.employeeId,\n      resignationDate: payload.resignationDate,\n      lastWorkingDate: payload.lastWorkingDate,\n      reason: payload.reason ?? null,\n      reasonDetails: payload.reasonDetails ?? null,\n      exitInterviewDate: payload.exitInterviewDate ?? null,\n      exitInterviewNotes: payload.exitInterviewNotes ?? null,\n      handoverNotes: payload.handoverNotes ?? null,\n      assetsReturned: payload.assetsReturned ?? null,\n      status: payload.status ?? \"initiated\",\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create offboarding\");\n\n    const offboarding = await this.getOffboardingById(created.id);\n\n    if (!offboarding)\n      throw new Error(\"Failed to load offboarding after creation\");\n\n    return offboarding;\n  };\n\n  updateOffboarding = async (\n    id: string,\n    payload: Partial<OffboardingInput>,\n  ): Promise<OffboardingRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.resignationDate !== undefined)\n      updateData.resignationDate = payload.resignationDate;\n    if (payload.lastWorkingDate !== undefined)\n      updateData.lastWorkingDate = payload.lastWorkingDate;\n    if (payload.reason !== undefined)\n      updateData.reason = payload.reason ?? null;\n    if (payload.reasonDetails !== undefined)\n      updateData.reasonDetails = payload.reasonDetails ?? null;\n    if (payload.exitInterviewDate !== undefined)\n      updateData.exitInterviewDate = payload.exitInterviewDate ?? null;\n    if (payload.exitInterviewNotes !== undefined)\n      updateData.exitInterviewNotes = payload.exitInterviewNotes ?? null;\n    if (payload.handoverNotes !== undefined)\n      updateData.handoverNotes = payload.handoverNotes ?? null;\n    if (payload.assetsReturned !== undefined)\n      updateData.assetsReturned = payload.assetsReturned ?? null;\n    if (payload.status !== undefined) {\n      updateData.status = payload.status;\n      if (payload.status === \"completed\") {\n        updateData.completedDate = new Date().toISOString().split(\"T\")[0];\n      }\n    }\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getOffboardingById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<OffboardingInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.resignationDate !== undefined) {\n      normalizedPayload.resignationDate = String(payload.resignationDate);\n    }\n    if (payload.lastWorkingDate !== undefined) {\n      normalizedPayload.lastWorkingDate = String(payload.lastWorkingDate);\n    }\n    if (payload.reason !== undefined) {\n      normalizedPayload.reason =\n        payload.reason === null || payload.reason === \"\"\n          ? null\n          : String(payload.reason);\n    }\n    if (payload.reasonDetails !== undefined) {\n      normalizedPayload.reasonDetails =\n        payload.reasonDetails === null || payload.reasonDetails === \"\"\n          ? null\n          : String(payload.reasonDetails);\n    }\n    if (payload.exitInterviewDate !== undefined) {\n      normalizedPayload.exitInterviewDate =\n        payload.exitInterviewDate === null || payload.exitInterviewDate === \"\"\n          ? null\n          : String(payload.exitInterviewDate);\n    }\n    if (payload.exitInterviewNotes !== undefined) {\n      normalizedPayload.exitInterviewNotes =\n        payload.exitInterviewNotes === null || payload.exitInterviewNotes === \"\"\n          ? null\n          : String(payload.exitInterviewNotes);\n    }\n    if (payload.handoverNotes !== undefined) {\n      normalizedPayload.handoverNotes =\n        payload.handoverNotes === null || payload.handoverNotes === \"\"\n          ? null\n          : String(payload.handoverNotes);\n    }\n    if (payload.assetsReturned !== undefined) {\n      normalizedPayload.assetsReturned = payload.assetsReturned;\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n\n    return this.updateOffboarding(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Offboarding/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Offer/OfferModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbOffer, hrm_tb_offers } from \"../../schemas\";\nimport { hrm_tb_candidates } from \"../../schemas/hrm.candidate\";\n\nconst candidate = alias(hrm_tb_candidates, \"candidate\");\n\nexport interface OfferRow {\n  id: string;\n  candidateId: string;\n  candidate?: {\n    id: string;\n    fullName?: unknown;\n  } | null;\n  offerNumber: string;\n  positionTitle?: unknown;\n  baseSalary: number;\n  currency?: string | null;\n  startDate: string;\n  employmentType?: string | null;\n  benefits?: unknown;\n  terms?: string | null;\n  status: string;\n  sentDate?: number | null;\n  expiryDate?: string | null;\n  acceptedDate?: number | null;\n  rejectedDate?: number | null;\n  rejectionReason?: string | null;\n  approvedBy?: string | null;\n  approvedAt?: number | null;\n  notes?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface OfferInput {\n  candidateId: string;\n  offerNumber: string;\n  positionTitle: LocaleDataType<string>;\n  baseSalary: number;\n  currency?: string | null;\n  startDate: string;\n  employmentType?: string | null;\n  benefits?: unknown;\n  terms?: string | null;\n  status?: string;\n  expiryDate?: string | null;\n  notes?: string | null;\n}\n\nexport default class OfferModel extends BaseModel<typeof hrm_tb_offers> {\n  constructor() {\n    super(hrm_tb_offers);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getOfferById = async (id: string): Promise<OfferRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        candidateId: this.table.candidateId,\n        candidateFullName: candidate.fullName,\n        offerNumber: this.table.offerNumber,\n        positionTitle: this.table.positionTitle,\n        baseSalary: this.table.baseSalary,\n        currency: this.table.currency,\n        startDate: this.table.startDate,\n        employmentType: this.table.employmentType,\n        benefits: this.table.benefits,\n        terms: this.table.terms,\n        status: this.table.status,\n        sentDate: this.table.sentDate,\n        expiryDate: this.table.expiryDate,\n        acceptedDate: this.table.acceptedDate,\n        rejectedDate: this.table.rejectedDate,\n        rejectionReason: this.table.rejectionReason,\n        approvedBy: this.table.approvedBy,\n        approvedAt: this.table.approvedAt,\n        notes: this.table.notes,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(candidate, eq(this.table.candidateId, candidate.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      candidateId: row.candidateId,\n      candidate: row.candidateId\n        ? {\n            id: row.candidateId,\n            fullName: row.candidateFullName ?? undefined,\n          }\n        : null,\n      offerNumber: row.offerNumber,\n      positionTitle: row.positionTitle,\n      baseSalary: row.baseSalary,\n      currency: row.currency ?? undefined,\n      startDate: row.startDate,\n      employmentType: row.employmentType ?? undefined,\n      benefits: row.benefits,\n      terms: row.terms ?? undefined,\n      status: row.status,\n      sentDate: row.sentDate?.getTime(),\n      expiryDate: row.expiryDate ?? undefined,\n      acceptedDate: row.acceptedDate?.getTime(),\n      rejectedDate: row.rejectedDate?.getTime(),\n      rejectionReason: row.rejectionReason ?? undefined,\n      approvedBy: row.approvedBy ?? undefined,\n      approvedAt: row.approvedAt?.getTime(),\n      notes: row.notes ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<OfferRow | null> => {\n    return this.getOfferById(params.id);\n  };\n\n  createOffer = async (payload: OfferInput): Promise<OfferRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbOffer = {\n      candidateId: payload.candidateId,\n      offerNumber: payload.offerNumber,\n      positionTitle: payload.positionTitle,\n      baseSalary: payload.baseSalary,\n      currency: payload.currency ?? \"VND\",\n      startDate: payload.startDate,\n      employmentType: payload.employmentType ?? null,\n      benefits: payload.benefits ?? null,\n      terms: payload.terms ?? null,\n      status: payload.status ?? \"draft\",\n      expiryDate: payload.expiryDate ?? null,\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create offer\");\n\n    const offer = await this.getOfferById(created.id);\n\n    if (!offer) throw new Error(\"Failed to load offer after creation\");\n\n    return offer;\n  };\n\n  updateOffer = async (\n    id: string,\n    payload: Partial<OfferInput>,\n  ): Promise<OfferRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.candidateId !== undefined)\n      updateData.candidateId = payload.candidateId;\n    if (payload.offerNumber !== undefined)\n      updateData.offerNumber = payload.offerNumber;\n    if (payload.positionTitle !== undefined)\n      updateData.positionTitle = payload.positionTitle;\n    if (payload.baseSalary !== undefined)\n      updateData.baseSalary = payload.baseSalary;\n    if (payload.currency !== undefined)\n      updateData.currency = payload.currency ?? null;\n    if (payload.startDate !== undefined)\n      updateData.startDate = payload.startDate;\n    if (payload.employmentType !== undefined)\n      updateData.employmentType = payload.employmentType ?? null;\n    if (payload.benefits !== undefined)\n      updateData.benefits = payload.benefits ?? null;\n    if (payload.terms !== undefined) updateData.terms = payload.terms ?? null;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.expiryDate !== undefined)\n      updateData.expiryDate = payload.expiryDate ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getOfferById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<OfferInput> = {};\n\n    if (payload.candidateId !== undefined) {\n      normalizedPayload.candidateId = String(payload.candidateId);\n    }\n    if (payload.offerNumber !== undefined) {\n      normalizedPayload.offerNumber = String(payload.offerNumber);\n    }\n    if (payload.positionTitle !== undefined) {\n      normalizedPayload.positionTitle = this.normalizeLocaleInput(\n        payload.positionTitle,\n      ) ?? { en: \"\" };\n    }\n    if (payload.baseSalary !== undefined) {\n      normalizedPayload.baseSalary = Number(payload.baseSalary);\n    }\n    if (payload.currency !== undefined) {\n      normalizedPayload.currency =\n        payload.currency === null || payload.currency === \"\"\n          ? null\n          : String(payload.currency);\n    }\n    if (payload.startDate !== undefined) {\n      normalizedPayload.startDate = String(payload.startDate);\n    }\n    if (payload.employmentType !== undefined) {\n      normalizedPayload.employmentType =\n        payload.employmentType === null || payload.employmentType === \"\"\n          ? null\n          : String(payload.employmentType);\n    }\n    if (payload.benefits !== undefined) {\n      normalizedPayload.benefits = payload.benefits;\n    }\n    if (payload.terms !== undefined) {\n      normalizedPayload.terms =\n        payload.terms === null || payload.terms === \"\"\n          ? null\n          : String(payload.terms);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.expiryDate !== undefined) {\n      normalizedPayload.expiryDate =\n        payload.expiryDate === null || payload.expiryDate === \"\"\n          ? null\n          : String(payload.expiryDate);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateOffer(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Offer/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/OnboardingChecklist/OnboardingChecklistModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport {\n  NewHrmTbOnboardingChecklist,\n  hrm_tb_onboarding_checklists,\n} from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst assignedEmployee = alias(hrm_tb_employees, \"assigned_employee\");\n\nexport interface OnboardingChecklistRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  taskName?: unknown;\n  taskDescription?: unknown;\n  category?: string | null;\n  assignedTo?: string | null;\n  assignedEmployee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  dueDate?: string | null;\n  completedDate?: string | null;\n  isCompleted: boolean;\n  notes?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface OnboardingChecklistInput {\n  employeeId: string;\n  taskName: LocaleDataType<string>;\n  taskDescription?: LocaleDataType<string> | null;\n  category?: string | null;\n  assignedTo?: string | null;\n  dueDate?: string | null;\n  isCompleted?: boolean;\n  notes?: string | null;\n}\n\nexport default class OnboardingChecklistModel extends BaseModel<\n  typeof hrm_tb_onboarding_checklists\n> {\n  constructor() {\n    super(hrm_tb_onboarding_checklists);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getOnboardingChecklistById = async (\n    id: string,\n  ): Promise<OnboardingChecklistRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        taskName: this.table.taskName,\n        taskDescription: this.table.taskDescription,\n        category: this.table.category,\n        assignedTo: this.table.assignedTo,\n        assignedEmployeeCode: assignedEmployee.employeeCode,\n        assignedEmployeeFullName: assignedEmployee.fullName,\n        dueDate: this.table.dueDate,\n        completedDate: this.table.completedDate,\n        isCompleted: this.table.isCompleted,\n        notes: this.table.notes,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .leftJoin(\n        assignedEmployee,\n        eq(this.table.assignedTo, assignedEmployee.id),\n      )\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      taskName: row.taskName,\n      taskDescription: row.taskDescription,\n      category: row.category ?? undefined,\n      assignedTo: row.assignedTo ?? undefined,\n      assignedEmployee: row.assignedTo\n        ? {\n            id: row.assignedTo,\n            employeeCode: row.assignedEmployeeCode ?? undefined,\n            fullName: row.assignedEmployeeFullName ?? undefined,\n          }\n        : null,\n      dueDate: row.dueDate ?? undefined,\n      completedDate: row.completedDate ?? undefined,\n      isCompleted: row.isCompleted,\n      notes: row.notes ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<OnboardingChecklistRow | null> => {\n    return this.getOnboardingChecklistById(params.id);\n  };\n\n  createOnboardingChecklist = async (\n    payload: OnboardingChecklistInput,\n  ): Promise<OnboardingChecklistRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbOnboardingChecklist = {\n      employeeId: payload.employeeId,\n      taskName: payload.taskName,\n      taskDescription: payload.taskDescription\n        ? typeof payload.taskDescription === \"string\"\n          ? payload.taskDescription\n          : JSON.stringify(payload.taskDescription)\n        : null,\n      category: payload.category ?? null,\n      assignedTo: payload.assignedTo ?? null,\n      dueDate: payload.dueDate ?? null,\n      isCompleted: payload.isCompleted ?? false,\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create onboarding checklist\");\n\n    const checklist = await this.getOnboardingChecklistById(created.id);\n\n    if (!checklist)\n      throw new Error(\"Failed to load onboarding checklist after creation\");\n\n    return checklist;\n  };\n\n  updateOnboardingChecklist = async (\n    id: string,\n    payload: Partial<OnboardingChecklistInput>,\n  ): Promise<OnboardingChecklistRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.taskName !== undefined) updateData.taskName = payload.taskName;\n    if (payload.taskDescription !== undefined)\n      updateData.taskDescription = payload.taskDescription\n        ? typeof payload.taskDescription === \"string\"\n          ? payload.taskDescription\n          : JSON.stringify(payload.taskDescription)\n        : null;\n    if (payload.category !== undefined)\n      updateData.category = payload.category ?? null;\n    if (payload.assignedTo !== undefined)\n      updateData.assignedTo = payload.assignedTo ?? null;\n    if (payload.dueDate !== undefined)\n      updateData.dueDate = payload.dueDate ?? null;\n    if (payload.isCompleted !== undefined) {\n      updateData.isCompleted = payload.isCompleted;\n      if (payload.isCompleted) {\n        updateData.completedDate = new Date().toISOString().split(\"T\")[0];\n      }\n    }\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getOnboardingChecklistById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<OnboardingChecklistInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.taskName !== undefined) {\n      normalizedPayload.taskName = this.normalizeLocaleInput(\n        payload.taskName,\n      ) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.taskDescription !== undefined) {\n      normalizedPayload.taskDescription = this.normalizeLocaleInput(\n        payload.taskDescription,\n      );\n    }\n    if (payload.category !== undefined) {\n      normalizedPayload.category =\n        payload.category === null || payload.category === \"\"\n          ? null\n          : String(payload.category);\n    }\n    if (payload.assignedTo !== undefined) {\n      normalizedPayload.assignedTo =\n        payload.assignedTo === null || payload.assignedTo === \"\"\n          ? null\n          : String(payload.assignedTo);\n    }\n    if (payload.dueDate !== undefined) {\n      normalizedPayload.dueDate =\n        payload.dueDate === null || payload.dueDate === \"\"\n          ? null\n          : String(payload.dueDate);\n    }\n    if (payload.isCompleted !== undefined) {\n      normalizedPayload.isCompleted = Boolean(payload.isCompleted);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateOnboardingChecklist(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/OnboardingChecklist/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Payroll/PayrollModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbPayroll, hrm_tb_payrolls } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_payrolls_period } from \"../../schemas/hrm.payroll-period\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst period = alias(hrm_tb_payrolls_period, \"period\");\n\nexport interface PayrollRow {\n  id: string;\n  payrollPeriodId: string;\n  payrollPeriod?: {\n    id: string;\n    code?: string;\n    name?: string | null;\n  } | null;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  baseSalary: number;\n  allowances?: Record<string, number>;\n  overtimePay: number;\n  bonuses: number;\n  otherEarnings: number;\n  grossSalary: number;\n  socialInsurance: number;\n  healthInsurance: number;\n  unemploymentInsurance: number;\n  personalIncomeTax: number;\n  otherDeductions?: Record<string, number>;\n  totalDeductions: number;\n  netSalary: number;\n  workingDays: number;\n  workingHours: number;\n  overtimeHours: number;\n  status: string;\n  notes?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface PayrollInput {\n  payrollPeriodId: string;\n  employeeId: string;\n  baseSalary: number;\n  allowances?: Record<string, number>;\n  overtimePay?: number;\n  bonuses?: number;\n  otherEarnings?: number;\n  socialInsurance?: number;\n  healthInsurance?: number;\n  unemploymentInsurance?: number;\n  personalIncomeTax?: number;\n  otherDeductions?: Record<string, number>;\n  workingDays?: number;\n  workingHours?: number;\n  overtimeHours?: number;\n  status?: string;\n  notes?: string | null;\n}\n\nexport default class PayrollModel extends BaseModel<typeof hrm_tb_payrolls> {\n  constructor() {\n    super(hrm_tb_payrolls);\n  }\n\n  getPayrollById = async (id: string): Promise<PayrollRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        payrollPeriodId: this.table.payrollPeriodId,\n        periodCode: period.code,\n        periodName: period.name,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        baseSalary: this.table.baseSalary,\n        allowances: this.table.allowances,\n        overtimePay: this.table.overtimePay,\n        bonuses: this.table.bonuses,\n        otherEarnings: this.table.otherEarnings,\n        grossSalary: this.table.grossSalary,\n        socialInsurance: this.table.socialInsurance,\n        healthInsurance: this.table.healthInsurance,\n        unemploymentInsurance: this.table.unemploymentInsurance,\n        personalIncomeTax: this.table.personalIncomeTax,\n        otherDeductions: this.table.otherDeductions,\n        totalDeductions: this.table.totalDeductions,\n        netSalary: this.table.netSalary,\n        workingDays: this.table.workingDays,\n        workingHours: this.table.workingHours,\n        overtimeHours: this.table.overtimeHours,\n        status: this.table.status,\n        notes: this.table.notes,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(period, eq(this.table.payrollPeriodId, period.id))\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      payrollPeriodId: row.payrollPeriodId,\n      payrollPeriod: row.payrollPeriodId\n        ? {\n            id: row.payrollPeriodId,\n            code: row.periodCode ?? undefined,\n            name: row.periodName ?? undefined,\n          }\n        : null,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      baseSalary: row.baseSalary,\n      allowances: (row.allowances as Record<string, number>) ?? undefined,\n      overtimePay: row.overtimePay ?? 0,\n      bonuses: row.bonuses ?? 0,\n      otherEarnings: row.otherEarnings ?? 0,\n      grossSalary: row.grossSalary,\n      socialInsurance: row.socialInsurance ?? 0,\n      healthInsurance: row.healthInsurance ?? 0,\n      unemploymentInsurance: row.unemploymentInsurance ?? 0,\n      personalIncomeTax: row.personalIncomeTax ?? 0,\n      otherDeductions:\n        (row.otherDeductions as Record<string, number>) ?? undefined,\n      totalDeductions: row.totalDeductions ?? 0,\n      netSalary: row.netSalary,\n      workingDays: row.workingDays ?? 0,\n      workingHours: row.workingHours ?? 0,\n      overtimeHours: row.overtimeHours ?? 0,\n      status: row.status,\n      notes: row.notes ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<PayrollRow | null> => {\n    return this.getPayrollById(params.id);\n  };\n\n  createPayroll = async (payload: PayrollInput): Promise<PayrollRow> => {\n    const now = new Date();\n\n    // Calculate totals\n    const allowancesTotal = payload.allowances\n      ? Object.values(payload.allowances).reduce((sum, val) => sum + val, 0)\n      : 0;\n    const otherDeductionsTotal = payload.otherDeductions\n      ? Object.values(payload.otherDeductions).reduce(\n          (sum, val) => sum + val,\n          0,\n        )\n      : 0;\n\n    const grossSalary =\n      payload.baseSalary +\n      allowancesTotal +\n      (payload.overtimePay ?? 0) +\n      (payload.bonuses ?? 0) +\n      (payload.otherEarnings ?? 0);\n\n    const totalDeductions =\n      (payload.socialInsurance ?? 0) +\n      (payload.healthInsurance ?? 0) +\n      (payload.unemploymentInsurance ?? 0) +\n      (payload.personalIncomeTax ?? 0) +\n      otherDeductionsTotal;\n\n    const netSalary = grossSalary - totalDeductions;\n\n    const insertData: NewHrmTbPayroll = {\n      payrollPeriodId: payload.payrollPeriodId,\n      employeeId: payload.employeeId,\n      baseSalary: payload.baseSalary,\n      allowances: payload.allowances ?? null,\n      overtimePay: payload.overtimePay ?? 0,\n      bonuses: payload.bonuses ?? 0,\n      otherEarnings: payload.otherEarnings ?? 0,\n      grossSalary: grossSalary,\n      socialInsurance: payload.socialInsurance ?? 0,\n      healthInsurance: payload.healthInsurance ?? 0,\n      unemploymentInsurance: payload.unemploymentInsurance ?? 0,\n      personalIncomeTax: payload.personalIncomeTax ?? 0,\n      otherDeductions: payload.otherDeductions ?? null,\n      totalDeductions: totalDeductions,\n      netSalary: netSalary,\n      workingDays: payload.workingDays ?? 0,\n      workingHours: payload.workingHours ?? 0,\n      overtimeHours: payload.overtimeHours ?? 0,\n      status: payload.status ?? \"draft\",\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create payroll\");\n\n    const payroll = await this.getPayrollById(created.id);\n\n    if (!payroll) throw new Error(\"Failed to load payroll after creation\");\n\n    return payroll;\n  };\n\n  updatePayroll = async (\n    id: string,\n    payload: Partial<PayrollInput>,\n  ): Promise<PayrollRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.payrollPeriodId !== undefined)\n      updateData.payrollPeriodId = payload.payrollPeriodId;\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.baseSalary !== undefined)\n      updateData.baseSalary = payload.baseSalary;\n    if (payload.allowances !== undefined)\n      updateData.allowances = payload.allowances ?? null;\n    if (payload.overtimePay !== undefined)\n      updateData.overtimePay = payload.overtimePay;\n    if (payload.bonuses !== undefined) updateData.bonuses = payload.bonuses;\n    if (payload.otherEarnings !== undefined)\n      updateData.otherEarnings = payload.otherEarnings;\n    if (payload.socialInsurance !== undefined)\n      updateData.socialInsurance = payload.socialInsurance;\n    if (payload.healthInsurance !== undefined)\n      updateData.healthInsurance = payload.healthInsurance;\n    if (payload.unemploymentInsurance !== undefined)\n      updateData.unemploymentInsurance = payload.unemploymentInsurance;\n    if (payload.personalIncomeTax !== undefined)\n      updateData.personalIncomeTax = payload.personalIncomeTax;\n    if (payload.otherDeductions !== undefined)\n      updateData.otherDeductions = payload.otherDeductions ?? null;\n    if (payload.workingDays !== undefined)\n      updateData.workingDays = payload.workingDays;\n    if (payload.workingHours !== undefined)\n      updateData.workingHours = payload.workingHours;\n    if (payload.overtimeHours !== undefined)\n      updateData.overtimeHours = payload.overtimeHours;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    // Recalculate totals if earnings/deductions changed\n    if (\n      payload.baseSalary !== undefined ||\n      payload.allowances !== undefined ||\n      payload.overtimePay !== undefined ||\n      payload.bonuses !== undefined ||\n      payload.otherEarnings !== undefined ||\n      payload.socialInsurance !== undefined ||\n      payload.healthInsurance !== undefined ||\n      payload.unemploymentInsurance !== undefined ||\n      payload.personalIncomeTax !== undefined ||\n      payload.otherDeductions !== undefined\n    ) {\n      const existing = await this.getPayrollById(id);\n\n      if (existing) {\n        const baseSalary = updateData.baseSalary ?? existing.baseSalary;\n        const allowances = (updateData.allowances ?? existing.allowances) as\n          | Record<string, number>\n          | undefined;\n        const allowancesTotal = allowances\n          ? Object.values(allowances).reduce((sum, val) => sum + val, 0)\n          : 0;\n        const overtimePay = updateData.overtimePay ?? existing.overtimePay ?? 0;\n        const bonuses = updateData.bonuses ?? existing.bonuses ?? 0;\n        const otherEarnings =\n          updateData.otherEarnings ?? existing.otherEarnings ?? 0;\n\n        const grossSalary =\n          baseSalary + allowancesTotal + overtimePay + bonuses + otherEarnings;\n\n        const socialInsurance =\n          updateData.socialInsurance ?? existing.socialInsurance ?? 0;\n        const healthInsurance =\n          updateData.healthInsurance ?? existing.healthInsurance ?? 0;\n        const unemploymentInsurance =\n          updateData.unemploymentInsurance ??\n          existing.unemploymentInsurance ??\n          0;\n        const personalIncomeTax =\n          updateData.personalIncomeTax ?? existing.personalIncomeTax ?? 0;\n        const otherDeductions = (updateData.otherDeductions ??\n          existing.otherDeductions) as Record<string, number> | undefined;\n        const otherDeductionsTotal = otherDeductions\n          ? Object.values(otherDeductions).reduce((sum, val) => sum + val, 0)\n          : 0;\n\n        const totalDeductions =\n          socialInsurance +\n          healthInsurance +\n          unemploymentInsurance +\n          personalIncomeTax +\n          otherDeductionsTotal;\n        const netSalary = grossSalary - totalDeductions;\n\n        updateData.grossSalary = grossSalary;\n        updateData.totalDeductions = totalDeductions;\n        updateData.netSalary = netSalary;\n      }\n    }\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getPayrollById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<PayrollInput> = {};\n\n    if (payload.payrollPeriodId !== undefined) {\n      normalizedPayload.payrollPeriodId = String(payload.payrollPeriodId);\n    }\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.baseSalary !== undefined) {\n      normalizedPayload.baseSalary = Number(payload.baseSalary);\n    }\n    if (payload.allowances !== undefined) {\n      normalizedPayload.allowances = payload.allowances;\n    }\n    if (payload.overtimePay !== undefined) {\n      normalizedPayload.overtimePay = Number(payload.overtimePay);\n    }\n    if (payload.bonuses !== undefined) {\n      normalizedPayload.bonuses = Number(payload.bonuses);\n    }\n    if (payload.otherEarnings !== undefined) {\n      normalizedPayload.otherEarnings = Number(payload.otherEarnings);\n    }\n    if (payload.socialInsurance !== undefined) {\n      normalizedPayload.socialInsurance = Number(payload.socialInsurance);\n    }\n    if (payload.healthInsurance !== undefined) {\n      normalizedPayload.healthInsurance = Number(payload.healthInsurance);\n    }\n    if (payload.unemploymentInsurance !== undefined) {\n      normalizedPayload.unemploymentInsurance = Number(\n        payload.unemploymentInsurance,\n      );\n    }\n    if (payload.personalIncomeTax !== undefined) {\n      normalizedPayload.personalIncomeTax = Number(payload.personalIncomeTax);\n    }\n    if (payload.otherDeductions !== undefined) {\n      normalizedPayload.otherDeductions = payload.otherDeductions;\n    }\n    if (payload.workingDays !== undefined) {\n      normalizedPayload.workingDays = Number(payload.workingDays);\n    }\n    if (payload.workingHours !== undefined) {\n      normalizedPayload.workingHours = Number(payload.workingHours);\n    }\n    if (payload.overtimeHours !== undefined) {\n      normalizedPayload.overtimeHours = Number(payload.overtimeHours);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updatePayroll(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Payroll/PayrollViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_payrolls } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_payrolls_period } from \"../../schemas/hrm.payroll-period\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst period = alias(hrm_tb_payrolls_period, \"period\");\n\nexport interface PayrollRow {\n  id: string;\n  payrollPeriodId: string;\n  payrollPeriod?: {\n    id: string;\n    code?: string;\n    name?: string | null;\n  } | null;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  grossSalary: number;\n  totalDeductions: number;\n  netSalary: number;\n  status: string;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass PayrollViewListModel extends BaseViewListModel<\n  typeof hrm_tb_payrolls,\n  PayrollRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_payrolls.id, sort: true }],\n      [\n        \"payrollPeriodId\",\n        { column: hrm_tb_payrolls.payrollPeriodId, sort: true },\n      ],\n      [\"employeeId\", { column: hrm_tb_payrolls.employeeId, sort: true }],\n      [\"grossSalary\", { column: hrm_tb_payrolls.grossSalary, sort: true }],\n      [\n        \"totalDeductions\",\n        { column: hrm_tb_payrolls.totalDeductions, sort: true },\n      ],\n      [\"netSalary\", { column: hrm_tb_payrolls.netSalary, sort: true }],\n      [\"status\", { column: hrm_tb_payrolls.status, sort: true }],\n      [\"createdAt\", { column: hrm_tb_payrolls.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_payrolls.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_payrolls });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"employeeCode\", (text: string) => ilike(employee.employeeCode, text)],\n      [\"fullName\", (text: string) => ilike(employee.fullName, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): PayrollRow => ({\n    id: row.id,\n    payrollPeriodId: row.payrollPeriodId,\n    payrollPeriod: row.payrollPeriodId\n      ? {\n          id: row.payrollPeriodId,\n          code: row.periodCode ?? undefined,\n          name: row.periodName ?? undefined,\n        }\n      : null,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    grossSalary: row.grossSalary,\n    totalDeductions: row.totalDeductions,\n    netSalary: row.netSalary,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PayrollRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(employee, eq(this.table.employeeId, employee.id))\n        .leftJoin(period, eq(this.table.payrollPeriodId, period.id)),\n    );\n  };\n}\n\nexport default PayrollViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Payroll/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PayrollPeriod/PayrollPeriodDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_payrolls_period } from \"../../schemas\";\n\nexport interface PayrollPeriodDropdownRow {\n  id: string;\n  code?: string | null;\n  name?: string | null;\n  startDate?: string | null;\n  endDate?: string | null;\n  isLocked?: boolean;\n}\n\nclass PayrollPeriodDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_payrolls_period,\n  PayrollPeriodDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_payrolls_period.id, sort: true }],\n      [\"code\", { column: hrm_tb_payrolls_period.code, sort: true }],\n      [\"name\", { column: hrm_tb_payrolls_period.name, sort: true }],\n      [\"isLocked\", { column: hrm_tb_payrolls_period.isLocked, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_payrolls_period });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_payrolls_period.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_payrolls_period.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): PayrollPeriodDropdownRow => ({\n    id: row.id,\n    code: row.code ?? undefined,\n    name: row.name ?? undefined,\n    startDate: row.startDate ?? undefined,\n    endDate: row.endDate ?? undefined,\n    isLocked: row.isLocked ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PayrollPeriodDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default PayrollPeriodDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PayrollPeriod/PayrollPeriodModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":34,"fix":{"range":[0,93],"text":"import { eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbPayrollPeriod, hrm_tb_payrolls_period } from \"../../schemas\";\n\nexport interface PayrollPeriodRow {\n  id: string;\n  code: string;\n  name?: string | null;\n  startDate: string;\n  endDate: string;\n  payDate: string;\n  status: string;\n  isLocked?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface PayrollPeriodInput {\n  code: string;\n  name?: string | null;\n  startDate: string;\n  endDate: string;\n  payDate: string;\n  status?: string;\n  isLocked?: boolean;\n}\n\nexport default class PayrollPeriodModel extends BaseModel<\n  typeof hrm_tb_payrolls_period\n> {\n  constructor() {\n    super(hrm_tb_payrolls_period);\n  }\n\n  getPayrollPeriodById = async (\n    id: string,\n  ): Promise<PayrollPeriodRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name ?? undefined,\n      startDate: row.startDate,\n      endDate: row.endDate,\n      payDate: row.payDate,\n      status: row.status,\n      isLocked: row.isLocked ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<PayrollPeriodRow | null> => {\n    return this.getPayrollPeriodById(params.id);\n  };\n\n  createPayrollPeriod = async (\n    payload: PayrollPeriodInput,\n  ): Promise<PayrollPeriodRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbPayrollPeriod = {\n      code: payload.code,\n      name: payload.name ?? null,\n      startDate: payload.startDate,\n      endDate: payload.endDate,\n      payDate: payload.payDate,\n      status: payload.status ?? \"draft\",\n      isLocked: payload.isLocked ?? false,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create payroll period\");\n\n    const period = await this.getPayrollPeriodById(created.id);\n\n    if (!period)\n      throw new Error(\"Failed to load payroll period after creation\");\n\n    return period;\n  };\n\n  updatePayrollPeriod = async (\n    id: string,\n    payload: Partial<PayrollPeriodInput>,\n  ): Promise<PayrollPeriodRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name ?? null;\n    if (payload.startDate !== undefined)\n      updateData.startDate = payload.startDate;\n    if (payload.endDate !== undefined) updateData.endDate = payload.endDate;\n    if (payload.payDate !== undefined) updateData.payDate = payload.payDate;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.isLocked !== undefined) updateData.isLocked = payload.isLocked;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getPayrollPeriodById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<PayrollPeriodInput> = {};\n\n    if (payload.code !== undefined)\n      normalizedPayload.code = String(payload.code);\n    if (payload.name !== undefined) {\n      normalizedPayload.name =\n        payload.name === null || payload.name === \"\"\n          ? null\n          : String(payload.name);\n    }\n    if (payload.startDate !== undefined) {\n      normalizedPayload.startDate = String(payload.startDate);\n    }\n    if (payload.endDate !== undefined) {\n      normalizedPayload.endDate = String(payload.endDate);\n    }\n    if (payload.payDate !== undefined) {\n      normalizedPayload.payDate = String(payload.payDate);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.isLocked !== undefined) {\n      normalizedPayload.isLocked = Boolean(payload.isLocked);\n    }\n\n    return this.updatePayrollPeriod(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PayrollPeriod/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PayrollRule/PayrollRuleModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbPayrollRule, hrm_tb_payrolls_rule } from \"../../schemas\";\n\nexport interface PayrollRuleRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  ruleType: string;\n  ruleConfig?: unknown;\n  effectiveDate: string;\n  expiryDate?: string | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface PayrollRuleInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  ruleType: string;\n  ruleConfig: unknown;\n  effectiveDate: string;\n  expiryDate?: string | null;\n  isActive?: boolean;\n}\n\nexport default class PayrollRuleModel extends BaseModel<\n  typeof hrm_tb_payrolls_rule\n> {\n  constructor() {\n    super(hrm_tb_payrolls_rule);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getPayrollRuleById = async (id: string): Promise<PayrollRuleRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      ruleType: row.ruleType,\n      ruleConfig: row.ruleConfig,\n      effectiveDate: row.effectiveDate,\n      expiryDate: row.expiryDate ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<PayrollRuleRow | null> => {\n    return this.getPayrollRuleById(params.id);\n  };\n\n  createPayrollRule = async (\n    payload: PayrollRuleInput,\n  ): Promise<PayrollRuleRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbPayrollRule = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      ruleType: payload.ruleType,\n      ruleConfig: payload.ruleConfig,\n      effectiveDate: payload.effectiveDate,\n      expiryDate: payload.expiryDate ?? null,\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create payroll rule\");\n\n    const rule = await this.getPayrollRuleById(created.id);\n\n    if (!rule) throw new Error(\"Failed to load payroll rule after creation\");\n\n    return rule;\n  };\n\n  updatePayrollRule = async (\n    id: string,\n    payload: Partial<PayrollRuleInput>,\n  ): Promise<PayrollRuleRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.ruleType !== undefined) updateData.ruleType = payload.ruleType;\n    if (payload.ruleConfig !== undefined)\n      updateData.ruleConfig = payload.ruleConfig;\n    if (payload.effectiveDate !== undefined)\n      updateData.effectiveDate = payload.effectiveDate;\n    if (payload.expiryDate !== undefined)\n      updateData.expiryDate = payload.expiryDate ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getPayrollRuleById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<PayrollRuleInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.ruleType !== undefined) {\n      normalizedPayload.ruleType = String(payload.ruleType);\n    }\n    if (payload.ruleConfig !== undefined) {\n      normalizedPayload.ruleConfig = payload.ruleConfig;\n    }\n    if (payload.effectiveDate !== undefined) {\n      normalizedPayload.effectiveDate = String(payload.effectiveDate);\n    }\n    if (payload.expiryDate !== undefined) {\n      normalizedPayload.expiryDate =\n        payload.expiryDate === null || payload.expiryDate === \"\"\n          ? null\n          : String(payload.expiryDate);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updatePayrollRule(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PayrollRule/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PerformanceReview/PerformanceReviewModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport {\n  NewHrmTbPerformanceReview,\n  hrm_tb_performance_reviews,\n} from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst reviewer = alias(hrm_tb_employees, \"reviewer\");\n\nexport interface PerformanceReviewRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  reviewType: string;\n  reviewPeriod?: string | null;\n  reviewDate: string;\n  reviewerId: string;\n  reviewer?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  overallRating?: number | null;\n  strengths?: string | null;\n  areasForImprovement?: string | null;\n  goals?: unknown;\n  feedback?: string | null;\n  employeeComments?: string | null;\n  status: string;\n  completedDate?: string | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface PerformanceReviewInput {\n  employeeId: string;\n  reviewType: string;\n  reviewPeriod?: string | null;\n  reviewDate: string;\n  reviewerId: string;\n  overallRating?: number | null;\n  strengths?: string | null;\n  areasForImprovement?: string | null;\n  goals?: unknown;\n  feedback?: string | null;\n  employeeComments?: string | null;\n  status?: string;\n}\n\nexport default class PerformanceReviewModel extends BaseModel<\n  typeof hrm_tb_performance_reviews\n> {\n  constructor() {\n    super(hrm_tb_performance_reviews);\n  }\n\n  getPerformanceReviewById = async (\n    id: string,\n  ): Promise<PerformanceReviewRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        reviewType: this.table.reviewType,\n        reviewPeriod: this.table.reviewPeriod,\n        reviewDate: this.table.reviewDate,\n        reviewerId: this.table.reviewerId,\n        reviewerCode: reviewer.employeeCode,\n        reviewerFullName: reviewer.fullName,\n        overallRating: this.table.overallRating,\n        strengths: this.table.strengths,\n        areasForImprovement: this.table.areasForImprovement,\n        goals: this.table.goals,\n        feedback: this.table.feedback,\n        employeeComments: this.table.employeeComments,\n        status: this.table.status,\n        completedDate: this.table.completedDate,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .leftJoin(reviewer, eq(this.table.reviewerId, reviewer.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      reviewType: row.reviewType,\n      reviewPeriod: row.reviewPeriod ?? undefined,\n      reviewDate: row.reviewDate,\n      reviewerId: row.reviewerId,\n      reviewer: row.reviewerId\n        ? {\n            id: row.reviewerId,\n            employeeCode: row.reviewerCode ?? undefined,\n            fullName: row.reviewerFullName ?? undefined,\n          }\n        : null,\n      overallRating: row.overallRating ?? undefined,\n      strengths: row.strengths ?? undefined,\n      areasForImprovement: row.areasForImprovement ?? undefined,\n      goals: row.goals,\n      feedback: row.feedback ?? undefined,\n      employeeComments: row.employeeComments ?? undefined,\n      status: row.status,\n      completedDate: row.completedDate ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<PerformanceReviewRow | null> => {\n    return this.getPerformanceReviewById(params.id);\n  };\n\n  createPerformanceReview = async (\n    payload: PerformanceReviewInput,\n  ): Promise<PerformanceReviewRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbPerformanceReview = {\n      employeeId: payload.employeeId,\n      reviewType: payload.reviewType,\n      reviewPeriod: payload.reviewPeriod ?? null,\n      reviewDate: payload.reviewDate,\n      reviewerId: payload.reviewerId,\n      overallRating: payload.overallRating ?? null,\n      strengths: payload.strengths ?? null,\n      areasForImprovement: payload.areasForImprovement ?? null,\n      goals: payload.goals ?? null,\n      feedback: payload.feedback ?? null,\n      employeeComments: payload.employeeComments ?? null,\n      status: payload.status ?? \"draft\",\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create performance review\");\n\n    const review = await this.getPerformanceReviewById(created.id);\n\n    if (!review)\n      throw new Error(\"Failed to load performance review after creation\");\n\n    return review;\n  };\n\n  updatePerformanceReview = async (\n    id: string,\n    payload: Partial<PerformanceReviewInput>,\n  ): Promise<PerformanceReviewRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.reviewType !== undefined)\n      updateData.reviewType = payload.reviewType;\n    if (payload.reviewPeriod !== undefined)\n      updateData.reviewPeriod = payload.reviewPeriod ?? null;\n    if (payload.reviewDate !== undefined)\n      updateData.reviewDate = payload.reviewDate;\n    if (payload.reviewerId !== undefined)\n      updateData.reviewerId = payload.reviewerId;\n    if (payload.overallRating !== undefined)\n      updateData.overallRating = payload.overallRating ?? null;\n    if (payload.strengths !== undefined)\n      updateData.strengths = payload.strengths ?? null;\n    if (payload.areasForImprovement !== undefined)\n      updateData.areasForImprovement = payload.areasForImprovement ?? null;\n    if (payload.goals !== undefined) updateData.goals = payload.goals ?? null;\n    if (payload.feedback !== undefined)\n      updateData.feedback = payload.feedback ?? null;\n    if (payload.employeeComments !== undefined)\n      updateData.employeeComments = payload.employeeComments ?? null;\n    if (payload.status !== undefined) {\n      updateData.status = payload.status;\n      if (payload.status === \"completed\") {\n        updateData.completedDate = new Date().toISOString().split(\"T\")[0];\n      }\n    }\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getPerformanceReviewById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<PerformanceReviewInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.reviewType !== undefined) {\n      normalizedPayload.reviewType = String(payload.reviewType);\n    }\n    if (payload.reviewPeriod !== undefined) {\n      normalizedPayload.reviewPeriod =\n        payload.reviewPeriod === null || payload.reviewPeriod === \"\"\n          ? null\n          : String(payload.reviewPeriod);\n    }\n    if (payload.reviewDate !== undefined) {\n      normalizedPayload.reviewDate = String(payload.reviewDate);\n    }\n    if (payload.reviewerId !== undefined) {\n      normalizedPayload.reviewerId = String(payload.reviewerId);\n    }\n    if (payload.overallRating !== undefined) {\n      normalizedPayload.overallRating =\n        payload.overallRating === null || payload.overallRating === \"\"\n          ? null\n          : Number(payload.overallRating);\n    }\n    if (payload.strengths !== undefined) {\n      normalizedPayload.strengths =\n        payload.strengths === null || payload.strengths === \"\"\n          ? null\n          : String(payload.strengths);\n    }\n    if (payload.areasForImprovement !== undefined) {\n      normalizedPayload.areasForImprovement =\n        payload.areasForImprovement === null ||\n        payload.areasForImprovement === \"\"\n          ? null\n          : String(payload.areasForImprovement);\n    }\n    if (payload.goals !== undefined) {\n      normalizedPayload.goals = payload.goals;\n    }\n    if (payload.feedback !== undefined) {\n      normalizedPayload.feedback =\n        payload.feedback === null || payload.feedback === \"\"\n          ? null\n          : String(payload.feedback);\n    }\n    if (payload.employeeComments !== undefined) {\n      normalizedPayload.employeeComments =\n        payload.employeeComments === null || payload.employeeComments === \"\"\n          ? null\n          : String(payload.employeeComments);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n\n    return this.updatePerformanceReview(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PerformanceReview/PerformanceReviewViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_performance_reviews } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst reviewer = alias(hrm_tb_employees, \"reviewer\");\n\nexport interface PerformanceReviewRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  reviewType: string;\n  reviewPeriod?: string | null;\n  reviewDate: string;\n  reviewerId: string;\n  reviewer?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  overallRating?: number | null;\n  status: string;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass PerformanceReviewViewListModel extends BaseViewListModel<\n  typeof hrm_tb_performance_reviews,\n  PerformanceReviewRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_performance_reviews.id, sort: true }],\n      [\n        \"employeeId\",\n        { column: hrm_tb_performance_reviews.employeeId, sort: true },\n      ],\n      [\n        \"reviewType\",\n        { column: hrm_tb_performance_reviews.reviewType, sort: true },\n      ],\n      [\n        \"reviewDate\",\n        { column: hrm_tb_performance_reviews.reviewDate, sort: true },\n      ],\n      [\n        \"reviewerId\",\n        { column: hrm_tb_performance_reviews.reviewerId, sort: true },\n      ],\n      [\n        \"overallRating\",\n        { column: hrm_tb_performance_reviews.overallRating, sort: true },\n      ],\n      [\"status\", { column: hrm_tb_performance_reviews.status, sort: true }],\n      [\n        \"createdAt\",\n        { column: hrm_tb_performance_reviews.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: hrm_tb_performance_reviews.updatedAt, sort: true },\n      ],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_performance_reviews });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"employeeCode\", (text: string) => ilike(employee.employeeCode, text)],\n      [\"fullName\", (text: string) => ilike(employee.fullName, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): PerformanceReviewRow => ({\n    id: row.id,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    reviewType: row.reviewType,\n    reviewPeriod: row.reviewPeriod ?? undefined,\n    reviewDate: row.reviewDate,\n    reviewerId: row.reviewerId,\n    reviewer: row.reviewerId\n      ? {\n          id: row.reviewerId,\n          employeeCode: row.reviewerCode ?? undefined,\n          fullName: row.reviewerFullName ?? undefined,\n        }\n      : null,\n    overallRating: row.overallRating ?? undefined,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PerformanceReviewRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(employee, eq(this.table.employeeId, employee.id))\n        .leftJoin(reviewer, eq(this.table.reviewerId, reviewer.id)),\n    );\n  };\n}\n\nexport default PerformanceReviewViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/PerformanceReview/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Position/PositionDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_positions } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\n\nconst department = alias(hrm_tb_departments, \"department\");\n\nexport interface PositionDropdownRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  isActive?: boolean;\n}\n\nclass PositionDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_positions,\n  PositionDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_positions.id, sort: true }],\n      [\"code\", { column: hrm_tb_positions.code, sort: true }],\n      [\"name\", { column: hrm_tb_positions.name, sort: true }],\n      [\"departmentId\", { column: hrm_tb_positions.departmentId, sort: true }],\n      [\"isActive\", { column: hrm_tb_positions.isActive, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_positions });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_positions.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_positions.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): PositionDropdownRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    departmentId: row.departmentId,\n    department: row.departmentId\n      ? {\n          id: row.departmentId,\n          name: row.departmentName ?? undefined,\n        }\n      : null,\n    isActive: row.isActive ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PositionDropdownRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(department, eq(this.table.departmentId, department.id)),\n    );\n  };\n}\n\nexport default PositionDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Position/PositionModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbPosition, hrm_tb_positions } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\n\nconst department = alias(hrm_tb_departments, \"department\");\n\nexport interface PositionRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  jobFamily?: string | null;\n  jobGrade?: string | null;\n  reportsTo?: string | null;\n  reportingPosition?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  minSalary?: number | null;\n  maxSalary?: number | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface PositionInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  departmentId: string;\n  jobFamily?: string | null;\n  jobGrade?: string | null;\n  reportsTo?: string | null;\n  minSalary?: number | null;\n  maxSalary?: number | null;\n  isActive?: boolean;\n}\n\nexport default class PositionModel extends BaseModel<typeof hrm_tb_positions> {\n  constructor() {\n    super(hrm_tb_positions);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getPositionById = async (id: string): Promise<PositionRow | null> => {\n    const reportingPosition = alias(hrm_tb_positions, \"reporting_position\");\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        code: this.table.code,\n        name: this.table.name,\n        description: this.table.description,\n        departmentId: this.table.departmentId,\n        departmentName: department.name,\n        jobFamily: this.table.jobFamily,\n        jobGrade: this.table.jobGrade,\n        reportsTo: this.table.reportsTo,\n        reportingPositionName: reportingPosition.name,\n        minSalary: this.table.minSalary,\n        maxSalary: this.table.maxSalary,\n        isActive: this.table.isActive,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(department, eq(this.table.departmentId, department.id))\n      .leftJoin(\n        reportingPosition,\n        eq(this.table.reportsTo, reportingPosition.id),\n      )\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      departmentId: row.departmentId,\n      department: row.departmentId\n        ? {\n            id: row.departmentId,\n            name: row.departmentName ?? undefined,\n          }\n        : null,\n      jobFamily: row.jobFamily ?? undefined,\n      jobGrade: row.jobGrade ?? undefined,\n      reportsTo: row.reportsTo ?? undefined,\n      reportingPosition: row.reportsTo\n        ? {\n            id: row.reportsTo,\n            name: row.reportingPositionName ?? undefined,\n          }\n        : null,\n      minSalary: row.minSalary ?? undefined,\n      maxSalary: row.maxSalary ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<PositionRow | null> => {\n    return this.getPositionById(params.id);\n  };\n\n  createPosition = async (payload: PositionInput): Promise<PositionRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbPosition = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      departmentId: payload.departmentId,\n      jobFamily: payload.jobFamily ?? null,\n      jobGrade: payload.jobGrade ?? null,\n      reportsTo: payload.reportsTo ?? null,\n      minSalary: payload.minSalary ?? null,\n      maxSalary: payload.maxSalary ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create position\");\n    }\n\n    const row = await this.getPositionById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load position after creation\");\n    }\n\n    return row;\n  };\n\n  updatePosition = async (\n    id: string,\n    payload: Partial<PositionInput>,\n  ): Promise<PositionRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.departmentId !== undefined)\n      updateData.departmentId = payload.departmentId;\n    if (payload.jobFamily !== undefined)\n      updateData.jobFamily = payload.jobFamily ?? null;\n    if (payload.jobGrade !== undefined)\n      updateData.jobGrade = payload.jobGrade ?? null;\n    if (payload.reportsTo !== undefined)\n      updateData.reportsTo = payload.reportsTo ?? null;\n    if (payload.minSalary !== undefined)\n      updateData.minSalary = payload.minSalary ?? null;\n    if (payload.maxSalary !== undefined)\n      updateData.maxSalary = payload.maxSalary ?? null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getPositionById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<PositionInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.departmentId !== undefined) {\n      normalizedPayload.departmentId = String(payload.departmentId);\n    }\n    if (payload.jobFamily !== undefined) {\n      normalizedPayload.jobFamily =\n        payload.jobFamily === null || payload.jobFamily === \"\"\n          ? null\n          : String(payload.jobFamily);\n    }\n    if (payload.jobGrade !== undefined) {\n      normalizedPayload.jobGrade =\n        payload.jobGrade === null || payload.jobGrade === \"\"\n          ? null\n          : String(payload.jobGrade);\n    }\n    if (payload.reportsTo !== undefined) {\n      normalizedPayload.reportsTo =\n        payload.reportsTo === null || payload.reportsTo === \"\"\n          ? null\n          : String(payload.reportsTo);\n    }\n    if (payload.minSalary !== undefined) {\n      normalizedPayload.minSalary =\n        payload.minSalary === null || payload.minSalary === \"\"\n          ? null\n          : Number(payload.minSalary);\n    }\n    if (payload.maxSalary !== undefined) {\n      normalizedPayload.maxSalary =\n        payload.maxSalary === null || payload.maxSalary === \"\"\n          ? null\n          : Number(payload.maxSalary);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updatePosition(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Position/PositionViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_positions } from \"../../schemas\";\nimport { hrm_tb_departments } from \"../../schemas/hrm.department\";\n\nconst department = alias(hrm_tb_departments, \"department\");\n\nexport interface PositionRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  departmentId: string;\n  department?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  jobFamily?: string | null;\n  jobGrade?: string | null;\n  reportsTo?: string | null;\n  minSalary?: number | null;\n  maxSalary?: number | null;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass PositionViewListModel extends BaseViewListModel<\n  typeof hrm_tb_positions,\n  PositionRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_positions.id, sort: true }],\n      [\"code\", { column: hrm_tb_positions.code, sort: true }],\n      [\"name\", { column: hrm_tb_positions.name, sort: true }],\n      [\"description\", { column: hrm_tb_positions.description, sort: false }],\n      [\"departmentId\", { column: hrm_tb_positions.departmentId, sort: true }],\n      [\"jobFamily\", { column: hrm_tb_positions.jobFamily, sort: true }],\n      [\"jobGrade\", { column: hrm_tb_positions.jobGrade, sort: true }],\n      [\"reportsTo\", { column: hrm_tb_positions.reportsTo, sort: true }],\n      [\"minSalary\", { column: hrm_tb_positions.minSalary, sort: true }],\n      [\"maxSalary\", { column: hrm_tb_positions.maxSalary, sort: true }],\n      [\"isActive\", { column: hrm_tb_positions.isActive, sort: true }],\n      [\"createdAt\", { column: hrm_tb_positions.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_positions.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_positions });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_positions.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_positions.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): PositionRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    description: row.description,\n    departmentId: row.departmentId,\n    department: row.departmentId\n      ? {\n          id: row.departmentId,\n          name: row.departmentName ?? undefined,\n        }\n      : null,\n    jobFamily: row.jobFamily ?? undefined,\n    jobGrade: row.jobGrade ?? undefined,\n    reportsTo: row.reportsTo ?? undefined,\n    minSalary: row.minSalary ?? undefined,\n    maxSalary: row.maxSalary ?? undefined,\n    isActive: row.isActive ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<PositionRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(department, eq(this.table.departmentId, department.id)),\n    );\n  };\n}\n\nexport default PositionViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Position/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Role/RoleModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":31,"fix":{"range":[238,238],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":39,"fix":{"range":[0,278],"text":"import { eq, and } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n  base_tb_roles,\n} from \"@base/server/schemas\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport {\n  base_tb_permissions,\n  base_tb_role_permissions_default,\n  base_tb_roles,\n} from \"@base/server/schemas\";\nimport { eq, and } from \"drizzle-orm\";\n\nexport interface RoleRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  permissions?: string[];\n  isSystem?: boolean;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface RoleInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  permissions: string[];\n  isSystem?: boolean;\n  isActive?: boolean;\n}\n\nexport default class RoleModel extends BaseModel<typeof base_tb_roles> {\n  constructor() {\n    super(base_tb_roles);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  /**\n   * Get all active roles\n   */\n  async getRoles(): Promise<RoleRow[]> {\n    const results = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.isActive, true))\n      .orderBy(this.table.code);\n\n    return Promise.all(results.map((row) => this.mapToRoleRow(row)));\n  }\n\n  getRoleById = async (id: string): Promise<RoleRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return this.mapToRoleRow(row);\n  };\n\n  getDataById = async (params: { id: string }): Promise<RoleRow | null> => {\n    return this.getRoleById(params.id);\n  };\n\n  createRole = async (payload: RoleInput): Promise<RoleRow> => {\n    const now = new Date();\n    const insertData = {\n      code: payload.code,\n      name: payload.name,\n      description:\n        payload.description !== null && payload.description !== undefined\n          ? String(payload.description)\n          : null,\n      isSystem: payload.isSystem ?? false,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create role\");\n    }\n\n    // Add permissions to role_permissions_default if provided\n    if (payload.permissions && payload.permissions.length > 0) {\n      for (const permKey of payload.permissions) {\n        const perm = await this.db\n          .select({ id: base_tb_permissions.id })\n          .from(base_tb_permissions)\n          .where(eq(base_tb_permissions.key, permKey))\n          .limit(1);\n\n        if (perm[0]) {\n          await this.db.insert(base_tb_role_permissions_default).values({\n            roleId: created.id,\n            permissionId: perm[0].id,\n            isActive: true,\n            createdAt: now,\n          });\n        }\n      }\n    }\n\n    const role = await this.getRoleById(created.id);\n\n    if (!role) {\n      throw new Error(\"Failed to load role after creation\");\n    }\n\n    return role;\n  };\n\n  updateRole = async (\n    id: string,\n    payload: Partial<RoleInput>,\n  ): Promise<RoleRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description =\n        payload.description !== null && payload.description !== undefined\n          ? String(payload.description)\n          : null;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    // Update permissions if provided\n    if (payload.permissions !== undefined) {\n      // Get permission IDs from keys\n      const permissionIds: string[] = [];\n\n      for (const permKey of payload.permissions) {\n        const perm = await this.db\n          .select({ id: base_tb_permissions.id })\n          .from(base_tb_permissions)\n          .where(eq(base_tb_permissions.key, permKey))\n          .limit(1);\n\n        if (perm[0]) {\n          permissionIds.push(perm[0].id);\n        }\n      }\n\n      // Remove all current permissions\n      await this.db\n        .update(base_tb_role_permissions_default)\n        .set({ isActive: false })\n        .where(eq(base_tb_role_permissions_default.roleId, id));\n\n      // Add new permissions\n      const now = new Date();\n\n      for (const permissionId of permissionIds) {\n        // Check if exists\n        const existing = await this.db\n          .select()\n          .from(base_tb_role_permissions_default)\n          .where(\n            and(\n              eq(base_tb_role_permissions_default.roleId, id),\n              eq(base_tb_role_permissions_default.permissionId, permissionId),\n            ),\n          )\n          .limit(1);\n\n        if (existing[0]) {\n          // Reactivate if inactive\n          await this.db\n            .update(base_tb_role_permissions_default)\n            .set({ isActive: true })\n            .where(eq(base_tb_role_permissions_default.id, existing[0].id));\n        } else {\n          // Insert new\n          await this.db.insert(base_tb_role_permissions_default).values({\n            roleId: id,\n            permissionId,\n            isActive: true,\n            createdAt: now,\n          });\n        }\n      }\n    }\n\n    return this.getRoleById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<RoleInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.permissions !== undefined) {\n      normalizedPayload.permissions = Array.isArray(payload.permissions)\n        ? payload.permissions\n        : [];\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateRole(id, normalizedPayload);\n  };\n\n  private async mapToRoleRow(\n    row: typeof base_tb_roles.$inferSelect,\n  ): Promise<RoleRow> {\n    // Get permissions for this role\n    const permissions = await this.db\n      .select({\n        permissionKey: base_tb_permissions.key,\n      })\n      .from(base_tb_role_permissions_default)\n      .innerJoin(\n        base_tb_permissions,\n        eq(\n          base_tb_role_permissions_default.permissionId,\n          base_tb_permissions.id,\n        ),\n      )\n      .where(\n        and(\n          eq(base_tb_role_permissions_default.roleId, row.id),\n          eq(base_tb_role_permissions_default.isActive, true),\n          eq(base_tb_permissions.isActive, true),\n        ),\n      );\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description ?? undefined,\n      permissions: permissions.map((p) => p.permissionKey),\n      isSystem: row.isSystem ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Role/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Shift/ShiftDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { hrm_tb_shifts } from \"../../schemas\";\n\nexport interface ShiftDropdownRow {\n  id: string;\n  code?: string | null;\n  name?: unknown;\n  isActive?: boolean;\n}\n\nclass ShiftDropdownListModel extends BaseViewListModel<\n  typeof hrm_tb_shifts,\n  ShiftDropdownRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_shifts.id, sort: true }],\n      [\"code\", { column: hrm_tb_shifts.code, sort: true }],\n      [\"name\", { column: hrm_tb_shifts.name, sort: true }],\n      [\"isActive\", { column: hrm_tb_shifts.isActive, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_shifts });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(hrm_tb_shifts.code, text)],\n      [\"name\", (text: string) => ilike(hrm_tb_shifts.name, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): ShiftDropdownRow => ({\n    id: row.id,\n    code: row.code ?? undefined,\n    name: row.name,\n    isActive: row.isActive ?? undefined,\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<ShiftDropdownRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default ShiftDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Shift/ShiftModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbShift, hrm_tb_shifts } from \"../../schemas\";\n\nexport interface ShiftRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  startTime?: string | null;\n  endTime?: string | null;\n  breakDuration?: number;\n  workingHours?: number;\n  isNightShift?: boolean;\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface ShiftInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  startTime: string; // HH:mm format\n  endTime: string; // HH:mm format\n  breakDuration?: number;\n  workingHours: number;\n  isNightShift?: boolean;\n  isActive?: boolean;\n}\n\nexport default class ShiftModel extends BaseModel<typeof hrm_tb_shifts> {\n  constructor() {\n    super(hrm_tb_shifts);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getShiftById = async (id: string): Promise<ShiftRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      startTime: row.startTime ?? undefined,\n      endTime: row.endTime ?? undefined,\n      breakDuration: row.breakDuration ?? undefined,\n      workingHours: row.workingHours ?? undefined,\n      isNightShift: row.isNightShift ?? undefined,\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<ShiftRow | null> => {\n    return this.getShiftById(params.id);\n  };\n\n  createShift = async (payload: ShiftInput): Promise<ShiftRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbShift = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      startTime: payload.startTime as any,\n      endTime: payload.endTime as any,\n      breakDuration: payload.breakDuration ?? 0,\n      workingHours: payload.workingHours,\n      isNightShift: payload.isNightShift ?? false,\n      isActive: payload.isActive ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create shift\");\n\n    const shift = await this.getShiftById(created.id);\n\n    if (!shift) throw new Error(\"Failed to load shift after creation\");\n\n    return shift;\n  };\n\n  updateShift = async (\n    id: string,\n    payload: Partial<ShiftInput>,\n  ): Promise<ShiftRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.startTime !== undefined)\n      updateData.startTime = payload.startTime as any;\n    if (payload.endTime !== undefined)\n      updateData.endTime = payload.endTime as any;\n    if (payload.breakDuration !== undefined)\n      updateData.breakDuration = payload.breakDuration;\n    if (payload.workingHours !== undefined)\n      updateData.workingHours = payload.workingHours;\n    if (payload.isNightShift !== undefined)\n      updateData.isNightShift = payload.isNightShift;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getShiftById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<ShiftInput> = {};\n\n    if (payload.code !== undefined)\n      normalizedPayload.code = String(payload.code);\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.startTime !== undefined) {\n      normalizedPayload.startTime = String(payload.startTime);\n    }\n    if (payload.endTime !== undefined) {\n      normalizedPayload.endTime = String(payload.endTime);\n    }\n    if (payload.breakDuration !== undefined) {\n      normalizedPayload.breakDuration = Number(payload.breakDuration);\n    }\n    if (payload.workingHours !== undefined) {\n      normalizedPayload.workingHours = Number(payload.workingHours);\n    }\n    if (payload.isNightShift !== undefined) {\n      normalizedPayload.isNightShift = Boolean(payload.isNightShift);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateShift(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Shift/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Timesheet/TimesheetModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseModel` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[0,138],"text":"import { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { NewHrmTbTimesheet, hrm_tb_timesheets } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_shifts } from \"../../schemas/hrm.shift\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst shift = alias(hrm_tb_shifts, \"shift\");\n\nexport interface TimesheetRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  rosterId?: string | null;\n  workDate: string;\n  shiftId?: string | null;\n  shift?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  checkInTime?: number | null;\n  checkOutTime?: number | null;\n  actualHours?: number | null;\n  regularHours?: number | null;\n  overtimeHours?: number;\n  breakDuration?: number;\n  status: string;\n  checkInMethod?: string | null;\n  checkOutMethod?: string | null;\n  checkInLocation?: string | null;\n  checkOutLocation?: string | null;\n  notes?: string | null;\n  approvedBy?: string | null;\n  approvedAt?: number | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface TimesheetInput {\n  employeeId: string;\n  rosterId?: string | null;\n  workDate: string;\n  shiftId?: string | null;\n  checkInTime?: string | null;\n  checkOutTime?: string | null;\n  breakDuration?: number;\n  status?: string;\n  checkInMethod?: string | null;\n  checkOutMethod?: string | null;\n  checkInLocation?: string | null;\n  checkOutLocation?: string | null;\n  notes?: string | null;\n}\n\nexport default class TimesheetModel extends BaseModel<\n  typeof hrm_tb_timesheets\n> {\n  constructor() {\n    super(hrm_tb_timesheets);\n  }\n\n  getTimesheetById = async (id: string): Promise<TimesheetRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        employeeId: this.table.employeeId,\n        employeeCode: employee.employeeCode,\n        employeeFullName: employee.fullName,\n        rosterId: this.table.rosterId,\n        workDate: this.table.workDate,\n        shiftId: this.table.shiftId,\n        shiftName: shift.name,\n        checkInTime: this.table.checkInTime,\n        checkOutTime: this.table.checkOutTime,\n        actualHours: this.table.actualHours,\n        regularHours: this.table.regularHours,\n        overtimeHours: this.table.overtimeHours,\n        breakDuration: this.table.breakDuration,\n        status: this.table.status,\n        checkInMethod: this.table.checkInMethod,\n        checkOutMethod: this.table.checkOutMethod,\n        checkInLocation: this.table.checkInLocation,\n        checkOutLocation: this.table.checkOutLocation,\n        notes: this.table.notes,\n        approvedBy: this.table.approvedBy,\n        approvedAt: this.table.approvedAt,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(employee, eq(this.table.employeeId, employee.id))\n      .leftJoin(shift, eq(this.table.shiftId, shift.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) return null;\n\n    return {\n      id: row.id,\n      employeeId: row.employeeId,\n      employee: row.employeeId\n        ? {\n            id: row.employeeId,\n            employeeCode: row.employeeCode ?? undefined,\n            fullName: row.employeeFullName ?? undefined,\n          }\n        : null,\n      rosterId: row.rosterId ?? undefined,\n      workDate: row.workDate,\n      shiftId: row.shiftId ?? undefined,\n      shift: row.shiftId\n        ? {\n            id: row.shiftId,\n            name: row.shiftName ?? undefined,\n          }\n        : null,\n      checkInTime: row.checkInTime?.getTime(),\n      checkOutTime: row.checkOutTime?.getTime(),\n      actualHours: row.actualHours ?? undefined,\n      regularHours: row.regularHours ?? undefined,\n      overtimeHours: row.overtimeHours ?? undefined,\n      breakDuration: row.breakDuration ?? undefined,\n      status: row.status,\n      checkInMethod: row.checkInMethod ?? undefined,\n      checkOutMethod: row.checkOutMethod ?? undefined,\n      checkInLocation: row.checkInLocation ?? undefined,\n      checkOutLocation: row.checkOutLocation ?? undefined,\n      notes: row.notes ?? undefined,\n      approvedBy: row.approvedBy ?? undefined,\n      approvedAt: row.approvedAt?.getTime(),\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: {\n    id: string;\n  }): Promise<TimesheetRow | null> => {\n    return this.getTimesheetById(params.id);\n  };\n\n  createTimesheet = async (payload: TimesheetInput): Promise<TimesheetRow> => {\n    const now = new Date();\n    const checkInTime = payload.checkInTime\n      ? new Date(payload.checkInTime)\n      : null;\n    const checkOutTime = payload.checkOutTime\n      ? new Date(payload.checkOutTime)\n      : null;\n\n    // Calculate hours if both check in/out are provided\n    let actualHours: number | null = null;\n    let regularHours: number | null = null;\n    let overtimeHours = 0;\n\n    if (checkInTime && checkOutTime) {\n      const diffMs = checkOutTime.getTime() - checkInTime.getTime();\n      const diffHours =\n        diffMs / (1000 * 60 * 60) - (payload.breakDuration ?? 0) / 60;\n\n      actualHours = Math.max(0, Math.round(diffHours * 100) / 100);\n      // TODO: Calculate regular vs OT based on shift rules\n      regularHours = actualHours;\n    }\n\n    const insertData: NewHrmTbTimesheet = {\n      employeeId: payload.employeeId,\n      rosterId: payload.rosterId ?? null,\n      workDate: payload.workDate,\n      shiftId: payload.shiftId ?? null,\n      checkInTime: checkInTime,\n      checkOutTime: checkOutTime,\n      actualHours: actualHours,\n      regularHours: regularHours,\n      overtimeHours: overtimeHours,\n      breakDuration: payload.breakDuration ?? 0,\n      status: payload.status ?? \"pending\",\n      checkInMethod: payload.checkInMethod ?? null,\n      checkOutMethod: payload.checkOutMethod ?? null,\n      checkInLocation: payload.checkInLocation ?? null,\n      checkOutLocation: payload.checkOutLocation ?? null,\n      notes: payload.notes ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) throw new Error(\"Failed to create timesheet\");\n\n    const timesheet = await this.getTimesheetById(created.id);\n\n    if (!timesheet) throw new Error(\"Failed to load timesheet after creation\");\n\n    return timesheet;\n  };\n\n  updateTimesheet = async (\n    id: string,\n    payload: Partial<TimesheetInput>,\n  ): Promise<TimesheetRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.employeeId !== undefined)\n      updateData.employeeId = payload.employeeId;\n    if (payload.rosterId !== undefined)\n      updateData.rosterId = payload.rosterId ?? null;\n    if (payload.workDate !== undefined) updateData.workDate = payload.workDate;\n    if (payload.shiftId !== undefined)\n      updateData.shiftId = payload.shiftId ?? null;\n    if (payload.checkInTime !== undefined)\n      updateData.checkInTime = payload.checkInTime\n        ? new Date(payload.checkInTime)\n        : null;\n    if (payload.checkOutTime !== undefined)\n      updateData.checkOutTime = payload.checkOutTime\n        ? new Date(payload.checkOutTime)\n        : null;\n    if (payload.breakDuration !== undefined)\n      updateData.breakDuration = payload.breakDuration;\n    if (payload.status !== undefined) updateData.status = payload.status;\n    if (payload.checkInMethod !== undefined)\n      updateData.checkInMethod = payload.checkInMethod ?? null;\n    if (payload.checkOutMethod !== undefined)\n      updateData.checkOutMethod = payload.checkOutMethod ?? null;\n    if (payload.checkInLocation !== undefined)\n      updateData.checkInLocation = payload.checkInLocation ?? null;\n    if (payload.checkOutLocation !== undefined)\n      updateData.checkOutLocation = payload.checkOutLocation ?? null;\n    if (payload.notes !== undefined) updateData.notes = payload.notes ?? null;\n\n    // Recalculate hours if times updated\n    if (\n      payload.checkInTime !== undefined ||\n      payload.checkOutTime !== undefined\n    ) {\n      const existing = await this.getTimesheetById(id);\n\n      if (existing) {\n        const checkIn =\n          updateData.checkInTime ??\n          (existing.checkInTime ? new Date(existing.checkInTime) : null);\n        const checkOut =\n          updateData.checkOutTime ??\n          (existing.checkOutTime ? new Date(existing.checkOutTime) : null);\n\n        if (checkIn && checkOut) {\n          const diffMs = checkOut.getTime() - checkIn.getTime();\n          const breakMins =\n            updateData.breakDuration ?? existing.breakDuration ?? 0;\n          const diffHours = diffMs / (1000 * 60 * 60) - breakMins / 60;\n\n          updateData.actualHours = Math.max(\n            0,\n            Math.round(diffHours * 100) / 100,\n          );\n          updateData.regularHours = updateData.actualHours;\n        }\n      }\n    }\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getTimesheetById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n    const normalizedPayload: Partial<TimesheetInput> = {};\n\n    if (payload.employeeId !== undefined) {\n      normalizedPayload.employeeId = String(payload.employeeId);\n    }\n    if (payload.rosterId !== undefined) {\n      normalizedPayload.rosterId =\n        payload.rosterId === null || payload.rosterId === \"\"\n          ? null\n          : String(payload.rosterId);\n    }\n    if (payload.workDate !== undefined) {\n      normalizedPayload.workDate = String(payload.workDate);\n    }\n    if (payload.shiftId !== undefined) {\n      normalizedPayload.shiftId =\n        payload.shiftId === null || payload.shiftId === \"\"\n          ? null\n          : String(payload.shiftId);\n    }\n    if (payload.checkInTime !== undefined) {\n      normalizedPayload.checkInTime =\n        payload.checkInTime === null || payload.checkInTime === \"\"\n          ? null\n          : String(payload.checkInTime);\n    }\n    if (payload.checkOutTime !== undefined) {\n      normalizedPayload.checkOutTime =\n        payload.checkOutTime === null || payload.checkOutTime === \"\"\n          ? null\n          : String(payload.checkOutTime);\n    }\n    if (payload.breakDuration !== undefined) {\n      normalizedPayload.breakDuration = Number(payload.breakDuration);\n    }\n    if (payload.status !== undefined) {\n      normalizedPayload.status = String(payload.status);\n    }\n    if (payload.checkInMethod !== undefined) {\n      normalizedPayload.checkInMethod =\n        payload.checkInMethod === null || payload.checkInMethod === \"\"\n          ? null\n          : String(payload.checkInMethod);\n    }\n    if (payload.checkOutMethod !== undefined) {\n      normalizedPayload.checkOutMethod =\n        payload.checkOutMethod === null || payload.checkOutMethod === \"\"\n          ? null\n          : String(payload.checkOutMethod);\n    }\n    if (payload.checkInLocation !== undefined) {\n      normalizedPayload.checkInLocation =\n        payload.checkInLocation === null || payload.checkInLocation === \"\"\n          ? null\n          : String(payload.checkInLocation);\n    }\n    if (payload.checkOutLocation !== undefined) {\n      normalizedPayload.checkOutLocation =\n        payload.checkOutLocation === null || payload.checkOutLocation === \"\"\n          ? null\n          : String(payload.checkOutLocation);\n    }\n    if (payload.notes !== undefined) {\n      normalizedPayload.notes =\n        payload.notes === null || payload.notes === \"\"\n          ? null\n          : String(payload.notes);\n    }\n\n    return this.updateTimesheet(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Timesheet/TimesheetViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_timesheets } from \"../../schemas\";\nimport { hrm_tb_employees } from \"../../schemas/hrm.employee\";\nimport { hrm_tb_shifts } from \"../../schemas/hrm.shift\";\n\nconst employee = alias(hrm_tb_employees, \"employee\");\nconst shift = alias(hrm_tb_shifts, \"shift\");\n\nexport interface TimesheetRow {\n  id: string;\n  employeeId: string;\n  employee?: {\n    id: string;\n    employeeCode?: string;\n    fullName?: unknown;\n  } | null;\n  workDate: string;\n  shiftId?: string | null;\n  shift?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  checkInTime?: number | null;\n  checkOutTime?: number | null;\n  actualHours?: number | null;\n  regularHours?: number | null;\n  overtimeHours?: number;\n  status: string;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass TimesheetViewListModel extends BaseViewListModel<\n  typeof hrm_tb_timesheets,\n  TimesheetRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: hrm_tb_timesheets.id, sort: true }],\n      [\"employeeId\", { column: hrm_tb_timesheets.employeeId, sort: true }],\n      [\"workDate\", { column: hrm_tb_timesheets.workDate, sort: true }],\n      [\"shiftId\", { column: hrm_tb_timesheets.shiftId, sort: true }],\n      [\"checkInTime\", { column: hrm_tb_timesheets.checkInTime, sort: true }],\n      [\"checkOutTime\", { column: hrm_tb_timesheets.checkOutTime, sort: true }],\n      [\"actualHours\", { column: hrm_tb_timesheets.actualHours, sort: true }],\n      [\"status\", { column: hrm_tb_timesheets.status, sort: true }],\n      [\"createdAt\", { column: hrm_tb_timesheets.createdAt, sort: true }],\n      [\"updatedAt\", { column: hrm_tb_timesheets.updatedAt, sort: true }],\n    ]);\n\n  constructor() {\n    super({ table: hrm_tb_timesheets });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"employeeCode\", (text: string) => ilike(employee.employeeCode, text)],\n      [\"fullName\", (text: string) => ilike(employee.fullName, text)],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): TimesheetRow => ({\n    id: row.id,\n    employeeId: row.employeeId,\n    employee: row.employeeId\n      ? {\n          id: row.employeeId,\n          employeeCode: row.employeeCode ?? undefined,\n          fullName: row.employeeFullName ?? undefined,\n        }\n      : null,\n    workDate: row.workDate,\n    shiftId: row.shiftId ?? undefined,\n    shift: row.shiftId\n      ? {\n          id: row.shiftId,\n          name: row.shiftName ?? undefined,\n        }\n      : null,\n    checkInTime: row.checkInTime?.getTime(),\n    checkOutTime: row.checkOutTime?.getTime(),\n    actualHours: row.actualHours ?? undefined,\n    regularHours: row.regularHours ?? undefined,\n    overtimeHours: row.overtimeHours ?? undefined,\n    status: row.status,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<TimesheetRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(employee, eq(this.table.employeeId, employee.id))\n        .leftJoin(shift, eq(this.table.shiftId, shift.id)),\n    );\n  };\n}\n\nexport default TimesheetViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Timesheet/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Workflow/WorkflowModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport { NewHrmTbWorkflow, hrm_tb_workflows } from \"../../schemas\";\n\nexport interface WorkflowStep {\n  step: number;\n  name: string;\n  approverType: \"manager\" | \"role\" | \"employee\"; // Who can approve\n  approverValue?: string; // Role ID or Employee ID\n  isRequired: boolean;\n  canDelegate: boolean;\n}\n\nexport interface WorkflowRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  workflowType: string;\n  steps?: WorkflowStep[];\n  isActive?: boolean;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface WorkflowInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  workflowType: string;\n  steps: WorkflowStep[];\n  isActive?: boolean;\n}\n\nexport default class WorkflowModel extends BaseModel<typeof hrm_tb_workflows> {\n  constructor() {\n    super(hrm_tb_workflows);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getWorkflowById = async (id: string): Promise<WorkflowRow | null> => {\n    const result = await this.db\n      .select()\n      .from(this.table)\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      workflowType: row.workflowType,\n      steps: (row.steps as WorkflowStep[]) ?? [],\n      isActive: row.isActive ?? undefined,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  getDataById = async (params: { id: string }): Promise<WorkflowRow | null> => {\n    return this.getWorkflowById(params.id);\n  };\n\n  createWorkflow = async (payload: WorkflowInput): Promise<WorkflowRow> => {\n    const now = new Date();\n    const insertData: NewHrmTbWorkflow = {\n      code: payload.code,\n      name: payload.name,\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      workflowType: payload.workflowType,\n      steps: payload.steps,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create workflow\");\n    }\n\n    const workflow = await this.getWorkflowById(created.id);\n\n    if (!workflow) {\n      throw new Error(\"Failed to load workflow after creation\");\n    }\n\n    return workflow;\n  };\n\n  updateWorkflow = async (\n    id: string,\n    payload: Partial<WorkflowInput>,\n  ): Promise<WorkflowRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined) updateData.name = payload.name;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.workflowType !== undefined)\n      updateData.workflowType = payload.workflowType;\n    if (payload.steps !== undefined) updateData.steps = payload.steps;\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getWorkflowById(id);\n  };\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<WorkflowInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.workflowType !== undefined) {\n      normalizedPayload.workflowType = String(payload.workflowType);\n    }\n    if (payload.steps !== undefined) {\n      normalizedPayload.steps = Array.isArray(payload.steps)\n        ? payload.steps\n        : [];\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateWorkflow(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/models/Workflow/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.audit-log.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":23,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport { jsonb, timestamp, uuid, varchar } from \"drizzle-orm/pg-core\";\n\nimport { mdlHrmSchema } from \"./schema\";\n\n// Audit Log - Nhật ký kiểm toán cho compliance\nexport const hrm_tb_audit_logs = mdlHrmSchema.table(\n  \"audit_logs\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    entityType: varchar(\"entity_type\", { length: 50 }).notNull(), // employee, contract, salary, etc.\n    entityId: uuid(\"entity_id\").notNull(),\n    action: varchar(\"action\", { length: 50 }).notNull(), // create, update, delete, view, approve, reject\n    performedBy: uuid(\"performed_by\").notNull(), // Employee ID\n    ipAddress: varchar(\"ip_address\", { length: 45 }),\n    userAgent: varchar(\"user_agent\", { length: 500 }),\n    changes: jsonb(\"changes\"), // Before/after values for updates\n    metadata: jsonb(\"metadata\"), // Additional context\n    createdAt: timestamp(\"created_at\", { withTimezone: true }).notNull(),\n  },\n  (table) => [],\n);\n\nexport type HrmTbAuditLog = typeof hrm_tb_audit_logs.$inferSelect;\nexport type NewHrmTbAuditLog = typeof hrm_tb_audit_logs.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.benefit-package.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.candidate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.certificate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.compliance-report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.contract.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.course.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.department.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.document.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":44,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  integer,\n  jsonb,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_employees } from \"./hrm.employee\";\nimport { mdlHrmSchema } from \"./schema\";\n\n// Documents - Tài liệu pháp lý và hồ sơ\nexport const hrm_tb_documents = mdlHrmSchema.table(\n  \"documents\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    documentNumber: varchar(\"document_number\", { length: 100 }).unique(),\n    documentType: varchar(\"document_type\", { length: 50 }).notNull(), // contract, amendment, certificate, id_card, etc.\n    title: jsonb(\"title\").notNull(), // LocaleDataType<string>\n    description: text(\"description\"), // Text description\n    employeeId: uuid(\"employee_id\").references(() => hrm_tb_employees.id, {\n      onDelete: \"cascade\",\n    }),\n    fileUrl: varchar(\"file_url\", { length: 500 }).notNull(),\n    fileSize: integer(\"file_size\"), // bytes\n    mimeType: varchar(\"mime_type\", { length: 100 }),\n    signedDate: timestamp(\"signed_date\", { withTimezone: true }),\n    expiryDate: timestamp(\"expiry_date\", { withTimezone: true }),\n    isDigitalSignature: boolean(\"is_digital_signature\")\n      .default(false)\n      .notNull(),\n    metadata: jsonb(\"metadata\"), // Additional document properties\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [],\n);\n\nexport type HrmTbDocument = typeof hrm_tb_documents.$inferSelect;\nexport type NewHrmTbDocument = typeof hrm_tb_documents.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.employee-benefit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.employee-history.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.employee-training.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.employee.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[63,63],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/schemas/base.user` import should occur after import of `drizzle-orm/pg-core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":64,"fix":{"range":[0,232],"text":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  date,\n  foreignKey,\n  index,\n  integer,\n  jsonb,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_users } from \"@base/server/schemas/base.user\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { base_tb_users } from \"@base/server/schemas/base.user\";\nimport { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  date,\n  foreignKey,\n  index,\n  integer,\n  jsonb,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { hrm_tb_departments } from \"./hrm.department\";\nimport { hrm_tb_positions } from \"./hrm.position\";\nimport { mdlHrmSchema } from \"./schema\";\n\n// Employees - Nhân viên\nexport const hrm_tb_employees = mdlHrmSchema.table(\n  \"employees\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n\n    // Link to base user (optional - not all employees have user accounts)\n    userId: uuid(\"user_id\").references(() => base_tb_users.id, {\n      onDelete: \"set null\",\n    }), // Optional: link to user account for authentication\n\n    employeeCode: varchar(\"employee_code\", { length: 100 }).notNull().unique(), // Mã nhân viên\n    firstName: varchar(\"first_name\", { length: 255 }),\n    lastName: varchar(\"last_name\", { length: 255 }),\n    fullName: jsonb(\"full_name\").notNull(), // LocaleDataType<string> - Full name\n    email: varchar(\"email\", { length: 255 }).unique(),\n    phone: varchar(\"phone\", { length: 50 }),\n    dateOfBirth: date(\"date_of_birth\"),\n    gender: varchar(\"gender\", { length: 20 }), // male, female, other\n    nationalId: varchar(\"national_id\", { length: 50 }), // CMND/CCCD\n    taxId: varchar(\"tax_id\", { length: 50 }), // Mã số thuế cá nhân\n    address: jsonb(\"address\"), // Address object\n    positionId: uuid(\"position_id\")\n      .references(() => hrm_tb_positions.id, { onDelete: \"restrict\" })\n      .notNull(),\n    departmentId: uuid(\"department_id\")\n      .references(() => hrm_tb_departments.id, { onDelete: \"restrict\" })\n      .notNull(),\n    managerId: uuid(\"manager_id\"), // Direct manager (employee ID)\n    employmentStatus: varchar(\"employment_status\", { length: 50 })\n      .notNull()\n      .default(\"active\"), // active, inactive, terminated, on_leave\n    employmentType: varchar(\"employment_type\", { length: 50 }), // full_time, part_time, contract, intern\n    hireDate: date(\"hire_date\").notNull(),\n    probationEndDate: date(\"probation_end_date\"), // Ngày kết thúc thử việc\n    baseSalary: integer(\"base_salary\"), // Lương cơ bản\n    currency: varchar(\"currency\", { length: 10 }).default(\"VND\"),\n    locationId: uuid(\"location_id\"), // Office/location\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [\n    foreignKey({\n      columns: [table.managerId],\n      foreignColumns: [table.id],\n    }),\n    index(\"employees_user_idx\").on(table.userId),\n    index(\"employees_code_idx\").on(table.employeeCode),\n    index(\"employees_email_idx\").on(table.email),\n    index(\"employees_position_idx\").on(table.positionId),\n    index(\"employees_department_idx\").on(table.departmentId),\n    index(\"employees_manager_idx\").on(table.managerId),\n    index(\"employees_status_idx\").on(table.employmentStatus),\n    index(\"employees_active_idx\").on(table.isActive),\n  ],\n);\n\nexport type HrmTbEmployee = typeof hrm_tb_employees.$inferSelect;\nexport type NewHrmTbEmployee = typeof hrm_tb_employees.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.goal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.interview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.job-requisition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.leave-balance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.leave-request.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.leave-type.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":37,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  integer,\n  jsonb,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { mdlHrmSchema } from \"./schema\";\n\n// Leave Types - Loại nghỉ phép\nexport const hrm_tb_leave_types = mdlHrmSchema.table(\n  \"leave_types\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 100 }).notNull().unique(),\n    name: jsonb(\"name\").notNull(), // LocaleDataType<string>\n    description: text(\"description\"), // Text description\n    accrualType: varchar(\"accrual_type\", { length: 50 }).notNull(), // monthly, yearly, none\n    accrualRate: integer(\"accrual_rate\"), // Days per period (e.g., 1.25 days/month)\n    maxAccrual: integer(\"max_accrual\"), // Maximum days that can be accrued (null = unlimited)\n    carryForward: boolean(\"carry_forward\").default(false).notNull(), // Can carry forward to next year\n    maxCarryForward: integer(\"max_carry_forward\"), // Max days to carry forward\n    requiresApproval: boolean(\"requires_approval\").default(true).notNull(),\n    isPaid: boolean(\"is_paid\").default(true).notNull(),\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [],\n);\n\nexport type HrmTbLeaveType = typeof hrm_tb_leave_types.$inferSelect;\nexport type NewHrmTbLeaveType = typeof hrm_tb_leave_types.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.notification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.offboarding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.offer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.onboarding-checklist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.payroll-period.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.payroll-rule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.payroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.performance-review.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.roster.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.shift.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.timesheet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/hrm.workflow.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":32,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":57,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'table' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":82,"column":4,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  boolean,\n  integer,\n  jsonb,\n  text,\n  timestamp,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nimport { mdlHrmSchema } from \"./schema\";\n\n// Workflow Definitions - Định nghĩa quy trình\nexport const hrm_tb_workflows = mdlHrmSchema.table(\n  \"workflows\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 100 }).notNull().unique(),\n    name: jsonb(\"name\").notNull(), // LocaleDataType<string>\n    description: text(\"description\"), // Text description\n    workflowType: varchar(\"workflow_type\", { length: 50 }).notNull(), // leave_request, overtime, salary_change, contract_approval, etc.\n    steps: jsonb(\"steps\").notNull(), // Array of workflow steps with approvers\n    isActive: boolean(\"is_active\").default(true).notNull(),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }),\n    createdBy: varchar(\"created_by\", { length: 36 }),\n    updatedBy: varchar(\"updated_by\", { length: 36 }),\n  },\n  (table) => [],\n);\n\nexport type HrmTbWorkflow = typeof hrm_tb_workflows.$inferSelect;\nexport type NewHrmTbWorkflow = typeof hrm_tb_workflows.$inferInsert;\n\n// Workflow Instances - Phiên bản quy trình đang chạy\nexport const hrm_tb_workflows_instance = mdlHrmSchema.table(\n  \"workflow_instances\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    workflowId: uuid(\"workflow_id\")\n      .references(() => hrm_tb_workflows.id, { onDelete: \"restrict\" })\n      .notNull(),\n    entityType: varchar(\"entity_type\", { length: 50 }).notNull(), // leave, overtime, contract, etc.\n    entityId: uuid(\"entity_id\").notNull(), // ID of the entity being processed\n    currentStep: integer(\"current_step\").default(0).notNull(),\n    status: varchar(\"status\", { length: 50 }).notNull().default(\"pending\"), // pending, approved, rejected, cancelled\n    initiatedBy: uuid(\"initiated_by\").notNull(), // Employee ID\n    completedAt: timestamp(\"completed_at\", { withTimezone: true }),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true }),\n  },\n  (table) => [],\n);\n\nexport type HrmTbWorkflowInstance =\n  typeof hrm_tb_workflows_instance.$inferSelect;\nexport type NewHrmTbWorkflowInstance =\n  typeof hrm_tb_workflows_instance.$inferInsert;\n\n// Workflow Approvals - Phê duyệt từng bước\nexport const hrm_tb_workflows_approval = mdlHrmSchema.table(\n  \"workflow_approvals\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    instanceId: uuid(\"instance_id\")\n      .references(() => hrm_tb_workflows_instance.id, { onDelete: \"cascade\" })\n      .notNull(),\n    step: integer(\"step\").notNull(),\n    approverId: uuid(\"approver_id\").notNull(), // Employee ID\n    status: varchar(\"status\", { length: 50 }).notNull().default(\"pending\"), // pending, approved, rejected\n    comments: varchar(\"comments\", { length: 1000 }),\n    approvedAt: timestamp(\"approved_at\", { withTimezone: true }),\n    createdAt: timestamp(\"created_at\", { withTimezone: true }),\n  },\n  (table) => [],\n);\n\nexport type HrmTbWorkflowApproval =\n  typeof hrm_tb_workflows_approval.$inferSelect;\nexport type NewHrmTbWorkflowApproval =\n  typeof hrm_tb_workflows_approval.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/hrm/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Category/ProductCategoryForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":54,"fix":{"range":[208,208],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `valibot`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":54,"fix":{"range":[155,674],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Switch, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Save } from \"lucide-react\";\nimport { useEffect, useMemo } from \"react\";\nimport { Controller, useForm } from \"react-hook-form\";\nimport {\n  boolean,\n  minLength,\n  number,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport { IBaseInput } from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { Resolver, SubmitHandler } from \"react-hook-form\";\nimport type { ProductCategoryRow } from \"../../interface/ProductCategory\";\n\nimport { IBaseInput } from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Switch, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Save } from \"lucide-react\";\nimport { useEffect, useMemo } from \"react\";\nimport { Controller, useForm } from \"react-hook-form\";\nimport {\n  boolean,\n  minLength,\n  number,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\n\nimport ProductCategoryService from \"../../services/ProductCategoryService\";\n\nexport type ProductCategoryFormValues = {\n  name: string;\n  code: string;\n  description?: string;\n  parentId?: string;\n  level?: number;\n  isActive: boolean;\n};\n\ninterface ProductCategoryFormProps {\n  title: string;\n  subtitle?: string;\n  submitLabel?: string;\n  secondarySubmitLabel?: string;\n  initialValues?: ProductCategoryFormValues;\n  loading?: boolean;\n  error?: string | null;\n  onSubmit: (values: ProductCategoryFormValues) => Promise<void> | void;\n  onSubmitAndContinue?: (\n    values: ProductCategoryFormValues,\n  ) => Promise<void> | void;\n  onCancel?: () => void;\n  categoryId?: string;\n}\n\nconst defaultValues: ProductCategoryFormValues = {\n  name: \"\",\n  code: \"\",\n  description: \"\",\n  parentId: \"\",\n  level: 1,\n  isActive: true,\n};\n\nconst MAX_LEVEL = 5;\n\nconst getDisplayName = (node: ProductCategoryRow) => {\n  if (!node) return \"\";\n  const { name, code, id } = node;\n\n  if (typeof name === \"string\") return name;\n  if (name && typeof name === \"object\") {\n    const record = name as Record<string, string>;\n\n    return record.en ?? record.vi ?? code ?? id ?? \"\";\n  }\n\n  return code ?? id ?? \"\";\n};\n\nconst buildHierarchyOptions = (\n  categories: ProductCategoryRow[],\n  excludeId?: string,\n): { id: string; label: string; level: number }[] => {\n  const grouped = new Map<string | null, ProductCategoryRow[]>();\n\n  categories.forEach((category) => {\n    if (excludeId && category.id === excludeId) {\n      return;\n    }\n\n    const parentKey = category.parent?.id ?? null;\n    const siblings = grouped.get(parentKey) ?? [];\n\n    siblings.push(category);\n    grouped.set(parentKey, siblings);\n  });\n\n  const results: { id: string; label: string; level: number }[] = [];\n\n  const traverse = (parentKey: string | null, depth: number) => {\n    const items = grouped.get(parentKey);\n\n    if (!items) {\n      return;\n    }\n\n    items.forEach((item) => {\n      const prefix = depth > 1 ? `${\"―\".repeat(depth - 1)} ` : \"\";\n\n      results.push({\n        id: item.id,\n        label: `${prefix}${getDisplayName(item)}`,\n        level: depth,\n      });\n      traverse(item.id, depth + 1);\n    });\n  };\n\n  traverse(null, 1);\n\n  return results;\n};\n\nconst productCategorySchema = object({\n  name: pipe(string(), trim(), minLength(1, \"Name is required\")),\n  code: pipe(string(), trim(), minLength(1, \"Code is required\")),\n  description: optional(pipe(string(), trim())),\n  parentId: optional(pipe(string(), trim())),\n  level: optional(number()),\n  isActive: boolean(),\n});\n\nconst normalizeValues = (\n  values?: ProductCategoryFormValues,\n): ProductCategoryFormValues => ({\n  ...defaultValues,\n  ...values,\n  level: values?.level ?? defaultValues.level,\n});\n\nexport default function ProductCategoryForm({\n  title,\n  subtitle,\n  submitLabel = \"Save\",\n  secondarySubmitLabel = \"Save & add another\",\n  initialValues,\n  loading = false,\n  error,\n  onSubmit,\n  onSubmitAndContinue,\n  onCancel,\n  categoryId,\n}: ProductCategoryFormProps) {\n  const categoriesQuery = useQuery({\n    queryKey: [\"product-category-tree\"],\n    queryFn: () => ProductCategoryService.fetchTree(),\n  });\n\n  const normalizedDefaults = normalizeValues(initialValues);\n\n  const {\n    control,\n    handleSubmit,\n    reset,\n    watch,\n    setValue,\n    setError,\n    clearErrors,\n    formState: { errors, isSubmitting },\n  } = useForm<ProductCategoryFormValues>({\n    defaultValues: normalizedDefaults,\n    resolver: valibotResolver(\n      productCategorySchema,\n    ) as Resolver<ProductCategoryFormValues>,\n  });\n\n  useEffect(() => {\n    reset(normalizeValues(initialValues));\n  }, [initialValues, reset]);\n\n  const categoryNodes = useMemo(() => {\n    if (!categoriesQuery.data) return [];\n\n    return buildHierarchyOptions(categoriesQuery.data, categoryId);\n  }, [categoriesQuery.data, categoryId]);\n\n  const parentId = watch(\"parentId\");\n  const computedLevel = useMemo(() => {\n    if (!parentId) return 1;\n    const parentNode = categoryNodes.find((node) => node.id === parentId);\n\n    return parentNode ? parentNode.level + 1 : 1;\n  }, [parentId, categoryNodes]);\n\n  const isLevelValid = computedLevel <= MAX_LEVEL;\n\n  useEffect(() => {\n    setValue(\"level\", computedLevel, { shouldDirty: true });\n    if (isLevelValid) {\n      clearErrors(\"parentId\");\n    } else {\n      setError(\"parentId\", {\n        type: \"validate\",\n        message: `Maximum depth is ${MAX_LEVEL}. Please choose a higher-level parent.`,\n      });\n    }\n  }, [computedLevel, isLevelValid, setValue, setError, clearErrors]);\n\n  const levelValue = isLevelValid ? computedLevel : `>${MAX_LEVEL}`;\n\n  const handleValidSubmit: SubmitHandler<ProductCategoryFormValues> = async (\n    formValues,\n  ) => {\n    if (!isLevelValid) {\n      return;\n    }\n\n    const payload: ProductCategoryFormValues = {\n      ...formValues,\n      name: formValues.name.trim(),\n      code: formValues.code.trim(),\n      description: formValues.description?.trim() || undefined,\n      parentId: formValues.parentId?.trim() || undefined,\n      level: computedLevel,\n    };\n\n    await onSubmit(payload);\n  };\n\n  const handleValidSubmitAndContinue: SubmitHandler<\n    ProductCategoryFormValues\n  > = async (formValues) => {\n    if (!onSubmitAndContinue || !isLevelValid) {\n      return;\n    }\n\n    const payload: ProductCategoryFormValues = {\n      ...formValues,\n      name: formValues.name.trim(),\n      code: formValues.code.trim(),\n      description: formValues.description?.trim() || undefined,\n      parentId: formValues.parentId?.trim() || undefined,\n      level: computedLevel,\n    };\n\n    await onSubmitAndContinue(payload);\n    reset(defaultValues);\n  };\n\n  const onSubmitForm = handleSubmit(handleValidSubmit);\n\n  const onSubmitAndContinueForm = onSubmitAndContinue\n    ? handleSubmit(handleValidSubmitAndContinue)\n    : undefined;\n\n  const isBusy = loading || isSubmitting;\n\n  return (\n    <form className=\"flex flex-col gap-4\" onSubmit={onSubmitForm}>\n      <Card>\n        <CardBody className=\"space-y-4\">\n          <div>\n            <h1 className=\"text-xl font-semibold\">{title}</h1>\n            {subtitle ? (\n              <p className=\"text-default-500 text-small\">{subtitle}</p>\n            ) : null}\n            {error ? (\n              <p className=\"text-small text-danger-500\">{error}</p>\n            ) : null}\n          </div>\n\n          <Controller\n            control={control}\n            name=\"name\"\n            render={({ field }) => (\n              <IBaseInput\n                {...field}\n                isRequired\n                errorMessage={errors.name?.message}\n                isDisabled={isBusy}\n                isInvalid={Boolean(errors.name)}\n                label=\"Name\"\n                placeholder=\"Electronics\"\n                value={field.value}\n                variant=\"bordered\"\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n\n          <Controller\n            control={control}\n            name=\"code\"\n            render={({ field }) => (\n              <IBaseInput\n                {...field}\n                isRequired\n                errorMessage={errors.code?.message}\n                isDisabled={isBusy}\n                isInvalid={Boolean(errors.code)}\n                label=\"Code\"\n                placeholder=\"CAT-001\"\n                value={field.value}\n                variant=\"bordered\"\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n\n          <div className=\"flex flex-col gap-2\">\n            <p className=\"text-xs uppercase text-default-400\">Parent</p>\n            {categoriesQuery.isLoading ? (\n              <p className=\"text-sm text-default-500\">Loading categories...</p>\n            ) : categoriesQuery.isError ? (\n              <p className=\"text-sm text-danger-500\">\n                {categoriesQuery.error instanceof Error\n                  ? categoriesQuery.error.message\n                  : \"Failed to load categories\"}\n              </p>\n            ) : (\n              <Controller\n                control={control}\n                name=\"parentId\"\n                render={({ field }) => (\n                  <select\n                    className=\"rounded-medium border border-default-200 px-3 py-2 text-sm outline-none focus:border-primary\"\n                    disabled={isBusy}\n                    value={field.value ?? \"\"}\n                    onChange={(event) =>\n                      field.onChange(event.target.value || undefined)\n                    }\n                  >\n                    <option value=\"\">— Root (level 1) —</option>\n                    {categoryNodes.map((node) => (\n                      <option key={node.id} value={node.id}>\n                        {node.label}\n                      </option>\n                    ))}\n                  </select>\n                )}\n              />\n            )}\n            {errors.parentId ? (\n              <p className=\"text-xs text-danger-500\">\n                {errors.parentId.message}\n              </p>\n            ) : null}\n          </div>\n\n          <div className=\"flex flex-col gap-1\">\n            <p className=\"text-xs uppercase text-default-400\">Computed level</p>\n            <p className=\"text-sm text-default-600\">{levelValue}</p>\n          </div>\n\n          <Controller\n            control={control}\n            name=\"description\"\n            render={({ field }) => (\n              <Textarea\n                {...field}\n                isDisabled={isBusy}\n                label=\"Description\"\n                minRows={3}\n                placeholder=\"Write a short description\"\n                value={field.value ?? \"\"}\n                variant=\"bordered\"\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n\n          <Controller\n            control={control}\n            name=\"isActive\"\n            render={({ field }) => (\n              <Switch\n                isDisabled={isBusy}\n                isSelected={field.value}\n                onValueChange={field.onChange}\n              >\n                Active\n              </Switch>\n            )}\n          />\n\n          <div className=\"flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-end\">\n            {onCancel ? (\n              <Button\n                isDisabled={isBusy}\n                size=\"sm\"\n                variant=\"light\"\n                onPress={onCancel}\n              >\n                Cancel\n              </Button>\n            ) : null}\n\n            {onSubmitAndContinue ? (\n              <Button\n                isDisabled={isBusy || !isLevelValid}\n                size=\"sm\"\n                type=\"button\"\n                variant=\"bordered\"\n                onPress={\n                  onSubmitAndContinueForm\n                    ? async () => {\n                        await onSubmitAndContinueForm();\n                      }\n                    : undefined\n                }\n              >\n                {secondarySubmitLabel}\n              </Button>\n            ) : null}\n\n            <Button\n              color=\"primary\"\n              endContent={<Save size={16} />}\n              isDisabled={!isLevelValid}\n              isLoading={isBusy}\n              size=\"sm\"\n              type=\"submit\"\n            >\n              {submitLabel}\n            </Button>\n          </div>\n        </CardBody>\n      </Card>\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/MasterTab.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":34,"fix":{"range":[65,522],"text":"import { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Checkbox, CheckboxGroup } from \"@heroui/react\";\nimport { HelpCircle } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  IBaseTextarea,\n  IBaseTooltip,\n  IBaseUploadImageTiny,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":72,"fix":{"range":[343,343],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `react`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":72,"fix":{"range":[272,522],"text":"import { Checkbox, CheckboxGroup } from \"@heroui/react\";\nimport { HelpCircle } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLocalizedText' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":59,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"\"use client\";\n\nimport type { MasterFieldValue } from \"./types\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  IBaseTextarea,\n  IBaseTooltip,\n  IBaseUploadImageTiny,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Checkbox, CheckboxGroup } from \"@heroui/react\";\nimport { HelpCircle } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport {\n  ProductMasterFeatures,\n  ProductMasterType,\n} from \"../../../interface/Product\";\nimport {\n  FORBIDDEN_FEATURES_BY_TYPE,\n  REQUIRED_FEATURES_BY_TYPE,\n} from \"../../../utils/product-features-validator\";\n\ntype MasterTabProps = {\n  value: MasterFieldValue;\n  categoryOptions: SelectItemOption[];\n  featureOptions: { value: string; label: string }[];\n  disabledFeatures?: Set<string>;\n  errors?: {\n    name?: { en?: { message?: string } };\n    code?: { message?: string };\n    categoryId?: { message?: string };\n    type?: { message?: string };\n    images?: { message?: string };\n  };\n  isBusy: boolean;\n  categoryQueryLoading: boolean;\n  onUpdate: (updater: (current: MasterFieldValue) => MasterFieldValue) => void;\n};\n\nexport default function MasterTab({\n  value,\n  categoryOptions,\n  featureOptions,\n  disabledFeatures = new Set(),\n  errors,\n  isBusy,\n  categoryQueryLoading,\n  onUpdate,\n}: MasterTabProps) {\n  const t = useTranslations(\"common\");\n  const tProduct = useTranslations(\"mdl-product\");\n  const getLocalizedText = useLocalizedText();\n\n  // Determine which features are required based on product type\n  const requiredFeatures = useMemo(() => {\n    if (!value.type) return new Set<ProductMasterFeatures>();\n    const required =\n      REQUIRED_FEATURES_BY_TYPE[value.type as ProductMasterType] || [];\n\n    return new Set(required);\n  }, [value.type]);\n\n  // Determine which features are forbidden based on product type\n  const forbiddenFeatures = useMemo(() => {\n    if (!value.type) return new Set<ProductMasterFeatures>();\n    const forbidden =\n      FORBIDDEN_FEATURES_BY_TYPE[value.type as ProductMasterType] || [];\n\n    return new Set(forbidden);\n  }, [value.type]);\n\n  // Filter out forbidden features\n  const allowedFeatureOptions = useMemo(() => {\n    return featureOptions.filter(\n      (feature) =>\n        !forbiddenFeatures.has(feature.value as ProductMasterFeatures),\n    );\n  }, [featureOptions, forbiddenFeatures]);\n\n  // Check if a feature is required\n  const isFeatureRequired = (featureKey: ProductMasterFeatures) => {\n    return requiredFeatures.has(featureKey);\n  };\n\n  return (\n    <div className=\"flex flex-col gap-4 pt-4\">\n      <IBaseInputMultipleLang\n        isRequired\n        errorMessage={errors?.name?.en?.message}\n        isDisabled={isBusy}\n        isInvalid={Boolean(errors?.name?.en)}\n        label={t(\"name\")}\n        value={value.name}\n        onValueChange={(langs) =>\n          onUpdate((current) => ({\n            ...current,\n            name: langs as MasterFieldValue[\"name\"],\n          }))\n        }\n      />\n\n      <div className=\"grid gap-4 md:grid-cols-2 items-start\">\n        <IBaseInput\n          isRequired\n          errorMessage={errors?.code?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(errors?.code)}\n          label={t(\"code\")}\n          value={value.code ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, code: next }))\n          }\n        />\n\n        <IBaseSingleSelectAsync\n          callWhen=\"mount\"\n          errorMessage={errors?.type?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(errors?.type)}\n          label={tProduct(\"productType\")}\n          model=\"product-type.dropdown\"\n          selectedKey={value.type || undefined}\n          onSelectionChange={(key) => {\n            const next = (key as ProductMasterType) || ProductMasterType.GOODS;\n\n            onUpdate((current) => ({ ...current, type: next }));\n          }}\n        />\n      </div>\n\n      <div className=\"grid gap-4 md:grid-cols-2 items-start\">\n        <IBaseSingleSelect\n          errorMessage={errors?.categoryId?.message}\n          isDisabled={isBusy || categoryQueryLoading}\n          isInvalid={Boolean(errors?.categoryId)}\n          isLoading={categoryQueryLoading}\n          items={categoryOptions}\n          label={t(\"category\")}\n          selectedKey={value.categoryId}\n          onSelectionChange={(key) => {\n            onUpdate((current) => ({\n              ...current,\n              categoryId: key || undefined,\n            }));\n          }}\n        />\n\n        <IBaseInput\n          isDisabled={isBusy}\n          label={t(\"brand\")}\n          value={value.brand ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, brand: next }))\n          }\n        />\n      </div>\n\n      <div className=\"flex flex-col gap-2\">\n        <div className=\"flex items-center gap-2\">\n          <label className=\"text-sm font-medium text-foreground\">\n            {tProduct(\"productFeatures\")}\n          </label>\n          <IBaseTooltip\n            content={tProduct(\"productFeaturesTooltip\")}\n            placement=\"top\"\n          >\n            <HelpCircle\n              aria-label=\"Thông tin về tính năng sản phẩm\"\n              className=\"text-default-400 cursor-help\"\n              size={16}\n            />\n          </IBaseTooltip>\n        </div>\n        <CheckboxGroup\n          classNames={{ wrapper: \"flex flex-wrap gap-3\" }}\n          isDisabled={isBusy}\n          orientation=\"horizontal\"\n          value={allowedFeatureOptions\n            .filter(\n              (feature) =>\n                value.features?.[feature.value as ProductMasterFeatures],\n            )\n            .map((feature) => feature.value as ProductMasterFeatures)}\n          onChange={(selected) => {\n            const selectedSet = new Set(selected as string[]);\n\n            onUpdate((current) => ({\n              ...current,\n              features: featureOptions.reduce(\n                (acc, feature) => {\n                  // If feature is forbidden, set to false and don't allow changes\n                  if (\n                    forbiddenFeatures.has(\n                      feature.value as ProductMasterFeatures,\n                    )\n                  ) {\n                    acc[feature.value as ProductMasterFeatures] = false;\n\n                    return acc;\n                  }\n                  // If feature is disabled, keep it false\n                  // If feature is required, keep it true (prevent unchecking)\n                  acc[feature.value as ProductMasterFeatures] =\n                    disabledFeatures.has(feature.value as ProductMasterFeatures)\n                      ? false\n                      : isFeatureRequired(\n                            feature.value as ProductMasterFeatures,\n                          )\n                        ? true\n                        : selectedSet.has(\n                            feature.value as ProductMasterFeatures,\n                          );\n\n                  return acc;\n                },\n                {} as Record<ProductMasterFeatures, boolean>,\n              ),\n            }));\n          }}\n        >\n          {allowedFeatureOptions.map((feature) => {\n            const isRequired = isFeatureRequired(\n              feature.value as ProductMasterFeatures,\n            );\n\n            return (\n              <Checkbox\n                key={feature.value}\n                classNames={{\n                  label: isRequired ? \"text-danger font-medium\" : \"\",\n                }}\n                color={isRequired ? \"danger\" : undefined}\n                isDisabled={\n                  isBusy ||\n                  disabledFeatures.has(\n                    feature.value as ProductMasterFeatures,\n                  ) ||\n                  isRequired\n                }\n                value={feature.value as ProductMasterFeatures}\n              >\n                {feature.label}\n              </Checkbox>\n            );\n          })}\n        </CheckboxGroup>\n      </div>\n\n      <IBaseTextarea\n        isDisabled={isBusy}\n        label={t(\"description\")}\n        value={value.description ?? \"\"}\n        onValueChange={(next) =>\n          onUpdate((current) => ({ ...current, description: next }))\n        }\n      />\n\n      <IBaseUploadImageTiny\n        required\n        error={errors?.images?.message}\n        isDisabled={isBusy}\n        label={tProduct(\"images\")}\n        maxCount={10}\n        maxSize={5 * 1024 * 1024} // 5MB\n        values={value.images ?? []}\n        onChange={(images) => onUpdate((current) => ({ ...current, images }))}\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/ProductFormGuideModal.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[240,240],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@tanstack/react-query` import should occur before import of `@base/client/components`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":50,"fix":{"range":[15,291],"text":"import { useQuery } from \"@tanstack/react-query\";\nimport { MarkdownContent } from \"@base/client/components\";\nimport guidelineService from \"@base/client/services/GuidelineService\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalHeader,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`lucide-react` import should occur before import of `@base/client/components`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":52,"fix":{"range":[15,343],"text":"import { HelpCircle, Loader2 } from \"lucide-react\";\nimport { MarkdownContent } from \"@base/client/components\";\nimport guidelineService from \"@base/client/services/GuidelineService\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalHeader,\n} from \"@base/client/components\";\nimport { useQuery } from \"@tanstack/react-query\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":45,"fix":{"range":[15,388],"text":"import { useTranslations } from \"next-intl\";\nimport { MarkdownContent } from \"@base/client/components\";\nimport guidelineService from \"@base/client/services/GuidelineService\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalHeader,\n} from \"@base/client/components\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { HelpCircle, Loader2 } from \"lucide-react\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { MarkdownContent } from \"@base/client/components\";\nimport guidelineService from \"@base/client/services/GuidelineService\";\nimport {\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalHeader,\n} from \"@base/client/components\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { HelpCircle, Loader2 } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\n\ninterface ProductFormGuideModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nexport default function ProductFormGuideModal({\n  isOpen,\n  onClose,\n}: ProductFormGuideModalProps) {\n  const t = useTranslations(\"guidelines\");\n  const {\n    data: guideContent,\n    isLoading,\n    error,\n  } = useQuery({\n    queryKey: [\"guideline\", \"product-information-needed\"],\n    queryFn: () => guidelineService.getByKey(\"product-information-needed\"),\n    enabled: isOpen, // Only fetch when modal is open\n    staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n  });\n\n  return (\n    <Modal\n      isOpen={isOpen}\n      placement=\"center\"\n      scrollBehavior=\"inside\"\n      size=\"5xl\"\n      onClose={onClose}\n    >\n      <ModalContent className=\"max-h-[90vh]\">\n        <>\n          <ModalHeader className=\"flex items-center gap-2 pb-3\">\n            <HelpCircle size={18} />\n            <span className=\"text-base\">{t(\"title\")}</span>\n          </ModalHeader>\n          <ModalBody className=\"pb-4 pt-2\">\n            {isLoading ? (\n              <div className=\"flex items-center justify-center py-8\">\n                <Loader2 className=\"h-6 w-6 animate-spin text-default-500\" />\n              </div>\n            ) : error ? (\n              <div className=\"py-4 text-center text-sm text-default-500\">\n                {t(\"error\")}\n              </div>\n            ) : guideContent ? (\n              <MarkdownContent content={guideContent} />\n            ) : (\n              <div className=\"py-4 text-center text-sm text-default-500\">\n                {t(\"notFound\")}\n              </div>\n            )}\n          </ModalBody>\n        </>\n      </ModalContent>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/UomSection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":34,"fix":{"range":[291,291],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `uuidv7`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":34,"fix":{"range":[15,613],"text":"import { Button } from \"@heroui/button\";\nimport { addToast } from \"@heroui/react\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useFormContext, useWatch } from \"react-hook-form\";\nimport { uuidv7 } from \"uuidv7\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTable,\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  SelectItemOption,\n  type DataTableColumnDefinition,\n} from \"@base/client/components\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentUom' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":88,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTable,\n  IBaseInputNumber,\n  IBaseSingleSelect,\n  IBaseSingleSelectAsync,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  SelectItemOption,\n  type DataTableColumnDefinition,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { addToast } from \"@heroui/react\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useFormContext, useWatch } from \"react-hook-form\";\nimport { uuidv7 } from \"uuidv7\";\n\nimport {\n  ProductMasterFeatures,\n  ProductMasterFeaturesType,\n} from \"../../../interface/Product\";\n\nimport { UomConversions } from \"./types\";\n\ntype UomSectionProps = {\n  variantIndex: number;\n  masterFeatures: Record<ProductMasterFeaturesType, boolean>;\n  isBusy: boolean;\n  error?: { message?: string };\n};\n\nexport default function UomSection({\n  variantIndex,\n  masterFeatures,\n  isBusy,\n  error,\n}: UomSectionProps) {\n  const tProduct = useTranslations(\"mdl-product\");\n  const tProductForm = useTranslations(\"mdl-product.product-create\");\n  const t = useTranslations(\"common\");\n\n  const { setValue } = useFormContext();\n\n  // Watch form values directly - now using objects {id, name}\n  const baseUom = useWatch({ name: `variants.${variantIndex}.baseUom` }) as\n    | { id: string; name: string }\n    | undefined;\n  const saleUom = useWatch({\n    name: `variants.${variantIndex}.saleUom`,\n  }) as { id: string; name: string } | undefined;\n  const purchaseUom = useWatch({\n    name: `variants.${variantIndex}.purchaseUom`,\n  }) as { id: string; name: string } | undefined;\n  const manufacturingUom = useWatch({\n    name: `variants.${variantIndex}.manufacturingUom`,\n  }) as { id: string; name: string } | undefined;\n  const uomConversions = useWatch({\n    name: `variants.${variantIndex}.uomConversions`,\n  });\n\n  // Extract IDs for backward compatibility\n  const baseUomId = baseUom?.id;\n  const saleUomIdProp = saleUom?.id;\n  const purchaseUomIdProp = purchaseUom?.id;\n  const manufacturingUomIdProp = manufacturingUom?.id;\n\n  const [deleteConfirmModal, setDeleteConfirmModal] = useState<{\n    isOpen: boolean;\n    uuid?: string;\n    uomName?: string;\n  }>({ isOpen: false });\n\n  // Check if UOM is duplicate based on type\n  const isDuplicateUom = useCallback(\n    (\n      uomId: string,\n      currentUuid: string,\n      currentType: ProductMasterFeaturesType | \"other\",\n      baseUomId?: string,\n    ): { isDuplicate: boolean; duplicateLabel?: string } => {\n      const currentUom = uomConversions.find(\n        (uom: UomConversions) => uom.uuid === currentUuid,\n      );\n\n      // If current type is \"other\", check against everything\n      if (currentType === \"other\") {\n        // Check against baseUomId\n        if (baseUomId && uomId === baseUomId) {\n          return { isDuplicate: true, duplicateLabel: \"Base UOM\" };\n        }\n\n        // Check against all other UOMs (sale, purchase, manufacture, and other \"other\" UOMs)\n        const duplicate = uomConversions.find(\n          (uom: UomConversions) =>\n            uom.uomId === uomId && uom.uuid !== currentUuid,\n        );\n\n        if (duplicate) {\n          return { isDuplicate: true, duplicateLabel: duplicate.label };\n        }\n      } else {\n        // If current type is sale, purchase, or manufacture\n        // Only check against \"other\" UOMs and baseUomId\n        // Allow duplication with other sale/purchase/manufacture UOMs\n\n        // Check against baseUomId\n        if (baseUomId && uomId === baseUomId) {\n          return { isDuplicate: true, duplicateLabel: \"Base UOM\" };\n        }\n\n        // Check only against \"other\" type UOMs\n        const duplicateOther = uomConversions.find(\n          (uom: UomConversions) =>\n            uom.type === \"other\" &&\n            uom.uomId === uomId &&\n            uom.uuid !== currentUuid,\n        );\n\n        if (duplicateOther) {\n          return { isDuplicate: true, duplicateLabel: duplicateOther.label };\n        }\n      }\n\n      return { isDuplicate: false };\n    },\n    [uomConversions],\n  );\n\n  // Update UOM conversions in form\n  const updateUomConversions = useCallback(\n    (updater: (prev: UomConversions[]) => UomConversions[]) => {\n      const current = uomConversions || [];\n      const updated = updater(current);\n\n      setValue(`variants.${variantIndex}.uomConversions`, updated, {\n        shouldDirty: true,\n        shouldValidate: false,\n      });\n    },\n    [uomConversions, variantIndex, setValue],\n  );\n\n  // Build available UOM options (baseUom + uomConversions)\n  const availableUomOptions = useMemo<SelectItemOption[]>(() => {\n    if (!baseUomId) return [];\n\n    const options = [\n      {\n        label: baseUom.name,\n        value: baseUom.id,\n      },\n      ...uomConversions\n        .filter((uom: UomConversions) => uom.uomId !== null)\n        .map((uom: UomConversions) => ({\n          label: uom.label,\n          value: uom.uuid,\n        })),\n    ];\n\n    return options;\n  }, [baseUom, uomConversions]);\n\n  // Check if can add more UOMs\n  const canAddOtherUom = useMemo(() => {\n    const MAX_OTHER_UOMS = 9;\n    const uomConversionsCount = uomConversions.filter(\n      (uom: UomConversions) => uom.type === \"other\",\n    ).length;\n\n    return uomConversionsCount < MAX_OTHER_UOMS;\n  }, [uomConversions]);\n\n  // Handle UOM selection\n  const handleSelectUomConversion = useCallback(\n    (\n      uuid: string,\n      selectedUomId: string | null,\n      selectedUomName: string | null,\n    ) => {\n      if (!selectedUomId) {\n        return;\n      }\n\n      const currentUom = uomConversions.find(\n        (uom: UomConversions) => uom.uuid === uuid,\n      );\n\n      if (!currentUom) {\n        return;\n      }\n\n      // Check for duplicates\n      const duplicateCheck = isDuplicateUom(\n        selectedUomId,\n        uuid,\n        currentUom.type,\n        baseUomId,\n      );\n\n      if (duplicateCheck.isDuplicate) {\n        addToast({\n          title: tProductForm(\"duplicateUom\"),\n          description:\n            tProductForm(\"duplicateUomDescription\") +\n            (selectedUomName ? ` (${selectedUomName})` : \"\"),\n          color: \"warning\",\n        });\n\n        return;\n      }\n      // Update UOM\n      updateUomConversions((prev) =>\n        prev.map((item) =>\n          item.uuid === uuid\n            ? {\n                ...item,\n                uomId: selectedUomId,\n                uomName: selectedUomName || \"\",\n              }\n            : item,\n        ),\n      );\n    },\n    [\n      baseUomId,\n      uomConversions,\n      isDuplicateUom,\n      updateUomConversions,\n      tProductForm,\n    ],\n  );\n\n  // Handle delete\n  const handleDeleteUom = useCallback(\n    (uuid: string) => {\n      const uom = uomConversions.find((u: UomConversions) => u.uuid === uuid);\n\n      if (uom) {\n        setDeleteConfirmModal({\n          isOpen: true,\n          uuid,\n          uomName: uom.uomName || uom.label,\n        });\n      }\n    },\n    [uomConversions],\n  );\n\n  const deleteUuid = deleteConfirmModal.uuid;\n  const confirmDelete = useCallback(() => {\n    if (deleteUuid) {\n      updateUomConversions((prev) =>\n        prev.filter((item) => item.uuid !== deleteUuid),\n      );\n      setDeleteConfirmModal({ isOpen: false });\n    }\n  }, [deleteUuid, updateUomConversions]);\n\n  // Handle add new UOM\n  const handleAddNewUom = useCallback(() => {\n    if (!canAddOtherUom) return;\n\n    updateUomConversions((prev) => [\n      ...prev,\n      {\n        type: \"other\" as const,\n        label: tProductForm(\"otherUnitOfMeasure\"),\n        uomId: null,\n        uomName: null,\n        uuid: uuidv7(),\n        isActive: true,\n        conversionRatio: 1,\n      },\n    ]);\n  }, [canAddOtherUom, updateUomConversions, tProductForm]);\n\n  // Handle conversion ratio change\n  const handleConversionRatioChange = useCallback(\n    (uuid: string) => (ratio: number | null | undefined) => {\n      updateUomConversions((prev) =>\n        prev.map((item) =>\n          item.uuid === uuid\n            ? { ...item, conversionRatio: ratio ?? null }\n            : item,\n        ),\n      );\n    },\n    [updateUomConversions],\n  );\n\n  // Handle base UOM change\n  const handleBaseUomChange = useCallback(\n    (key: string | undefined, item?: SelectItemOption) => {\n      if (!key) {\n        setValue(`variants.${variantIndex}.baseUom`, undefined, {\n          shouldDirty: true,\n          shouldValidate: false,\n        });\n\n        return;\n      }\n\n      const duplicate = uomConversions.find(\n        (uom: UomConversions) => uom.uomId === key,\n      );\n\n      if (duplicate) {\n        addToast({\n          title: tProductForm(\"duplicateUom\"),\n          description: tProductForm(\"duplicateUomDescription\"),\n          color: \"warning\",\n        });\n\n        return;\n      }\n\n      const name =\n        typeof item?.label === \"string\"\n          ? item.label\n          : item?.label?.vi || item?.label?.en || \"\";\n\n      const baseUomValue = { id: key, name };\n\n      setValue(`variants.${variantIndex}.baseUom`, baseUomValue, {\n        shouldDirty: true,\n        shouldValidate: false,\n      });\n\n      // Auto-set SALE, PURCHASE, MANUFACTURE to base if not already selected\n      if (key) {\n        setTimeout(() => {\n          if (masterFeatures[ProductMasterFeatures.SALE] && !saleUomIdProp) {\n            setValue(`variants.${variantIndex}.saleUom`, baseUomValue, {\n              shouldDirty: true,\n              shouldValidate: false,\n            });\n          }\n          if (\n            masterFeatures[ProductMasterFeatures.PURCHASE] &&\n            !purchaseUomIdProp\n          ) {\n            setValue(`variants.${variantIndex}.purchaseUom`, baseUomValue, {\n              shouldDirty: true,\n              shouldValidate: false,\n            });\n          }\n          if (\n            masterFeatures[ProductMasterFeatures.MANUFACTURE] &&\n            !manufacturingUomIdProp\n          ) {\n            setValue(\n              `variants.${variantIndex}.manufacturingUom`,\n              baseUomValue,\n              {\n                shouldDirty: true,\n                shouldValidate: false,\n              },\n            );\n          }\n        }, 100);\n      }\n    },\n    [\n      uomConversions,\n      variantIndex,\n      setValue,\n      masterFeatures,\n      saleUomIdProp,\n      purchaseUomIdProp,\n      manufacturingUomIdProp,\n      tProductForm,\n    ],\n  );\n\n  // Build table columns\n  const tableColumns: DataTableColumnDefinition<UomConversions>[] = useMemo(\n    () => [\n      {\n        key: \"uom\",\n        title: tProductForm(\"otherUnitOfMeasure\"),\n        width: 300,\n        render: (_, record) => {\n          return (\n            <IBaseSingleSelectAsync\n              aria-label={tProductForm(\"otherUnitOfMeasure\")}\n              defaultParams={{\n                filters: { isActive: true },\n              }}\n              isDisabled={isBusy || !baseUomId}\n              model=\"product-uom.dropdown\"\n              selectedKey={record.uomId || undefined}\n              onSelectionChange={(key, item) => {\n                handleSelectUomConversion(\n                  record.uuid,\n                  key ?? null,\n                  item?.localizedLabel ?? null,\n                );\n              }}\n            />\n          );\n        },\n      },\n      {\n        key: \"conversionRatio\",\n        title: tProductForm(\"uom-section.conversionRatio\"),\n        width: 200,\n        render: (_, record) => (\n          <IBaseInputNumber\n            key={`conversion-ratio-${record.uuid}`}\n            decimalPlaces={4}\n            id={`conversion-ratio-${record.uuid}`}\n            isDisabled={isBusy || !baseUomId}\n            max={10000}\n            min={0.0001}\n            size=\"sm\"\n            value={record.conversionRatio}\n            onValueChange={handleConversionRatioChange(record.uuid)}\n          />\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        title: t(\"actions.action\"),\n        width: 80,\n        align: \"end\",\n        render: (_, record) => (\n          <Button\n            isIconOnly\n            aria-label={tProductForm(\"deleteUom\")}\n            color=\"danger\"\n            isDisabled={isBusy || !baseUomId}\n            size=\"sm\"\n            variant=\"ghost\"\n            onPress={() => handleDeleteUom(record.uuid)}\n          >\n            <Trash size={14} />\n          </Button>\n        ),\n      },\n    ],\n    [\n      tProductForm,\n      t,\n      baseUomId,\n      uomConversions,\n      availableUomOptions,\n\n      isBusy,\n      handleSelectUomConversion,\n      handleDeleteUom,\n      handleConversionRatioChange,\n    ],\n  );\n\n  const isStockable = masterFeatures[ProductMasterFeatures.STOCKABLE];\n  const hasFeatureUoms =\n    masterFeatures[ProductMasterFeatures.SALE] ||\n    masterFeatures[ProductMasterFeatures.PURCHASE] ||\n    masterFeatures[ProductMasterFeatures.MANUFACTURE];\n\n  const featureUomConfigs = useMemo(\n    () =>\n      [\n        {\n          key: ProductMasterFeatures.SALE,\n          label: tProduct(\"productFeature.sale\"),\n          value: saleUomIdProp,\n          uom: saleUom,\n          fieldName: \"saleUom\",\n        },\n        {\n          key: ProductMasterFeatures.PURCHASE,\n          label: tProduct(\"productFeature.purchase\"),\n          value: purchaseUomIdProp,\n          uom: purchaseUom,\n          fieldName: \"purchaseUom\",\n        },\n        {\n          key: ProductMasterFeatures.MANUFACTURE,\n          label: tProduct(\"productFeature.manufacture\"),\n          value: manufacturingUomIdProp,\n          uom: manufacturingUom,\n          fieldName: \"manufacturingUom\",\n        },\n      ].filter((config) => masterFeatures[config.key]),\n    [\n      tProduct,\n      masterFeatures,\n      saleUomIdProp,\n      purchaseUomIdProp,\n      manufacturingUomIdProp,\n      saleUom,\n      purchaseUom,\n      manufacturingUom,\n    ],\n  );\n\n  return (\n    <>\n      <div className=\"flex flex-col gap-4\">\n        <h4 className=\"text-medium font-medium\">\n          {tProductForm(\"unitOfMeasure\")}\n        </h4>\n\n        <div className=\"flex gap-4\">\n          <div className=\"flex-shrink-0 w-[400px]\">\n            <IBaseSingleSelectAsync\n              isRequired\n              defaultParams={{ filters: { isActive: true } }}\n              errorMessage={error?.message}\n              isDisabled={isBusy}\n              isInvalid={Boolean(error)}\n              label={\n                tProductForm(\"baseUnitOfMeasure\") +\n                (isStockable\n                  ? ` (${tProduct(\"productFeature.stockable\")})`\n                  : \"\")\n              }\n              model=\"product-uom.dropdown\"\n              selectedKey={baseUomId}\n              onRenderOption={(item: any) => {\n                return (\n                  <div>\n                    {item.symbol\n                      ? `(${item.symbol}) ${item.localizedLabel} `\n                      : item.localizedLabel}\n                  </div>\n                );\n              }}\n              onSelectionChange={(key, item) => handleBaseUomChange(key, item)}\n            />\n          </div>\n          <div className=\"flex flex-col gap-1 justify-center flex-1\">\n            <p className=\"text-small text-default-500 italic break-words\">\n              {tProductForm(\"baseUomDescription\")}\n            </p>\n            <p className=\"text-small text-danger-500 italic break-words\">\n              {tProductForm(\"baseUomWarning\")}\n            </p>\n          </div>\n        </div>\n\n        {baseUomId && (\n          <>\n            <div className=\"flex gap-4\">\n              <div className=\"max-w-[900px] overflow-auto\">\n                <DataTable\n                  columns={tableColumns}\n                  dataSource={uomConversions}\n                  emptyContent={tProductForm(\"noOtherUoms\")}\n                  isRefreshData={false}\n                  isStriped={false}\n                  pagination={false}\n                  rowKey=\"uuid\"\n                  total={uomConversions.length}\n                />\n              </div>\n              {canAddOtherUom && (\n                <Button\n                  color=\"primary\"\n                  isDisabled={isBusy || !baseUomId}\n                  size=\"sm\"\n                  startContent={<Plus size={14} />}\n                  variant=\"light\"\n                  onPress={handleAddNewUom}\n                >\n                  {tProductForm(\"addOtherUom\")}\n                </Button>\n              )}\n            </div>\n\n            {hasFeatureUoms && (\n              <div className=\"grid grid-cols-3 gap-4 mt-4\">\n                {featureUomConfigs.map((config) => (\n                  <IBaseSingleSelect\n                    key={config.key}\n                    isDisabled={isBusy || !baseUomId}\n                    items={availableUomOptions}\n                    label={config.label}\n                    selectedKey={config.value}\n                    onSelectionChange={(key, item) => {\n                      const fieldPath = `variants.${variantIndex}.${config.fieldName}`;\n\n                      if (!key) {\n                        setValue(fieldPath, undefined, {\n                          shouldDirty: true,\n                          shouldValidate: false,\n                        });\n\n                        return;\n                      }\n                      const name =\n                        typeof item?.label === \"string\"\n                          ? item.label\n                          : item?.label?.vi || item?.label?.en || \"\";\n\n                      setValue(\n                        fieldPath,\n                        { id: key, name },\n                        {\n                          shouldDirty: true,\n                          shouldValidate: false,\n                        },\n                      );\n                    }}\n                  />\n                ))}\n              </div>\n            )}\n          </>\n        )}\n      </div>\n\n      {/* Delete Confirm Modal */}\n      <Modal\n        isOpen={deleteConfirmModal.isOpen}\n        placement=\"center\"\n        onClose={() => setDeleteConfirmModal({ isOpen: false })}\n      >\n        <ModalContent>\n          <ModalHeader>\n            {tProductForm(\"uom-section.confirmDeleteUom\")}\n          </ModalHeader>\n          <ModalBody>\n            <p>\n              {tProductForm(\"uom-section.confirmDeleteUomMessage\")}\n              {deleteConfirmModal.uomName && ` (${deleteConfirmModal.uomName})`}\n            </p>\n          </ModalBody>\n          <ModalFooter>\n            <Button\n              variant=\"light\"\n              onPress={() => setDeleteConfirmModal({ isOpen: false })}\n            >\n              {t(\"actions.cancel\")}\n            </Button>\n            <Button color=\"danger\" onPress={confirmDelete}>\n              {t(\"actions.delete\")}\n            </Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/VariantTab.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[207,207],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `next-intl`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[84,395],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseTextarea,\n  IBaseUploadImageTiny,\n} from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { LocaleFieldValue, VariantFieldValue } from \"./types\";\n\nimport {\n  IBaseInput,\n  IBaseInputMultipleLang,\n  IBaseTextarea,\n  IBaseUploadImageTiny,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\n\nimport { ProductMasterFeaturesType } from \"../../../interface/Product\";\n\nimport { updateLocaleValue } from \"./types\";\nimport UomSection from \"./UomSection\";\n\ntype VariantTabProps = {\n  value: VariantFieldValue;\n  masterFeatures: Record<ProductMasterFeaturesType, boolean>;\n  variantIndex: number;\n  variantErrors?: {\n    name?: { en?: { message?: string } };\n    sku?: { message?: string };\n    barcode?: { message?: string };\n    manufacturerName?: { message?: string };\n    manufacturerCode?: { message?: string };\n    baseUom?: { message?: string };\n    attributes?: Array<{\n      code?: { message?: string };\n      value?: { message?: string };\n    }>;\n  };\n  isBusy: boolean;\n  canRemove: boolean;\n  onRemove: () => void;\n  onUpdate: (\n    updater: (current: VariantFieldValue) => VariantFieldValue,\n  ) => void;\n};\n\nexport default function VariantTab({\n  value,\n  masterFeatures,\n  variantIndex,\n  variantErrors,\n  isBusy,\n  canRemove,\n  onRemove,\n  onUpdate,\n}: VariantTabProps) {\n  const t = useTranslations(\"common\");\n  const tProductForm = useTranslations(\"mdl-product.product-create\");\n\n  return (\n    <div className=\"flex flex-col gap-4 pt-4\">\n      <div className=\"flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold\">\n          {t(\"variant\")} {variantIndex + 1}\n        </h2>\n        <Button\n          isDisabled={isBusy || !canRemove}\n          size=\"sm\"\n          startContent={<Trash size={14} />}\n          variant=\"light\"\n          onPress={onRemove}\n        >\n          {tProductForm(\"removeVariant\")}\n        </Button>\n      </div>\n\n      <IBaseInputMultipleLang\n        isRequired\n        errorMessage={variantErrors?.name?.en?.message}\n        isDisabled={isBusy}\n        isInvalid={Boolean(variantErrors?.name?.en)}\n        label={t(\"name\")}\n        value={value.name}\n        onValueChange={(langs) =>\n          onUpdate((current) => ({\n            ...current,\n            name: langs as unknown as LocaleFieldValue,\n          }))\n        }\n      />\n\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        <IBaseInput\n          isRequired\n          errorMessage={variantErrors?.sku?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(variantErrors?.sku)}\n          label={t(\"sku\")}\n          value={value.sku ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, sku: next }))\n          }\n        />\n        <IBaseInput\n          isRequired\n          errorMessage={variantErrors?.barcode?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(variantErrors?.barcode)}\n          label={t(\"barcode\")}\n          value={value.barcode ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, barcode: next }))\n          }\n        />\n      </div>\n\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        <IBaseInput\n          errorMessage={variantErrors?.manufacturerName?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(variantErrors?.manufacturerName)}\n          label={tProductForm(\"manufacturerName\")}\n          value={value.manufacturerName ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, manufacturerName: next }))\n          }\n        />\n        <IBaseInput\n          errorMessage={variantErrors?.manufacturerCode?.message}\n          isDisabled={isBusy}\n          isInvalid={Boolean(variantErrors?.manufacturerCode)}\n          label={tProductForm(\"manufacturerCode\")}\n          value={value.manufacturerCode ?? \"\"}\n          onValueChange={(next) =>\n            onUpdate((current) => ({ ...current, manufacturerCode: next }))\n          }\n        />\n      </div>\n      <Divider />\n      <UomSection\n        error={variantErrors?.baseUom}\n        isBusy={isBusy}\n        masterFeatures={masterFeatures}\n        variantIndex={variantIndex}\n      />\n\n      <Divider />\n\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h4 className=\"text-medium font-medium\">\n              {tProductForm(\"packings\")}\n            </h4>\n            <p className=\"text-small text-default-500\">\n              {tProductForm(\"definePackaging\")}\n            </p>\n          </div>\n          <Button\n            isDisabled={isBusy}\n            size=\"sm\"\n            startContent={<Plus size={14} />}\n            variant=\"bordered\"\n            onPress={() =>\n              onUpdate((current) => ({\n                ...current,\n                packings: [\n                  ...(current.packings || []),\n                  {\n                    name: { en: \"\", vi: \"\" },\n                    description: \"\",\n                    isActive: true,\n                  },\n                ],\n              }))\n            }\n          >\n            {tProductForm(\"addPacking\")}\n          </Button>\n        </div>\n\n        {!value.packings || value.packings.length === 0 ? (\n          <p className=\"text-small text-default-500\">\n            {tProductForm(\"noPackingEntries\")}\n          </p>\n        ) : (\n          <div className=\"flex flex-col gap-3\">\n            {value.packings.map((packing, packingIndex) => (\n              <Card key={packingIndex} className=\"border border-default-200\">\n                <CardBody className=\"flex flex-col gap-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <h5 className=\"text-small font-medium\">\n                      Packing #{packingIndex + 1}\n                    </h5>\n                    <Button\n                      isDisabled={isBusy}\n                      size=\"sm\"\n                      startContent={<Trash size={14} />}\n                      variant=\"light\"\n                      onPress={() =>\n                        onUpdate((current) => ({\n                          ...current,\n                          packings: current.packings.filter(\n                            (_, idx) => idx !== packingIndex,\n                          ),\n                        }))\n                      }\n                    >\n                      {t(\"actions.remove\")}\n                    </Button>\n                  </div>\n                  <div className=\"grid gap-3 md:grid-cols-2\">\n                    <IBaseInput\n                      isDisabled={isBusy}\n                      label={tProductForm(\"nameEnglish\")}\n                      value={packing.name.en ?? \"\"}\n                      onValueChange={(next) =>\n                        onUpdate((current) => ({\n                          ...current,\n                          packings: current.packings.map((p, idx) =>\n                            idx === packingIndex\n                              ? {\n                                  ...p,\n                                  name: updateLocaleValue(p.name, \"en\", next),\n                                }\n                              : p,\n                          ),\n                        }))\n                      }\n                    />\n                    <IBaseInput\n                      isDisabled={isBusy}\n                      label={tProductForm(\"nameVietnamese\")}\n                      value={packing.name.vi ?? \"\"}\n                      onValueChange={(next) =>\n                        onUpdate((current) => ({\n                          ...current,\n                          packings: current.packings.map((p, idx) =>\n                            idx === packingIndex\n                              ? {\n                                  ...p,\n                                  name: updateLocaleValue(p.name, \"vi\", next),\n                                }\n                              : p,\n                          ),\n                        }))\n                      }\n                    />\n                  </div>\n                  <IBaseTextarea\n                    isDisabled={isBusy}\n                    label={t(\"description\")}\n                    value={packing.description ?? \"\"}\n                    onValueChange={(next) =>\n                      onUpdate((current) => ({\n                        ...current,\n                        packings: current.packings.map((p, idx) =>\n                          idx === packingIndex\n                            ? {\n                                ...p,\n                                description: next,\n                              }\n                            : p,\n                        ),\n                      }))\n                    }\n                  />\n                </CardBody>\n              </Card>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <Divider />\n\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h4 className=\"text-medium font-medium\">\n              {tProductForm(\"attributes\")}\n            </h4>\n            <p className=\"text-small text-default-500\">\n              {tProductForm(\"captureAttributes\")}\n            </p>\n          </div>\n          <Button\n            isDisabled={isBusy}\n            size=\"sm\"\n            startContent={<Plus size={14} />}\n            variant=\"bordered\"\n            onPress={() =>\n              onUpdate((current) => ({\n                ...current,\n                attributes: [\n                  ...(current.attributes || []),\n                  {\n                    code: \"\",\n                    name: { en: \"\", vi: \"\" },\n                    value: \"\",\n                  },\n                ],\n              }))\n            }\n          >\n            {tProductForm(\"addAttribute\")}\n          </Button>\n        </div>\n\n        {!value.attributes || value.attributes.length === 0 ? (\n          <p className=\"text-small text-default-500\">\n            {tProductForm(\"noAttributeEntries\")}\n          </p>\n        ) : (\n          <div className=\"flex flex-col gap-3\">\n            {value.attributes.map((attribute, attributeIndex) => (\n              <Card key={attributeIndex} className=\"border border-default-200\">\n                <CardBody className=\"flex flex-col gap-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <h5 className=\"text-small font-medium\">\n                      Attribute #{attributeIndex + 1}\n                    </h5>\n                    <Button\n                      isDisabled={isBusy}\n                      size=\"sm\"\n                      startContent={<Trash size={14} />}\n                      variant=\"light\"\n                      onPress={() =>\n                        onUpdate((current) => ({\n                          ...current,\n                          attributes: current.attributes.filter(\n                            (_, idx) => idx !== attributeIndex,\n                          ),\n                        }))\n                      }\n                    >\n                      {t(\"actions.remove\")}\n                    </Button>\n                  </div>\n                  <IBaseInput\n                    errorMessage={\n                      variantErrors?.attributes?.[attributeIndex]?.code?.message\n                    }\n                    isDisabled={isBusy}\n                    isInvalid={Boolean(\n                      variantErrors?.attributes?.[attributeIndex]?.code,\n                    )}\n                    label={t(\"code\")}\n                    value={attribute.code}\n                    onValueChange={(next) =>\n                      onUpdate((current) => ({\n                        ...current,\n                        attributes: current.attributes.map((a, idx) =>\n                          idx === attributeIndex ? { ...a, code: next } : a,\n                        ),\n                      }))\n                    }\n                  />\n                  <div className=\"grid gap-3 md:grid-cols-2\">\n                    <IBaseInput\n                      isDisabled={isBusy}\n                      label={tProductForm(\"nameEnglish\")}\n                      value={attribute.name.en ?? \"\"}\n                      onValueChange={(next) =>\n                        onUpdate((current) => ({\n                          ...current,\n                          attributes: current.attributes.map((a, idx) =>\n                            idx === attributeIndex\n                              ? {\n                                  ...a,\n                                  name: updateLocaleValue(a.name, \"en\", next),\n                                }\n                              : a,\n                          ),\n                        }))\n                      }\n                    />\n                    <IBaseInput\n                      isDisabled={isBusy}\n                      label={tProductForm(\"nameVietnamese\")}\n                      value={attribute.name.vi ?? \"\"}\n                      onValueChange={(next) =>\n                        onUpdate((current) => ({\n                          ...current,\n                          attributes: current.attributes.map((a, idx) =>\n                            idx === attributeIndex\n                              ? {\n                                  ...a,\n                                  name: updateLocaleValue(a.name, \"vi\", next),\n                                }\n                              : a,\n                          ),\n                        }))\n                      }\n                    />\n                  </div>\n                  <IBaseInput\n                    errorMessage={\n                      variantErrors?.attributes?.[attributeIndex]?.value\n                        ?.message\n                    }\n                    isDisabled={isBusy}\n                    isInvalid={Boolean(\n                      variantErrors?.attributes?.[attributeIndex]?.value,\n                    )}\n                    label={t(\"value\")}\n                    value={attribute.value}\n                    onValueChange={(next) =>\n                      onUpdate((current) => ({\n                        ...current,\n                        attributes: current.attributes.map((a, idx) =>\n                          idx === attributeIndex ? { ...a, value: next } : a,\n                        ),\n                      }))\n                    }\n                  />\n                </CardBody>\n              </Card>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <IBaseTextarea\n        isDisabled={isBusy}\n        label={t(\"description\")}\n        value={value.description ?? \"\"}\n        onValueChange={(next) =>\n          onUpdate((current) => ({ ...current, description: next }))\n        }\n      />\n\n      <IBaseUploadImageTiny\n        isDisabled={isBusy}\n        label={tProductForm(\"images\")}\n        maxCount={10}\n        maxSize={5 * 1024 * 1024} // 5MB\n        values={value.images ?? []}\n        onChange={(images) => onUpdate((current) => ({ ...current, images }))}\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/index.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react-hook-form`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":34,"fix":{"range":[130,755],"text":"import { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { HelpCircle, Plus } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  FormProvider,\n  useFieldArray,\n  useForm,\n  useWatch,\n} from \"react-hook-form\";\nimport {\n  IBaseTabs,\n  IBaseTooltip,\n  SelectItemOption,\n  Tab,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":72,"fix":{"range":[300,300],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useLocalizedText` import should occur after import of `react-hook-form`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":72,"fix":{"range":[229,755],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { HelpCircle, Plus } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  FormProvider,\n  useFieldArray,\n  useForm,\n  useWatch,\n} from \"react-hook-form\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":25,"endColumn":26,"fix":{"range":[754,754],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateVariantField' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":133,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":31},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":326,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":326,"endColumn":20,"suggestions":[{"fix":{"range":[10492,10540],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":349,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":349,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":364,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":364,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":425,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":425,"endColumn":20,"suggestions":[{"fix":{"range":[13474,13522],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport type { Resolver, SubmitHandler } from \"react-hook-form\";\nimport type { VariantFieldValue } from \"./types\";\n\nimport {\n  IBaseTabs,\n  IBaseTooltip,\n  SelectItemOption,\n  Tab,\n} from \"@base/client/components\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { HelpCircle, Plus } from \"lucide-react\";\nimport { useTranslations } from \"next-intl\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  FormProvider,\n  useFieldArray,\n  useForm,\n  useWatch,\n} from \"react-hook-form\";\nimport { MediaService } from \"@base/client/services\";\n\nimport {\n  ProductFormValues,\n  ProductMasterFeatures,\n  ProductMasterType,\n} from \"../../../interface/Product\";\nimport ProductCategoryService from \"../../../services/ProductCategoryService\";\nimport ProductService from \"../../../services/ProductService\";\nimport { FORBIDDEN_FEATURES_BY_TYPE } from \"../../../utils/product-features-validator\";\n\nimport MasterTab from \"./MasterTab\";\nimport ProductFormGuideModal from \"./ProductFormGuideModal\";\nimport VariantTab from \"./VariantTab\";\nimport {\n  createDefaultValues,\n  createDefaultVariant,\n  mapToFieldValues,\n  mapToProductFormValues,\n  type ProductFormFieldValues,\n} from \"./mappers\";\nimport { buildHierarchyOptions, getFeaturesByProductType } from \"./utils\";\nimport { createProductFormSchema } from \"./validation\";\n\ninterface ProductFormProps {\n  submitLabel?: string;\n  secondarySubmitLabel?: string;\n  loading?: boolean;\n  initialValues?: ProductFormValues;\n  onSubmit: (values: ProductFormValues) => Promise<void> | void;\n  onSubmitAndContinue?: (values: ProductFormValues) => Promise<void> | void;\n  onCancel?: () => void;\n}\n\nexport default function ProductForm({\n  submitLabel,\n  secondarySubmitLabel,\n  loading = false,\n  initialValues,\n  onSubmit,\n  onSubmitAndContinue,\n  onCancel,\n}: ProductFormProps) {\n  const getLocalizedText = useLocalizedText();\n  const t = useTranslations(\"common\");\n  const tProduct = useTranslations(\"mdl-product\");\n  const tProductForm = useTranslations(\"mdl-product.product-create\");\n\n  // Helper to format messages with variables\n  // next-intl's useTranslations supports variables as second parameter\n  const formatMessage = useCallback(\n    (key: string, values: Record<string, string | number>) => {\n      // Type assertion to allow passing variables to next-intl translation function\n      const tWithVars = tProductForm as unknown as (\n        key: string,\n        values?: Record<string, string | number>,\n      ) => string;\n\n      return tWithVars(key, values);\n    },\n    [tProductForm],\n  );\n\n  const productFeaturesQuery = useQuery({\n    queryKey: [\"product-features\"],\n    queryFn: () => ProductService.getProductFeatures(),\n  });\n\n  const featureOptions = useMemo(() => {\n    if (!productFeaturesQuery.data?.data) {\n      return [];\n    }\n\n    return productFeaturesQuery.data.data.map((option: any) => {\n      return {\n        value: option.value as ProductMasterFeatures,\n        label: getLocalizedText(option.label as any) as string,\n      };\n    });\n  }, [productFeaturesQuery.data]);\n\n  const form = useForm<ProductFormFieldValues>({\n    defaultValues: mapToFieldValues(initialValues, featureOptions),\n    resolver: valibotResolver(\n      createProductFormSchema(t, tProduct, tProductForm, formatMessage),\n    ) as unknown as Resolver<ProductFormFieldValues>,\n    mode: \"onSubmit\", // Only validate on submit initially\n    reValidateMode: \"onChange\", // After submit, re-validate on change for fields with errors\n    shouldFocusError: true, // Auto focus first error field on submit\n  });\n\n  const {\n    handleSubmit,\n    reset,\n    control,\n    setValue,\n    getValues,\n    trigger,\n    setFocus,\n    formState: { errors, isSubmitting, isSubmitted },\n  } = form;\n\n  // Use useFieldArray for managing variants array\n  const {\n    fields: variantFields,\n    append: appendVariant,\n    remove: removeVariant,\n    update: updateVariantField,\n  } = useFieldArray({\n    control,\n    name: \"variants\",\n  });\n\n  useEffect(() => {\n    reset(mapToFieldValues(initialValues, featureOptions));\n  }, [initialValues, reset, featureOptions]);\n\n  const categoryQuery = useQuery({\n    queryKey: [\"product-category-tree\"],\n    queryFn: () => ProductCategoryService.fetchTree(),\n  });\n\n  const categoryOptions = useMemo<SelectItemOption[]>(() => {\n    if (!categoryQuery.data) return [];\n    const categories = Array.isArray(categoryQuery.data)\n      ? categoryQuery.data\n      : [];\n\n    return buildHierarchyOptions(categories).map((option) => ({\n      value: option.id,\n      label: option.label,\n    }));\n  }, [categoryQuery.data]);\n\n  // Watch only specific fields instead of entire form to improve performance\n  const masterCode = useWatch({ control, name: \"master.code\" });\n  const masterType = useWatch({ control, name: \"master.type\" });\n  const masterName = useWatch({ control, name: \"master.name\" });\n  const masterCategoryId = useWatch({ control, name: \"master.categoryId\" });\n  const masterDescription = useWatch({ control, name: \"master.description\" });\n  const masterBrand = useWatch({ control, name: \"master.brand\" });\n  const masterFeatures = useWatch({ control, name: \"master.features\" });\n  const variants = useWatch({ control, name: \"variants\" });\n  const [selectedTab, setSelectedTab] = useState<string>(\"master\");\n  const [isGuideModalOpen, setIsGuideModalOpen] = useState(false);\n\n  // Preserve selectedTab when variants array changes (but not when updating fields)\n  useEffect(() => {\n    // Only reset tab if we're on a variant tab that no longer exists\n    if (selectedTab.startsWith(\"variant-\")) {\n      const variantIndex = parseInt(selectedTab.replace(\"variant-\", \"\"), 10);\n\n      if (isNaN(variantIndex) || variantIndex >= (variants?.length ?? 0)) {\n        // Variant tab no longer exists, switch to master\n        setSelectedTab(\"master\");\n      }\n    }\n  }, [variants?.length, selectedTab]);\n\n  const isBusy = loading || isSubmitting;\n\n  // Calculate disabled features based on product type\n  const disabledFeatures = useMemo(() => {\n    if (!masterType) return new Set<string>();\n    const forbidden = FORBIDDEN_FEATURES_BY_TYPE[masterType] || [];\n\n    return new Set(forbidden.map((f) => f));\n  }, [masterType]);\n\n  const addVariant = useCallback(() => {\n    if (variantFields.length >= 20) return;\n    const newIndex = variantFields.length;\n\n    appendVariant(createDefaultVariant());\n    // Switch to the new variant tab\n    setSelectedTab(`variant-${newIndex}`);\n  }, [variantFields.length, appendVariant]);\n\n  const removeVariantAtIndex = useCallback(\n    (index: number) => {\n      if (variantFields.length <= 1) return; // At least one variant required\n      removeVariant(index);\n      // If we're on the removed tab, switch to master or another variant\n      if (selectedTab === `variant-${index}`) {\n        if (index === 0 && variantFields.length > 1) {\n          setSelectedTab(\"variant-0\");\n        } else if (index > 0) {\n          setSelectedTab(`variant-${index - 1}`);\n        } else {\n          setSelectedTab(\"master\");\n        }\n      }\n    },\n    [variantFields.length, removeVariant, selectedTab],\n  );\n\n  // Helper function to find first error field path\n  const findFirstErrorField = useCallback(\n    (errors: any, path = \"\"): string | null => {\n      if (!errors) return null;\n\n      for (const key in errors) {\n        const currentPath = path ? `${path}.${key}` : key;\n        const error = errors[key];\n\n        if (error?.message) {\n          return currentPath;\n        }\n\n        if (typeof error === \"object\" && error !== null) {\n          const nestedError = findFirstErrorField(error, currentPath);\n\n          if (nestedError) return nestedError;\n        }\n      }\n\n      return null;\n    },\n    [],\n  );\n\n  const updateVariant = useCallback(\n    (\n      variantIndex: number,\n      updater: (current: VariantFieldValue) => VariantFieldValue,\n    ) => {\n      const currentVariant = getValues(`variants.${variantIndex}`);\n\n      if (!currentVariant) return;\n\n      const updatedVariant = updater(currentVariant);\n\n      // Check if this field has errors (only validate if already submitted and has errors)\n      const hasError = Boolean(errors.variants?.[variantIndex]);\n      const shouldValidate = isSubmitted && hasError;\n\n      // Use setValue directly to update the variant field\n      setValue(`variants.${variantIndex}` as any, updatedVariant, {\n        shouldDirty: true,\n        shouldValidate: shouldValidate, // Only validate if field has error after submit\n        shouldTouch: true,\n      });\n\n      // Only trigger validation if field has error (after submit)\n      if (shouldValidate) {\n        trigger(`variants.${variantIndex}` as any).catch(() => {\n          // Silently handle any validation errors\n        });\n      }\n    },\n    [getValues, setValue, trigger, errors, isSubmitted],\n  );\n\n  const handleValidSubmit: SubmitHandler<ProductFormFieldValues> = async (\n    formValues,\n  ) => {\n    try {\n      // Upload images before mapping to payload\n      const uploadedFormValues = { ...formValues };\n\n      // Upload master images\n      if (formValues.master.images.length > 0) {\n        uploadedFormValues.master.images = await MediaService.uploadImageItems(\n          formValues.master.images,\n        );\n      }\n\n      // Upload variant images\n      uploadedFormValues.variants = await Promise.all(\n        formValues.variants.map(async (variant) => {\n          if (variant.images.length > 0) {\n            const uploadedImages = await MediaService.uploadImageItems(\n              variant.images,\n            );\n\n            return { ...variant, images: uploadedImages };\n          }\n\n          return variant;\n        }),\n      );\n\n      // Check for upload errors\n      const hasUploadErrors =\n        uploadedFormValues.master.images.some(\n          (img) => img.status === \"error\",\n        ) ||\n        uploadedFormValues.variants.some((variant) =>\n          variant.images.some((img) => img.status === \"error\"),\n        );\n\n      if (hasUploadErrors) {\n        throw new Error(\"Some images failed to upload. Please try again.\");\n      }\n\n      // Map to payload after upload\n      const payload = mapToProductFormValues(uploadedFormValues);\n\n      await onSubmit(payload);\n    } catch (error) {\n      console.error(\"Error uploading images:\", error);\n      throw error;\n    }\n  };\n\n  // Handle submit error - focus on first error field\n  const handleSubmitError = useCallback(\n    (submitErrors: any) => {\n      const firstErrorPath = findFirstErrorField(submitErrors);\n\n      if (firstErrorPath) {\n        // Switch to appropriate tab if error is in variant\n        if (firstErrorPath.startsWith(\"variants.\")) {\n          const variantMatch = firstErrorPath.match(/variants\\.(\\d+)/);\n\n          if (variantMatch) {\n            const variantIndex = parseInt(variantMatch[1], 10);\n\n            setSelectedTab(`variant-${variantIndex}`);\n            // Wait for tab switch then focus\n            setTimeout(() => {\n              try {\n                setFocus(firstErrorPath as keyof ProductFormFieldValues);\n              } catch (e) {\n                // Ignore focus errors for nested paths\n              }\n            }, 150);\n\n            return;\n          }\n        } else if (firstErrorPath.startsWith(\"master.\")) {\n          // Switch to master tab if error is in master\n          setSelectedTab(\"master\");\n        }\n        // Focus on the first error field\n        setTimeout(() => {\n          try {\n            setFocus(firstErrorPath as keyof ProductFormFieldValues);\n          } catch (e) {\n            // Ignore focus errors for nested paths\n          }\n        }, 100);\n      }\n    },\n    [findFirstErrorField, setFocus],\n  );\n\n  const handleValidSubmitAndContinue: SubmitHandler<\n    ProductFormFieldValues\n  > = async (formValues) => {\n    if (!onSubmitAndContinue) {\n      return;\n    }\n\n    try {\n      // Upload images before mapping to payload\n      const uploadedFormValues = { ...formValues };\n\n      // Upload master images\n      if (formValues.master.images.length > 0) {\n        uploadedFormValues.master.images = await MediaService.uploadImageItems(\n          formValues.master.images,\n        );\n      }\n\n      // Upload variant images\n      uploadedFormValues.variants = await Promise.all(\n        formValues.variants.map(async (variant) => {\n          if (variant.images.length > 0) {\n            const uploadedImages = await MediaService.uploadImageItems(\n              variant.images,\n            );\n\n            return { ...variant, images: uploadedImages };\n          }\n\n          return variant;\n        }),\n      );\n\n      // Check for upload errors\n      const hasUploadErrors =\n        uploadedFormValues.master.images.some(\n          (img) => img.status === \"error\",\n        ) ||\n        uploadedFormValues.variants.some((variant) =>\n          variant.images.some((img) => img.status === \"error\"),\n        );\n\n      if (hasUploadErrors) {\n        throw new Error(\"Some images failed to upload. Please try again.\");\n      }\n\n      // Map to payload after upload\n      const payload = mapToProductFormValues(uploadedFormValues);\n\n      await onSubmitAndContinue(payload);\n      reset(createDefaultValues(featureOptions));\n    } catch (error) {\n      console.error(\"Error uploading images:\", error);\n      throw error;\n    }\n  };\n\n  const submitForm = handleSubmit(handleValidSubmit, handleSubmitError);\n\n  const submitAndContinueForm = onSubmitAndContinue\n    ? handleSubmit(handleValidSubmitAndContinue, handleSubmitError)\n    : undefined;\n\n  return (\n    <form className=\"flex flex-col gap-4\" onSubmit={submitForm}>\n      <Card>\n        <CardBody className=\"space-y-4\">\n          <div className=\"flex gap-2 justify-between\">\n            <div className=\"justify-start\">\n              <Button\n                color=\"primary\"\n                isDisabled={isBusy || variantFields.length >= 20}\n                size=\"sm\"\n                startContent={<Plus size={14} />}\n                variant=\"light\"\n                onPress={addVariant}\n              >\n                {t(\"actions.add\")} {t(\"variant\")}\n              </Button>\n            </div>\n            <div className=\"justify-end flex items-center gap-2\">\n              <IBaseTooltip content={tProduct(\"guideTooltip\")} placement=\"top\">\n                <Button\n                  isIconOnly\n                  aria-label={tProduct(\"guideAriaLabel\")}\n                  isDisabled={isBusy}\n                  size=\"sm\"\n                  variant=\"light\"\n                  onPress={() => setIsGuideModalOpen(true)}\n                >\n                  <HelpCircle className=\"text-default-500\" size={18} />\n                </Button>\n              </IBaseTooltip>\n              {onCancel ? (\n                <Button\n                  isDisabled={isBusy}\n                  size=\"sm\"\n                  variant=\"light\"\n                  onPress={onCancel}\n                >\n                  {t(\"actions.cancel\")}\n                </Button>\n              ) : null}\n\n              {onSubmitAndContinue && submitAndContinueForm ? (\n                <Button\n                  isDisabled={isBusy}\n                  size=\"sm\"\n                  type=\"button\"\n                  variant=\"bordered\"\n                  onPress={async () => {\n                    await submitAndContinueForm();\n                  }}\n                >\n                  {secondarySubmitLabel ??\n                    `${t(\"actions.save\")} & ${t(\"actions.add\")} ${t(\"another\")}`}\n                </Button>\n              ) : null}\n\n              <Button\n                color=\"primary\"\n                isDisabled={isBusy}\n                isLoading={isBusy}\n                size=\"sm\"\n                type=\"submit\"\n                onPress={() => {\n                  submitForm();\n                }}\n              >\n                {submitLabel ?? t(\"actions.save\")}\n              </Button>\n            </div>\n          </div>\n\n          <FormProvider {...form}>\n            <IBaseTabs\n              aria-label=\"Product form tabs\"\n              classNames={{\n                tabList: \"overflow-x-auto mb-0\",\n                tab: \"max-w-[80px]\",\n                tabContent: \"max-w-[80px] truncate\",\n                base: \"mb-0\",\n              }}\n              color=\"primary\"\n              selectedKey={selectedTab}\n              onSelectionChange={(key: React.Key) =>\n                setSelectedTab(key as string)\n              }\n            >\n              <Tab key=\"master\" title={t(\"master\")}>\n                <MasterTab\n                  categoryOptions={categoryOptions}\n                  categoryQueryLoading={categoryQuery.isLoading}\n                  disabledFeatures={disabledFeatures}\n                  errors={errors.master}\n                  featureOptions={featureOptions}\n                  isBusy={isBusy}\n                  value={{\n                    name: masterName ?? { en: \"\", vi: \"\" },\n                    code: masterCode ?? \"\",\n                    categoryId: masterCategoryId,\n                    brand: masterBrand ?? \"\",\n                    type: masterType as ProductMasterType,\n                    description: masterDescription ?? \"\",\n                    features: masterFeatures ?? {},\n                    isActive: true,\n                    images: [],\n                  }}\n                  onUpdate={(updater) => {\n                    const current = {\n                      name: masterName ?? { en: \"\", vi: \"\" },\n                      code: masterCode ?? \"\",\n                      categoryId: masterCategoryId,\n                      brand: masterBrand ?? \"\",\n                      type: masterType ?? ProductMasterType.GOODS,\n                      description: masterDescription ?? \"\",\n                      features: masterFeatures ?? {},\n                      isActive: true,\n                      images: [],\n                    };\n                    const updated = updater(current);\n\n                    // If product type changed, reset features using getFeaturesByProductType\n                    if (\n                      updated.type !== current.type &&\n                      featureOptions.length > 0\n                    ) {\n                      updated.features = getFeaturesByProductType(\n                        updated.type,\n                        featureOptions,\n                        current.features,\n                      );\n                    }\n\n                    // Check if master has errors (only validate if already submitted and has errors)\n                    const hasMasterError = Boolean(errors.master);\n                    const shouldValidateMaster = isSubmitted && hasMasterError;\n\n                    setValue(\"master\", updated, {\n                      shouldDirty: true,\n                      shouldValidate: shouldValidateMaster, // Only validate if field has error after submit\n                    });\n                    // Only trigger validation if master has error (after submit)\n                    if (shouldValidateMaster) {\n                      trigger(\"master\").catch(() => {\n                        // Silently handle any validation errors\n                      });\n                    }\n                  }}\n                />\n              </Tab>\n\n              {useMemo(\n                () =>\n                  variantFields.map((field, variantIndex) => {\n                    const variant = variants?.[variantIndex];\n                    const variantErrors = errors.variants?.[variantIndex];\n                    const tabTitle =\n                      variant?.sku?.trim() ||\n                      `${t(\"variant\")} ${variantIndex + 1}`;\n                    const truncatedTitle =\n                      tabTitle.length > 12\n                        ? `${tabTitle.substring(0, 12)}...`\n                        : tabTitle;\n                    // Use stable key based on index to prevent tab switching\n                    const tabKey = `variant-${variantIndex}`;\n\n                    return (\n                      <Tab key={tabKey} title={truncatedTitle}>\n                        <VariantTab\n                          canRemove={variantFields.length > 1}\n                          isBusy={isBusy}\n                          masterFeatures={masterFeatures}\n                          value={variant ?? createDefaultVariant()}\n                          variantErrors={variantErrors as any}\n                          variantIndex={variantIndex}\n                          onRemove={() => removeVariantAtIndex(variantIndex)}\n                          onUpdate={(updater) =>\n                            updateVariant(variantIndex, updater)\n                          }\n                        />\n                      </Tab>\n                    );\n                  }),\n                [\n                  variantFields,\n                  variants,\n                  errors.variants,\n                  masterFeatures,\n                  isBusy,\n                  t,\n                  removeVariantAtIndex,\n                  updateVariant,\n                ],\n              )}\n            </IBaseTabs>\n          </FormProvider>\n        </CardBody>\n      </Card>\n\n      <ProductFormGuideModal\n        isOpen={isGuideModalOpen}\n        onClose={() => setIsGuideModalOpen(false)}\n      />\n    </form>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/mappers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/components/Product/ProductForm/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/interface/Product.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/interface/ProductCategory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Category/ProductCategoryCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":46,"fix":{"range":[359,359],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { ProductCategoryRow } from \"../../interface/ProductCategory\";\n\nimport { Button } from \"@heroui/button\";\nimport { addToast } from \"@heroui/toast\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport ProductCategoryForm, {\n  ProductCategoryFormValues,\n} from \"../../components/Category/ProductCategoryForm\";\nimport ProductCategoryService from \"../../services/ProductCategoryService\";\n\nconst ProductCategoryCreatePage = (): React.ReactNode => {\n  const router = useRouter();\n\n  const listLink = useMemo(\n    () =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"category\",\n      }),\n    [],\n  );\n\n  const getCategoryViewLink = useCallback(\n    (id: string) =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"category/view/[id]\",\n        as: `category/view/${id}`,\n      }),\n    [],\n  );\n\n  const navigateToList = useCallback(() => {\n    router.push(listLink.as ?? listLink.path);\n  }, [listLink.as, listLink.path, router]);\n\n  const createMutation = useMutation<\n    ProductCategoryRow,\n    Error,\n    ProductCategoryFormValues\n  >({\n    mutationFn: (values: ProductCategoryFormValues) =>\n      ProductCategoryService.createCategory(values),\n  });\n\n  const handleSubmit = async (values: ProductCategoryFormValues) => {\n    try {\n      const created = await createMutation.mutateAsync(values);\n\n      addToast({\n        title: \"Category created\",\n        description: \"The category was created successfully.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n      setTimeout(() => {\n        const link = getCategoryViewLink(created.id);\n\n        router.push(link.as ?? link.path);\n      }, 500);\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Failed to create category\";\n\n      addToast({\n        title: \"Create failed\",\n        description: message,\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n    }\n  };\n\n  const handleSubmitAndContinue = async (values: ProductCategoryFormValues) => {\n    try {\n      await createMutation.mutateAsync(values);\n      addToast({\n        title: \"Category created\",\n        description: \"You can continue creating another category.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Failed to create category\";\n\n      addToast({\n        title: \"Create failed\",\n        description: message,\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n      throw error;\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex items-center gap-2\">\n        <Button\n          isDisabled={createMutation.isPending}\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={navigateToList}\n        >\n          Back\n        </Button>\n      </div>\n\n      <ProductCategoryForm\n        loading={createMutation.isPending}\n        secondarySubmitLabel=\"Create & add another\"\n        submitLabel=\"Create\"\n        subtitle=\"Define a new product category for organizing your catalog.\"\n        title=\"Create Category\"\n        onCancel={navigateToList}\n        onSubmit={handleSubmit}\n        onSubmitAndContinue={handleSubmitAndContinue}\n      />\n    </div>\n  );\n};\n\nexport default ProductCategoryCreatePage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Category/ProductCategoryDetailPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[485,485],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\nimport type { ProductCategoryRow } from \"../../interface/ProductCategory\";\n\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { Spinner } from \"@heroui/spinner\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n\nimport ProductCategoryService from \"../../services/ProductCategoryService\";\n\nconst getParamValue = (\n  value: string | string[] | undefined,\n): string | undefined => (Array.isArray(value) ? value[0] : value);\n\nconst ProductCategoryDetailPage = (): React.ReactNode => {\n  const params = useParams();\n  const router = useRouter();\n  const localized = useLocalizedText();\n\n  const categoryId = useMemo(() => {\n    const rawId = (params?.id ?? undefined) as string | string[] | undefined;\n\n    return getParamValue(rawId);\n  }, [params]);\n\n  const { data, isLoading, isError, error, refetch } = useQuery({\n    queryKey: [\"product-category-detail\", categoryId],\n    enabled: Boolean(categoryId),\n    queryFn: async (): Promise<ProductCategoryRow> => {\n      if (!categoryId) {\n        throw new Error(\"Missing category id\");\n      }\n\n      return ProductCategoryService.getById(categoryId);\n    },\n  });\n\n  const category = data;\n\n  const infoRows = [\n    {\n      label: \"Name\",\n      value: category\n        ? (localized(category.name as LocalizeText) ?? category.code)\n        : \"-\",\n    },\n    {\n      label: \"Code\",\n      value: category?.code ?? \"-\",\n    },\n    {\n      label: \"Parent\",\n      value:\n        category?.parent && category.parent.name\n          ? (localized(category.parent.name as LocalizeText) ??\n            category.parent.id)\n          : (category?.parent?.id ?? \"-\"),\n    },\n    {\n      label: \"Level\",\n      value: category?.level ?? \"-\",\n    },\n    {\n      label: \"Updated At\",\n      value: category?.updatedAt ? formatDate(category.updatedAt) : \"-\",\n    },\n  ];\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div>\n        <Button\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={() => router.back()}\n        >\n          Back to categories\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody className=\"space-y-4\">\n          {!categoryId ? (\n            <p className=\"text-default-500\">No category selected.</p>\n          ) : isLoading ? (\n            <div className=\"flex items-center gap-2 text-default-500\">\n              <Spinner size=\"sm\" />\n              <span>Loading category details...</span>\n            </div>\n          ) : isError ? (\n            <div className=\"flex flex-col gap-2 text-danger\">\n              <p>\n                {error instanceof Error\n                  ? error.message\n                  : \"Failed to load category.\"}\n              </p>\n              <Button size=\"sm\" variant=\"bordered\" onPress={() => refetch()}>\n                Retry\n              </Button>\n            </div>\n          ) : (\n            <>\n              <div className=\"flex flex-col gap-4\">\n                {infoRows.map((row) => (\n                  <div key={row.label}>\n                    <p className=\"text-xs uppercase text-default-400\">\n                      {row.label}\n                    </p>\n                    <div className=\"mt-1 text-sm text-default-600\">\n                      {row.value}\n                    </div>\n                  </div>\n                ))}\n              </div>\n\n              {category?.description ? (\n                <>\n                  <Divider />\n                  <div>\n                    <p className=\"text-xs uppercase text-default-400\">\n                      Description\n                    </p>\n                    <p className=\"mt-1 text-sm text-default-600\">\n                      {localized(category.description as LocalizeText) ?? \"-\"}\n                    </p>\n                  </div>\n                </>\n              ) : null}\n            </>\n          )}\n        </CardBody>\n      </Card>\n    </div>\n  );\n};\n\nexport default ProductCategoryDetailPage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Category/ProductCategoryEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":46,"fix":{"range":[453,453],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\nimport type { ProductCategoryRow } from \"../../interface/ProductCategory\";\n\nimport { Button } from \"@heroui/button\";\nimport { addToast } from \"@heroui/toast\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport ProductCategoryForm, {\n  ProductCategoryFormValues,\n} from \"../../components/Category/ProductCategoryForm\";\nimport ProductCategoryService from \"../../services/ProductCategoryService\";\n\nconst getParamValue = (\n  value: string | string[] | undefined,\n): string | undefined => (Array.isArray(value) ? value[0] : value);\n\nconst ProductCategoryEditPage = (): React.ReactNode => {\n  const params = useParams();\n  const router = useRouter();\n  const localized = useLocalizedText();\n\n  const listLink = useMemo(\n    () =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"category\",\n      }),\n    [],\n  );\n\n  const getCategoryViewLink = useCallback(\n    (id: string) =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"category/view/[id]\",\n        as: `category/view/${id}`,\n      }),\n    [],\n  );\n\n  const navigateToList = useCallback(() => {\n    router.push(listLink.as ?? listLink.path);\n  }, [listLink.as, listLink.path, router]);\n\n  const categoryId = useMemo(() => {\n    const rawId = (params?.id ?? undefined) as string | string[] | undefined;\n\n    return getParamValue(rawId);\n  }, [params]);\n\n  const categoryQuery = useQuery({\n    queryKey: [\"product-category-detail\", categoryId],\n    enabled: Boolean(categoryId),\n    queryFn: async (): Promise<ProductCategoryRow> => {\n      if (!categoryId) {\n        throw new Error(\"Missing category id\");\n      }\n\n      return ProductCategoryService.getById(categoryId);\n    },\n  });\n\n  const updateMutation = useMutation<\n    ProductCategoryRow,\n    Error,\n    ProductCategoryFormValues\n  >({\n    mutationFn: (values: ProductCategoryFormValues) => {\n      if (!categoryId) {\n        throw new Error(\"Missing category id\");\n      }\n\n      return ProductCategoryService.updateCategory(categoryId, values);\n    },\n  });\n\n  const handleSubmit = async (values: ProductCategoryFormValues) => {\n    try {\n      const updated = await updateMutation.mutateAsync(values);\n\n      addToast({\n        title: \"Category updated\",\n        description: \"Changes saved successfully.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n      setTimeout(() => {\n        const link = getCategoryViewLink(updated.id);\n\n        router.push(link.as ?? link.path);\n      }, 500);\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Failed to update category\";\n\n      addToast({\n        title: \"Update failed\",\n        description: message,\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n    }\n  };\n\n  const initialValues: ProductCategoryFormValues | undefined =\n    categoryQuery.data\n      ? {\n          name: localized(categoryQuery.data.name as LocalizeText) ?? \"\",\n          code: categoryQuery.data.code ?? \"\",\n          description:\n            localized(categoryQuery.data.description as LocalizeText) ?? \"\",\n          parentId: categoryQuery.data.parent?.id ?? \"\",\n          level: categoryQuery.data.level ?? undefined,\n          isActive:\n            categoryQuery.data.isActive === undefined\n              ? true\n              : Boolean(categoryQuery.data.isActive),\n        }\n      : undefined;\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex items-center gap-2\">\n        <Button\n          isDisabled={updateMutation.isPending}\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={() => router.back()}\n        >\n          Back\n        </Button>\n        {categoryId && (\n          <span className=\"text-small text-default-500\">\n            Editing category #{categoryId}\n          </span>\n        )}\n      </div>\n\n      {categoryQuery.isLoading ? (\n        <p className=\"text-default-500\">Loading category...</p>\n      ) : categoryQuery.isError ? (\n        <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-500\">\n          {categoryQuery.error instanceof Error\n            ? categoryQuery.error.message\n            : \"Failed to load category.\"}\n        </div>\n      ) : categoryQuery.data ? (\n        <ProductCategoryForm\n          categoryId={categoryId}\n          initialValues={initialValues}\n          loading={updateMutation.isPending}\n          submitLabel=\"Save changes\"\n          subtitle=\"Update the metadata for this category.\"\n          title=\"Edit Category\"\n          onCancel={() => {\n            if (categoryId) {\n              const link = getCategoryViewLink(categoryId);\n\n              router.push(link.as ?? link.path);\n            } else {\n              navigateToList();\n            }\n          }}\n          onSubmit={handleSubmit}\n        />\n      ) : null}\n    </div>\n  );\n};\n\nexport default ProductCategoryEditPage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Category/ProductCategoryListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":65,"fix":{"range":[466,466],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":38,"fix":{"range":[89,505],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":45,"fix":{"range":[89,550],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":40,"fix":{"range":[589,589],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":40,"fix":{"range":[89,590],"text":"import React, { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport React, { useMemo } from \"react\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport { ProductCategoryRow } from \"../../interface/ProductCategory\";\n\nconst ProductCategoryListPage = (): React.ReactNode => {\n  const localized = useLocalizedText();\n  const t = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<ProductCategoryRow>[]>(() => {\n    return [\n      {\n        key: \"name\",\n        label: \"Category Name\",\n        sortable: true,\n        render: (_, row) => {\n          const { path, as } = getClientLink({\n            mdl: \"product\",\n            path: \"categories/view/[id]\",\n            as: `categories/view/${row.id}`,\n          });\n\n          return (\n            <LinkAs as={as} href={path}>\n              {localized(row.name as LocalizeText) || row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"code\",\n        label: \"Code\",\n        sortable: true,\n        render: (value) => value,\n      },\n      {\n        key: \"parent.name\",\n        label: \"Parent\",\n        render: (_, row) =>\n          row.parent\n            ? localized(row.parent.name as LocalizeText) || row.parent.id\n            : \"-\",\n      },\n      {\n        key: \"level\",\n        label: \"Level\",\n        align: \"center\",\n        sortable: true,\n        render: (value) => value ?? \"-\",\n      },\n      {\n        key: \"isActive\",\n        label: \"Status\",\n        align: \"center\",\n        sortable: true,\n        render: (_, row) => (\n          <Chip\n            color={row.isActive ? \"success\" : \"danger\"}\n            size=\"sm\"\n            variant=\"flat\"\n          >\n            {row.isActive ? \"Active\" : \"Inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: \"createdAt\",\n        label: \"Created\",\n        sortable: true,\n        render: (_, row) => (row.createdAt ? formatDate(row.createdAt) : \"-\"),\n      },\n      {\n        key: \"updatedAt\",\n        label: \"Updated\",\n        sortable: true,\n        render: (_, row) => (row.updatedAt ? formatDate(row.updatedAt) : \"-\"),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: t(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          const viewLink = getClientLink({\n            mdl: \"product\",\n            path: \"categories/view/[id]\",\n            as: `categories/view/${row.id}`,\n          });\n          const editLink = getClientLink({\n            mdl: \"product\",\n            path: \"categories/edit/[id]\",\n            as: `categories/edit/${row.id}`,\n          });\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink.path,\n                  as: viewLink.as,\n                },\n                {\n                  key: \"edit\",\n                  label: \"Edit\",\n                  href: editLink.path,\n                  as: editLink.as,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ];\n  }, [localized, t]);\n\n  const createLink = getClientLink({\n    mdl: \"product\",\n    path: \"categories/create\",\n  });\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Category\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: createLink.path,\n              hrefAs: createLink.as as any,\n            },\n          },\n        ]}\n        columns={columns}\n        model=\"product-category\"\n      />\n    </div>\n  );\n};\n\nexport default ProductCategoryListPage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Product/ProductsCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":46,"fix":{"range":[283,283],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Button } from \"@heroui/button\";\nimport { addToast } from \"@heroui/toast\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport ProductForm from \"../../components/Product/ProductForm\";\nimport { ProductFormPayload, ProductFormValues } from \"../../interface/Product\";\nimport ProductService from \"../../services/ProductService\";\nimport { mapFormValuesToPayload } from \"../../utils/productMapper\";\n\nconst ProductsCreatePage = (): React.ReactNode => {\n  const router = useRouter();\n\n  const listLink = useMemo(\n    () =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"\",\n      }),\n    [],\n  );\n\n  const getViewLink = useCallback((id: string) => {\n    return getClientLink({\n      mdl: \"product\",\n      path: \"view/[id]\",\n      as: `view/${id}`,\n    });\n  }, []);\n\n  const navigateToList = useCallback(() => {\n    router.push(listLink.as ?? listLink.path);\n  }, [listLink.as, listLink.path, router]);\n\n  const createMutation = useMutation({\n    mutationFn: async (payload: ProductFormPayload) => {\n      const response = await ProductService.createProduct(payload);\n\n      if (!response.data) {\n        throw new Error(\"Failed to create product\");\n      }\n\n      return response.data;\n    },\n  });\n\n  const handleSubmit = async (values: ProductFormValues) => {\n    try {\n      const payload = mapFormValuesToPayload(values);\n      const created = await createMutation.mutateAsync(payload);\n\n      addToast({\n        title: \"Product created\",\n        description: \"The product has been created successfully.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n\n      if (created?.variant?.id) {\n        const viewLink = getViewLink(created.variant.id);\n\n        setTimeout(() => {\n          router.push(viewLink.as ?? viewLink.path);\n        }, 500);\n      } else {\n        navigateToList();\n      }\n    } catch (error) {\n      addToast({\n        title: \"Create failed\",\n        description:\n          error instanceof Error ? error.message : \"Failed to create product\",\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n    }\n  };\n\n  const handleSubmitAndContinue = async (values: ProductFormValues) => {\n    try {\n      const payload = mapFormValuesToPayload(values);\n\n      await createMutation.mutateAsync(payload);\n      addToast({\n        title: \"Product created\",\n        description: \"You can add another product now.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n    } catch (error) {\n      addToast({\n        title: \"Create failed\",\n        description:\n          error instanceof Error ? error.message : \"Failed to create product\",\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n      throw error;\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex items-center gap-2\">\n        <Button\n          isDisabled={createMutation.isPending}\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={navigateToList}\n        >\n          Back\n        </Button>\n      </div>\n\n      <ProductForm\n        loading={createMutation.isPending}\n        secondarySubmitLabel=\"Create & add another\"\n        submitLabel=\"Create\"\n        onCancel={navigateToList}\n        onSubmit={handleSubmit}\n        onSubmitAndContinue={handleSubmitAndContinue}\n      />\n    </div>\n  );\n};\n\nexport default ProductsCreatePage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Product/ProductsEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":46,"fix":{"range":[347,347],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport { Button } from \"@heroui/button\";\nimport { Spinner } from \"@heroui/spinner\";\nimport { addToast } from \"@heroui/toast\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport ProductForm from \"../../components/Product/ProductForm\";\nimport { ProductDetail, ProductFormValues } from \"../../interface/Product\";\nimport ProductService from \"../../services/ProductService\";\nimport {\n  mapDetailToFormValues,\n  mapFormValuesToPayload,\n} from \"../../utils/productMapper\";\n\nconst getParamValue = (\n  value: string | string[] | undefined,\n): string | undefined => (Array.isArray(value) ? value[0] : value);\n\nexport default function ProductsEditPage(): React.ReactNode {\n  const params = useParams();\n  const router = useRouter();\n\n  const productId = useMemo(() => {\n    const rawId = (params?.id ?? undefined) as string | string[] | undefined;\n\n    return getParamValue(rawId);\n  }, [params]);\n\n  const listLink = useMemo(\n    () =>\n      getClientLink({\n        mdl: \"product\",\n        path: \"\",\n      }),\n    [],\n  );\n\n  const getViewLink = useCallback((id: string) => {\n    return getClientLink({\n      mdl: \"product\",\n      path: \"view/[id]\",\n      as: `view/${id}`,\n    });\n  }, []);\n\n  const productQuery = useQuery({\n    queryKey: [\"product-detail\", productId],\n    enabled: Boolean(productId),\n    queryFn: async () => {\n      if (!productId) {\n        throw new Error(\"Missing product id\");\n      }\n      const response = await ProductService.getProductById(productId);\n\n      if (!response.data) {\n        throw new Error(\"Failed to load product\");\n      }\n\n      return response.data as ProductDetail;\n    },\n  });\n\n  const updateMutation = useMutation({\n    mutationFn: async ({\n      id,\n      values,\n    }: {\n      id: string;\n      values: ProductFormValues;\n    }) => {\n      const payload = mapFormValuesToPayload(values);\n      const response = await ProductService.updateProduct(id, payload);\n\n      if (!response.data) {\n        throw new Error(\"Failed to update product\");\n      }\n\n      return response.data;\n    },\n  });\n\n  const navigateToList = useCallback(() => {\n    router.push(listLink.as ?? listLink.path);\n  }, [listLink.as, listLink.path, router]);\n\n  const handleSubmit = async (values: ProductFormValues): Promise<void> => {\n    if (!productId) return;\n\n    try {\n      await updateMutation.mutateAsync({ id: productId, values });\n      addToast({\n        title: \"Product updated\",\n        description: \"Changes saved successfully.\",\n        color: \"success\",\n        variant: \"solid\",\n        timeout: 4000,\n      });\n\n      const link = getViewLink(productId);\n\n      setTimeout(() => {\n        router.push(link.as ?? link.path);\n      }, 500);\n    } catch (error) {\n      addToast({\n        title: \"Update failed\",\n        description:\n          error instanceof Error ? error.message : \"Failed to update product\",\n        color: \"danger\",\n        variant: \"solid\",\n        timeout: 5000,\n      });\n      throw error;\n    }\n  };\n\n  if (!productId) {\n    return (\n      <div className=\"space-y-4\">\n        <Button size=\"sm\" variant=\"light\" onPress={navigateToList}>\n          Back to products\n        </Button>\n        <p className=\"text-default-500\">No product selected.</p>\n      </div>\n    );\n  }\n\n  if (productQuery.isLoading) {\n    return (\n      <div className=\"flex items-center gap-2 text-default-500\">\n        <Spinner size=\"sm\" />\n        <span>Loading product...</span>\n      </div>\n    );\n  }\n\n  if (productQuery.isError) {\n    return (\n      <div className=\"space-y-4\">\n        <Button size=\"sm\" variant=\"light\" onPress={navigateToList}>\n          Back to products\n        </Button>\n        <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-500\">\n          {productQuery.error instanceof Error\n            ? productQuery.error.message\n            : \"Failed to load product.\"}\n        </div>\n      </div>\n    );\n  }\n\n  const productDetail = productQuery.data;\n\n  if (!productDetail) {\n    return (\n      <div className=\"space-y-4\">\n        <Button size=\"sm\" variant=\"light\" onPress={navigateToList}>\n          Back to products\n        </Button>\n        <p className=\"text-default-500\">Product not found.</p>\n      </div>\n    );\n  }\n\n  const initialFormValues = mapDetailToFormValues(productDetail);\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex items-center gap-2\">\n        <Button\n          isDisabled={updateMutation.isPending}\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={() => router.back()}\n        >\n          Back\n        </Button>\n        <span className=\"text-small text-default-500\">\n          Editing product #{productId}\n        </span>\n      </div>\n\n      <ProductForm\n        initialValues={initialFormValues}\n        loading={updateMutation.isPending}\n        submitLabel=\"Save changes\"\n        onCancel={() => {\n          const viewLink = getViewLink(productId);\n\n          router.push(viewLink.as ?? viewLink.path);\n        }}\n        onSubmit={handleSubmit}\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Product/ProductsListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":53,"fix":{"range":[589,589],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":38,"fix":{"range":[88,628],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":45,"fix":{"range":[88,673],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":40,"fix":{"range":[88,713],"text":"import React, { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport React, { useMemo } from \"react\";\n\nimport { ProductRow } from \"../../interface/Product\";\nimport { convertProductMasterFeaturesToArrayKey } from \"../../utils/getNameProductFeatures\";\nimport { getNameProductType } from \"../../utils/getNameProductType\";\n\nexport default function ProductsListPage(): React.ReactNode {\n  const localized = useLocalizedText();\n  const t = useTranslations(\"dataTable\");\n  const tProduct = useTranslations(\"mdl-product\");\n  const columns = useMemo<DataTableColumn<ProductRow>[]>(() => {\n    return [\n      {\n        key: \"name\",\n        label: \"Name\",\n        sortable: true,\n        minWidth: 150,\n        maxWidth: 300,\n        render: (_, row) => {\n          const { path, as } = getClientLink({\n            mdl: \"product\",\n            path: \"view/[id]\",\n            as: `view/${row.id}`,\n          });\n\n          return (\n            <LinkAs as={as} href={path}>\n              {localized(row.name as LocalizeText) || row.id}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"sku\",\n        label: \"SKU\",\n        minWidth: 100,\n        maxWidth: 150,\n        render: (value) => value,\n      },\n      {\n        key: \"barcode\",\n        label: \"Barcode\",\n        minWidth: 120,\n        maxWidth: 200,\n        render: (value) => value,\n      },\n      {\n        key: \"baseUom.name\",\n        label: \"Base UOM\",\n        minWidth: 100,\n        maxWidth: 150,\n        render: (_, row) => localized(row.baseUom?.name as LocalizeText),\n      },\n      {\n        key: \"productMaster.type\",\n        label: \"Type\",\n        minWidth: 100,\n        maxWidth: 150,\n        render: (_, row) => getNameProductType(row.productMaster?.type),\n      },\n      {\n        key: \"productMaster.features\",\n        label: \"Features\",\n        minWidth: 150,\n        maxWidth: 250,\n        render: (_, row) => {\n          const features = convertProductMasterFeaturesToArrayKey(\n            row.productMaster?.features,\n          );\n\n          return features.map((feature) =>\n            tProduct(`productFeature.${feature}`),\n          );\n        },\n      },\n      {\n        key: \"status\",\n        label: \"Status\",\n        align: \"center\",\n        minWidth: 100,\n        maxWidth: 120,\n        render: (_, row) => {\n          return (\n            <Chip\n              color={row.isActive ? \"success\" : \"danger\"}\n              size=\"sm\"\n              variant=\"flat\"\n            >\n              {row.isActive ? \"Active\" : \"Inactive\"}\n            </Chip>\n          );\n        },\n      },\n      {\n        key: \"productMaster.category.name\",\n        label: \"Category\",\n        minWidth: 120,\n        maxWidth: 200,\n        render: (_, row) =>\n          localized(row.productMaster?.category?.name as LocalizeText) ||\n          row.productMaster?.category?.code,\n      },\n      {\n        key: \"manufacturer.name\",\n        label: \"Manufacturer\",\n        minWidth: 120,\n        maxWidth: 200,\n        render: (_, row) =>\n          typeof row.manufacturer?.name === \"string\"\n            ? row.manufacturer.name\n            : (row.manufacturer?.code ?? \"-\"),\n      },\n      {\n        key: \"productMaster.brand\",\n        label: \"Brand\",\n        minWidth: 100,\n        maxWidth: 180,\n        render: (_, row) =>\n          typeof row.productMaster?.brand === \"string\"\n            ? row.productMaster.brand\n            : \"-\",\n      },\n\n      {\n        key: \"createdAt\",\n        label: \"Created At\",\n        minWidth: 120,\n        maxWidth: 150,\n        render: (_, row) => formatDate(row.createdAt),\n      },\n      {\n        key: \"updatedAt\",\n        label: \"Updated At\",\n        minWidth: 120,\n        maxWidth: 150,\n        render: (_, row) => formatDate(row.updatedAt),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: t(\"columns.action\"),\n        align: \"end\",\n        minWidth: 80,\n        maxWidth: 100,\n        render: (_, row) => {\n          const viewLink = getClientLink({\n            mdl: \"product\",\n            path: \"view/[id]\",\n            as: `view/${row.id}`,\n          });\n          const editLink = getClientLink({\n            mdl: \"product\",\n            path: \"edit/[id]\",\n            as: `edit/${row.id}`,\n          });\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: \"View\",\n                  href: viewLink.path,\n                  as: viewLink.as,\n                },\n                {\n                  key: \"edit\",\n                  label: \"Edit\",\n                  href: editLink.path,\n                  as: editLink.as,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ];\n  }, [t]);\n\n  const createLink = getClientLink({\n    mdl: \"product\",\n    path: \"create\",\n  });\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"New Product\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: createLink.path,\n              as: createLink.as as any,\n            },\n          },\n        ]}\n        columns={columns}\n        model=\"product\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/Product/ProductsViewPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":33,"fix":{"range":[478,478],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'localized' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":26,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\nimport type { ProductDetail } from \"../../interface/Product\";\n\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Chip, Divider } from \"@heroui/react\";\nimport { Spinner } from \"@heroui/spinner\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\nimport ProductService from \"../../services/ProductService\";\n\nconst getParamValue = (\n  value: string | string[] | undefined,\n): string | undefined => (Array.isArray(value) ? value[0] : value);\n\nexport default function ProductsViewPage(): React.ReactNode {\n  const params = useParams();\n  const router = useRouter();\n  const localized = useLocalizedText();\n\n  const productId = useMemo(() => {\n    const rawId = (params?.id ?? undefined) as string | string[] | undefined;\n\n    return getParamValue(rawId);\n  }, [params]);\n\n  const editLink = useMemo(() => {\n    if (!productId) {\n      return null;\n    }\n\n    return getClientLink({\n      mdl: \"product\",\n      path: \"edit/[id]\",\n      as: `edit/${productId}`,\n    });\n  }, [productId]);\n\n  const productQuery = useQuery({\n    queryKey: [\"product-detail\", productId],\n    enabled: Boolean(productId),\n    queryFn: async () => {\n      if (!productId) {\n        throw new Error(\"Missing product id\");\n      }\n      const response = await ProductService.getProductById(productId);\n\n      if (!response.data) {\n        throw new Error(\"Failed to load product\");\n      }\n\n      return response.data as ProductDetail;\n    },\n  });\n\n  if (!productId) {\n    return (\n      <div className=\"space-y-4\">\n        <Button size=\"sm\" variant=\"light\" onPress={() => router.back()}>\n          Back\n        </Button>\n        <p className=\"text-default-500\">No product selected.</p>\n      </div>\n    );\n  }\n\n  const renderLoading = (\n    <div className=\"flex items-center gap-2 text-default-500\">\n      <Spinner size=\"sm\" />\n      <span>Loading product...</span>\n    </div>\n  );\n\n  const renderError = (\n    <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-500\">\n      {productQuery.error instanceof Error\n        ? productQuery.error.message\n        : \"Failed to load product.\"}\n    </div>\n  );\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div>\n        <Button\n          size=\"sm\"\n          startContent={<ArrowLeft size={14} />}\n          variant=\"light\"\n          onPress={() => router.back()}\n        >\n          Back to products\n        </Button>\n        {editLink ? (\n          <Button\n            as={LinkAs as any}\n            className=\"ml-2\"\n            color=\"primary\"\n            href={editLink.path}\n            size=\"sm\"\n          >\n            Edit product\n          </Button>\n        ) : null}\n      </div>\n\n      <Card>\n        <CardBody className=\"space-y-4\">\n          <div className=\"flex flex-wrap items-center gap-2\">\n            <Chip size=\"sm\" variant=\"flat\">\n              Product ID: {productId}\n            </Chip>\n          </div>\n\n          {productQuery.isLoading ? (\n            renderLoading\n          ) : productQuery.isError ? (\n            renderError\n          ) : productQuery.data ? (\n            <ProductDetailContent detail={productQuery.data} />\n          ) : null}\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n\nconst ProductDetailContent = ({ detail }: { detail: ProductDetail }) => {\n  const localized = useLocalizedText();\n\n  const features = Object.entries(detail.master.features ?? {}).filter(\n    ([, value]) => Boolean(value),\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      <section className=\"space-y-3\">\n        <h2 className=\"text-lg font-semibold\">Master information</h2>\n        <div className=\"grid gap-3 md:grid-cols-2\">\n          <InfoRow label=\"Code\" value={detail.master.code} />\n          <InfoRow\n            label=\"Name\"\n            value={\n              localized(detail.master.name as LocalizeText) ??\n              detail.master.code\n            }\n          />\n          <InfoRow\n            label=\"Type\"\n            value={detail.master.type?.replace(/_/g, \" \") ?? \"-\"}\n          />\n          <InfoRow\n            label=\"Brand\"\n            value={\n              typeof detail.master.brand === \"string\"\n                ? detail.master.brand\n                : \"-\"\n            }\n          />\n          <InfoRow\n            label=\"Category\"\n            value={\n              detail.master.category\n                ? (localized(detail.master.category.name as LocalizeText) ??\n                  detail.master.category.code ??\n                  detail.master.category.id)\n                : \"-\"\n            }\n          />\n        </div>\n        <InfoRow label=\"Description\" value={detail.master.description || \"-\"} />\n        <div className=\"flex flex-wrap gap-2\">\n          <span className=\"text-xs uppercase text-default-400\">Features</span>\n          <div className=\"flex flex-wrap gap-2\">\n            {features.length === 0 ? (\n              <span className=\"text-small text-default-500\">None</span>\n            ) : (\n              features.map(([key]) => (\n                <Chip key={key} size=\"sm\" variant=\"flat\">\n                  {key}\n                </Chip>\n              ))\n            )}\n          </div>\n        </div>\n      </section>\n\n      <Divider />\n\n      <section className=\"space-y-3\">\n        <h2 className=\"text-lg font-semibold\">Variant</h2>\n        <div className=\"grid gap-3 md:grid-cols-2\">\n          <InfoRow\n            label=\"Name\"\n            value={\n              localized(detail.variant.name as LocalizeText) ??\n              detail.master.code\n            }\n          />\n          <InfoRow label=\"SKU\" value={detail.variant.sku ?? \"-\"} />\n          <InfoRow label=\"Barcode\" value={detail.variant.barcode ?? \"-\"} />\n          <InfoRow\n            label=\"Manufacturer\"\n            value={\n              detail.variant.manufacturer\n                ? ((typeof detail.variant.manufacturer.name === \"string\"\n                    ? detail.variant.manufacturer.name\n                    : detail.variant.manufacturer.code) ?? \"-\")\n                : \"-\"\n            }\n          />\n          <InfoRow\n            label=\"Base UOM\"\n            value={\n              detail.variant.baseUom\n                ? (localized(detail.variant.baseUom.name as LocalizeText) ??\n                  detail.variant.baseUom.id)\n                : \"-\"\n            }\n          />\n        </div>\n        <InfoRow\n          label=\"Description\"\n          value={detail.variant.description || \"-\"}\n        />\n      </section>\n\n      <Divider />\n\n      <section className=\"space-y-3\">\n        <h2 className=\"text-lg font-semibold\">Packings</h2>\n        {detail.packings.length === 0 ? (\n          <p className=\"text-small text-default-500\">No packings defined.</p>\n        ) : (\n          <div className=\"space-y-3\">\n            {detail.packings.map((packing) => (\n              <Card\n                key={\n                  packing.id ??\n                  localized(packing.name as LocalizeText) ??\n                  Math.random()\n                }\n              >\n                <CardBody className=\"space-y-2\">\n                  <span className=\"font-medium\">\n                    {localized(packing.name as LocalizeText) ?? packing.id}\n                  </span>\n                  <p className=\"text-small text-default-500\">\n                    {localized(packing.description as LocalizeText) ?? \"-\"}\n                  </p>\n                </CardBody>\n              </Card>\n            ))}\n          </div>\n        )}\n      </section>\n\n      <Divider />\n\n      <section className=\"space-y-3\">\n        <h2 className=\"text-lg font-semibold\">Attributes</h2>\n        {detail.attributes.length === 0 ? (\n          <p className=\"text-small text-default-500\">No attributes defined.</p>\n        ) : (\n          <div className=\"space-y-3\">\n            {detail.attributes.map((attribute) => (\n              <Card key={attribute.id ?? attribute.code}>\n                <CardBody className=\"space-y-1\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"font-medium\">{attribute.code}</span>\n                  </div>\n                  <p className=\"text-small text-default-500\">\n                    {localized(attribute.name as LocalizeText) ??\n                      attribute.code}\n                  </p>\n                  <p className=\"text-small text-default-600\">\n                    {attribute.value}\n                  </p>\n                </CardBody>\n              </Card>\n            ))}\n          </div>\n        )}\n      </section>\n    </div>\n  );\n};\n\nconst InfoRow = ({ label, value }: { label: string; value?: string }) => (\n  <div>\n    <p className=\"text-xs uppercase text-default-400\">{label}</p>\n    <p className=\"text-sm text-default-600\">\n      {value && value !== \"\" ? value : \"-\"}\n    </p>\n  </div>\n);\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/pages/uom/UnitOfMeasureListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":72,"fix":{"range":[456,456],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":46,"fix":{"range":[158,503],"text":"import { Button, Chip } from \"@heroui/react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":33,"fix":{"range":[158,536],"text":"import { useMemo } from \"react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button, Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":45,"fix":{"range":[580,580],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":45,"fix":{"range":[158,581],"text":"import { useTranslations } from \"next-intl\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button, Chip } from \"@heroui/react\";\nimport { useMemo } from \"react\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport type { LocalizeText } from \"@base/client/interface/LocalizeText\";\nimport type { LocaleDataType } from \"@base/shared/interface/Locale\";\n\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Button, Chip } from \"@heroui/react\";\nimport { useMemo } from \"react\";\nimport { useTranslations } from \"next-intl\";\nimport { getClientLink } from \"@base/client/utils/link/getClientLink\";\n\ninterface UnitOfMeasureRow {\n  id: string;\n  name?: string | LocaleDataType<string> | null;\n  symbol?: string | null;\n  isActive?: boolean | null;\n}\n\nconst UnitOfMeasureListPage = (): React.ReactNode => {\n  const localized = useLocalizedText();\n  const t = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<UnitOfMeasureRow>[]>(() => {\n    return [\n      {\n        key: \"name\",\n        label: \"Unit name\",\n        render: (_, row) =>\n          localized((row.name ?? row.id) as LocalizeText) || row.id,\n      },\n      {\n        key: \"symbol\",\n        label: \"Symbol\",\n        render: (value) => value ?? \"—\",\n      },\n      {\n        key: \"isActive\",\n        label: \"Status\",\n        align: \"center\",\n        render: (_, row) => (\n          <Chip\n            className=\"capitalize\"\n            color={row.isActive ? \"success\" : \"default\"}\n            size=\"sm\"\n            variant=\"flat\"\n          >\n            {row.isActive ? \"active\" : \"inactive\"}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: t(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          const { as } = getClientLink({\n            mdl: \"product\",\n            path: \"uom/view/[id]\",\n            as: `uom/view/${row.id}`,\n          });\n\n          return (\n            <Button as={LinkAs as any} href={as} size=\"sm\" variant=\"light\">\n              View\n            </Button>\n          );\n        },\n      },\n    ];\n  }, [localized, t]);\n\n  const createLink = getClientLink({\n    mdl: \"product\",\n    path: \"uom/create\",\n  });\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<UnitOfMeasureRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: \"Add UOM\",\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: createLink.path,\n              hrefAs: createLink.as as any,\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"product.uom\"\n      />\n    </div>\n  );\n};\n\nexport default UnitOfMeasureListPage;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/services/ProductCategoryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/services/ProductService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/services/UnitOfMeasureService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/utils/getNameProductFeatures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/utils/getNameProductType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/utils/product-features-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/client/utils/productMapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/Product/ProductDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[276,276],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":50,"fix":{"range":[148,327],"text":"import { eq, ilike, or, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterCondition,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterCondition,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike, or, sql } from \"drizzle-orm\";\n\nimport {\n  product_tb_product_masters,\n  product_tb_product_variants,\n} from \"../../schemas\";\nimport { ProductMasterFeaturesEnum } from \"../interfaces/ProductMaster\";\n\nimport { ProductFilter } from \"./ProductModelInterface\";\n\ntype ProductDropdownOption = {\n  label: string;\n  value: string;\n  [key: string]: any;\n};\n\nclass ProductDropdownListModel extends BaseViewListModel<\n  typeof product_tb_product_variants,\n  ProductDropdownOption,\n  ProductFilter\n> {\n  constructor() {\n    super({\n      table: product_tb_product_variants,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: product_tb_product_variants.id, sort: false }],\n      [\"name\", { column: product_tb_product_variants.name, sort: false }],\n      [\"sku\", { column: product_tb_product_variants.sku, sort: false }],\n      [\"barcode\", { column: product_tb_product_variants.barcode, sort: false }],\n      [\n        \"baseUomId\",\n        { column: product_tb_product_variants.baseUomId, sort: false },\n      ],\n      [\n        \"features\",\n        { column: product_tb_product_masters.features, sort: false },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      // name is jsonb, need to cast to text before using ilike\n      [\n        \"name\",\n        (text: string) =>\n          ilike(sql`${product_tb_product_variants.name}::text`, `%${text}%`),\n      ],\n      [\n        \"sku\",\n        (text: string) => ilike(product_tb_product_variants.sku, `%${text}%`),\n      ],\n      [\n        \"barcode\",\n        (text: string) =>\n          ilike(product_tb_product_variants.barcode, `%${text}%`),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ProductFilter> => {\n    const filters: Array<[string, FilterCondition<ProductFilter>]> = [\n      [\n        \"isActive\",\n        (value?: unknown) =>\n          typeof value === \"boolean\"\n            ? eq(product_tb_product_variants.isActive, value)\n            : undefined,\n      ],\n      [\n        \"features\",\n        (value?: unknown) => {\n          const featureList = Array.isArray(value)\n            ? (value as ProductMasterFeaturesEnum[])\n            : undefined;\n\n          return featureList && featureList.length > 0\n            ? or(\n                ...featureList.map(\n                  (feature) =>\n                    sql`${product_tb_product_masters.features} ->> '${feature}' = 'true'`,\n                ),\n              )\n            : undefined;\n        },\n      ],\n    ];\n\n    return new Map(filters);\n  };\n\n  protected declarationMappingData = (row: any): ProductDropdownOption => {\n    return {\n      label: row.name,\n      value: row.id,\n      ...row,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest<ProductFilter>,\n  ): Promise<ListParamsResponse<ProductDropdownOption>> => {\n    return this.buildQueryDataList(params, (query) => {\n      return query.innerJoin(\n        product_tb_product_masters,\n        eq(\n          product_tb_product_variants.productMasterId,\n          product_tb_product_masters.id,\n        ),\n      );\n    });\n  };\n}\n\nexport default ProductDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/Product/ProductModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":59,"fix":{"range":[58,58],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseModel`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":34,"fix":{"range":[0,93],"text":"import { eq } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n\nimport {\n  product_tb_product_attributes,\n  product_tb_product_categories,\n  product_tb_product_packings,\n  product_tb_product_variants,\n  product_tb_units_of_measure,\n  product_tb_uom_conversions,\n} from \"../../schemas\";\nimport {\n  product_tb_product_masters,\n  ProductTbProductMaster,\n} from \"../../schemas/product.master\";\nimport { MasterProduct } from \"../interfaces/ProductMaster\";\n\nimport {\n  ProductAttributeInput,\n  ProductCreateInput,\n  ProductDetail,\n  ProductPackingInput,\n  ProductUpdateInput,\n} from \"./ProductModelInterface\";\n\nclass ProductModel extends BaseModel<typeof product_tb_product_variants> {\n  constructor() {\n    super(product_tb_product_variants);\n  }\n\n  private mapToMasterProduct = (\n    dbProduct: ProductTbProductMaster,\n  ): MasterProduct => {\n    return {\n      id: dbProduct.id,\n      code: dbProduct.code,\n      name: dbProduct.name as MasterProduct[\"name\"],\n      type: dbProduct.type as MasterProduct[\"type\"],\n      features: dbProduct.features as MasterProduct[\"features\"],\n      isActive: dbProduct.isActive,\n      brand: dbProduct.brand ?? undefined,\n      images: dbProduct.images as MasterProduct[\"images\"],\n      createdAt: dbProduct.createdAt?.getTime(),\n      updatedAt: dbProduct.updatedAt?.getTime(),\n      // Note: createdBy and updatedBy are stored as user IDs (strings) in DB\n      // They would need to be resolved to User objects if needed\n      // For now, we omit them as they're optional\n    };\n  };\n\n  private normalizeLocale = (value: unknown) => {\n    if (!value) {\n      return null;\n    }\n\n    if (typeof value === \"string\") {\n      return { en: value };\n    }\n\n    return value;\n  };\n\n  private getProductDetailInternal = async (\n    id: string,\n    db = this.db,\n  ): Promise<ProductDetail | null> => {\n    const rows = await db\n      .select({\n        variant: this.table,\n        master: product_tb_product_masters,\n        category: product_tb_product_categories,\n        baseUom: product_tb_units_of_measure,\n      })\n      .from(this.table)\n      .innerJoin(\n        product_tb_product_masters,\n        eq(this.table.productMasterId, product_tb_product_masters.id),\n      )\n      .leftJoin(\n        product_tb_product_categories,\n        eq(\n          product_tb_product_masters.categoryId,\n          product_tb_product_categories.id,\n        ),\n      )\n      .leftJoin(\n        product_tb_units_of_measure,\n        eq(this.table.baseUomId, product_tb_units_of_measure.id),\n      )\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const record = rows[0];\n\n    if (!record) {\n      return null;\n    }\n\n    const packings = await db\n      .select()\n      .from(product_tb_product_packings)\n      .where(eq(product_tb_product_packings.productVariantId, id));\n\n    const attributes = await db\n      .select()\n      .from(product_tb_product_attributes)\n      .where(eq(product_tb_product_attributes.productVariantId, id));\n\n    return {\n      variant: {\n        id: record.variant.id,\n        productMasterId: record.variant.productMasterId,\n        name: record.variant.name as any,\n        description: record.variant.description ?? undefined,\n        images: record.variant.images as any,\n        sku: record.variant.sku ?? undefined,\n        barcode: record.variant.barcode ?? undefined,\n        manufacturer: record.variant.manufacturer as any,\n        baseUom: record.baseUom\n          ? {\n              id: record.baseUom.id,\n              name: record.baseUom.name as any,\n              symbol: record.baseUom.symbol ?? undefined,\n              isActive: record.baseUom.isActive ?? undefined,\n            }\n          : undefined,\n        isActive: record.variant.isActive,\n        attributes: [],\n        createdAt: record.variant.createdAt?.getTime(),\n        updatedAt: record.variant.updatedAt?.getTime(),\n      },\n      master: {\n        ...this.mapToMasterProduct(record.master),\n        category: record.category\n          ? {\n              id: record.category.id,\n              code: record.category.code ?? \"\",\n              name: record.category.name as any,\n              description: record.category.description as any,\n              parentId: record.category.parentId ?? undefined,\n              level: record.category.level ?? 1,\n              isActive:\n                record.category.isActive === undefined\n                  ? true\n                  : Boolean(record.category.isActive),\n              createdAt: record.category.createdAt?.getTime(),\n              updatedAt: record.category.updatedAt?.getTime(),\n            }\n          : undefined,\n      },\n      packings: packings.map((packing) => ({\n        id: packing.id,\n        name: packing.name as any,\n        description: packing.description || undefined,\n        isActive: packing.isActive,\n        createdAt: packing.createdAt?.getTime(),\n        updatedAt: packing.updatedAt?.getTime(),\n      })),\n      attributes: attributes.map((attr) => ({\n        id: attr.id,\n        code: attr.code,\n        name: attr.name as any,\n        value: attr.value ?? \"\",\n      })),\n    };\n  };\n\n  getProductDetail = async (id: string): Promise<ProductDetail | null> => {\n    return this.getProductDetailInternal(id, this.db);\n  };\n\n  private ensurePackingValues = (\n    packings: ProductPackingInput[] | undefined,\n  ): ProductPackingInput[] => {\n    return (packings ?? []).filter((packing) => Boolean(packing?.name));\n  };\n\n  private ensureAttributeValues = (\n    attributes: ProductAttributeInput[] | undefined,\n  ): ProductAttributeInput[] => {\n    return (attributes ?? []).filter((attribute) =>\n      Boolean(attribute?.code && attribute?.name),\n    );\n  };\n\n  createProduct = async (payload: ProductCreateInput) => {\n    const now = new Date();\n\n    const result = await this.db.transaction(async (tx) => {\n      const [master] = await tx\n        .insert(product_tb_product_masters)\n        .values({\n          code: payload.master.code.trim(),\n          name: this.normalizeLocale(payload.master.name) ?? {\n            en: payload.master.code.trim(),\n          },\n          description: payload.master.description?.trim() || null,\n          type: payload.master.type,\n          features: payload.master.features ?? null,\n          isActive: payload.master.isActive ?? true,\n          brand: payload.master.brand?.trim() || null,\n          categoryId: payload.master.categoryId || null,\n          images: payload.master.images ?? null,\n          createdAt: now,\n          updatedAt: now,\n        })\n        .returning({ id: product_tb_product_masters.id });\n\n      if (!master) {\n        throw new Error(\"Failed to create product master\");\n      }\n\n      const [variant] = await tx\n        .insert(this.table)\n        .values({\n          productMasterId: master.id,\n          name: this.normalizeLocale(payload.variant.name) ?? {\n            en: payload.master.code.trim(),\n          },\n          description: payload.variant.description?.trim() || null,\n          images: payload.variant.images ?? null,\n          sku: payload.variant.sku?.trim() || null,\n          barcode: payload.variant.barcode?.trim() || null,\n          manufacturer: payload.variant.manufacturer\n            ? {\n                name: payload.variant.manufacturer.name?.trim() || undefined,\n                code: payload.variant.manufacturer.code?.trim() || undefined,\n              }\n            : null,\n          baseUomId: payload.variant.baseUomId || null,\n          saleUomId: payload.variant.saleUomId || null,\n          purchaseUomId: payload.variant.purchaseUomId || null,\n          manufacturingUomId: payload.variant.manufacturingUomId || null,\n          isActive: payload.variant.isActive ?? true,\n          createdAt: now,\n          updatedAt: now,\n        })\n        .returning({ id: this.table.id });\n\n      if (!variant) {\n        throw new Error(\"Failed to create product variant\");\n      }\n\n      const normalizedPackings = this.ensurePackingValues(payload.packings);\n\n      if (normalizedPackings.length) {\n        await tx.insert(product_tb_product_packings).values(\n          normalizedPackings.map((packing) => ({\n            productVariantId: variant.id,\n            name: this.normalizeLocale(packing.name) ?? {\n              en: packing.id ?? \"\",\n            },\n            description: packing.description?.trim() || null,\n            isActive: packing.isActive ?? true,\n            createdAt: now,\n            updatedAt: now,\n          })),\n        );\n      }\n\n      const normalizedAttributes = this.ensureAttributeValues(\n        payload.attributes,\n      );\n\n      if (normalizedAttributes.length) {\n        await tx.insert(product_tb_product_attributes).values(\n          normalizedAttributes.map((attribute) => ({\n            productVariantId: variant.id,\n            code: attribute.code.trim(),\n            name: this.normalizeLocale(attribute.name) ?? {\n              en: attribute.code.trim(),\n            },\n            value: attribute.value,\n            createdAt: now,\n            updatedAt: now,\n          })),\n        );\n      }\n\n      // Handle uomConversions - create units_of_measure records\n      const normalizedUomConversions = payload.uomConversions ?? [];\n\n      if (normalizedUomConversions.length > 0 && payload.variant.baseUomId) {\n        // Insert UOM records first\n        const uomInserts = await tx\n          .insert(product_tb_units_of_measure)\n          .values(\n            normalizedUomConversions.map((conversion) => ({\n              name: this.normalizeLocale(conversion.uomName) ?? {\n                en: conversion.uomName,\n              },\n              symbol: null,\n              isActive: true,\n              createdAt: now,\n              updatedAt: now,\n            })),\n          )\n          .returning({ id: product_tb_units_of_measure.id });\n\n        // Then insert conversion records linking to baseUomId\n        if (uomInserts.length > 0) {\n          await tx.insert(product_tb_uom_conversions).values(\n            normalizedUomConversions.map((conversion, index) => ({\n              uomId: uomInserts[index]?.id || conversion.uomId,\n              conversionRatio: conversion.conversionRatio.toString(),\n              createdAt: now,\n              updatedAt: now,\n            })),\n          );\n        }\n      }\n\n      return { id: variant.id };\n    });\n\n    return this.getProductDetail(result.id);\n  };\n\n  updateProduct = async (payload: ProductUpdateInput) => {\n    const now = new Date();\n\n    const result = await this.db.transaction(async (tx) => {\n      const existingVariant = await tx\n        .select({ id: this.table.id, masterId: this.table.productMasterId })\n        .from(this.table)\n        .where(eq(this.table.id, payload.id))\n        .limit(1);\n\n      const variantRow = existingVariant[0];\n\n      if (!variantRow) {\n        throw new Error(\"Product variant not found\");\n      }\n\n      await tx\n        .update(product_tb_product_masters)\n        .set({\n          code: payload.master.code.trim(),\n          name: this.normalizeLocale(payload.master.name) ?? {\n            en: payload.master.code.trim(),\n          },\n          description: payload.master.description?.trim() || null,\n          type: payload.master.type,\n          features: payload.master.features ?? null,\n          isActive: payload.master.isActive ?? true,\n          brand: payload.master.brand?.trim() || null,\n          categoryId: payload.master.categoryId || null,\n          images: payload.master.images ?? null,\n          updatedAt: now,\n        })\n        .where(eq(product_tb_product_masters.id, variantRow.masterId));\n\n      await tx\n        .update(this.table)\n        .set({\n          name: this.normalizeLocale(payload.variant.name) ?? {\n            en: payload.master.code.trim(),\n          },\n          description: payload.variant.description?.trim() || null,\n          images: payload.variant.images ?? null,\n          sku: payload.variant.sku?.trim() || null,\n          barcode: payload.variant.barcode?.trim() || null,\n          manufacturer: payload.variant.manufacturer\n            ? {\n                name: payload.variant.manufacturer.name?.trim() || undefined,\n                code: payload.variant.manufacturer.code?.trim() || undefined,\n              }\n            : null,\n          baseUomId: payload.variant.baseUomId || null,\n          saleUomId: payload.variant.saleUomId || null,\n          purchaseUomId: payload.variant.purchaseUomId || null,\n          manufacturingUomId: payload.variant.manufacturingUomId || null,\n          isActive: payload.variant.isActive ?? true,\n          updatedAt: now,\n        })\n        .where(eq(this.table.id, payload.id));\n\n      await tx\n        .delete(product_tb_product_packings)\n        .where(eq(product_tb_product_packings.productVariantId, payload.id));\n\n      const normalizedPackings = this.ensurePackingValues(payload.packings);\n\n      if (normalizedPackings.length) {\n        await tx.insert(product_tb_product_packings).values(\n          normalizedPackings.map((packing) => ({\n            productVariantId: payload.id,\n            name: this.normalizeLocale(packing.name) ?? {\n              en: packing.id ?? \"\",\n            },\n            description: packing.description?.trim() || null,\n            isActive: packing.isActive ?? true,\n            createdAt: now,\n            updatedAt: now,\n          })),\n        );\n      }\n\n      await tx\n        .delete(product_tb_product_attributes)\n        .where(eq(product_tb_product_attributes.productVariantId, payload.id));\n\n      const normalizedAttributes = this.ensureAttributeValues(\n        payload.attributes,\n      );\n\n      if (normalizedAttributes.length) {\n        await tx.insert(product_tb_product_attributes).values(\n          normalizedAttributes.map((attribute) => ({\n            productVariantId: payload.id,\n            code: attribute.code.trim(),\n            name: this.normalizeLocale(attribute.name) ?? {\n              en: attribute.code.trim(),\n            },\n            value: attribute.value,\n            createdAt: now,\n            updatedAt: now,\n          })),\n        );\n      }\n\n      return { id: payload.id };\n    });\n\n    return this.getProductDetail(result.id);\n  };\n}\nexport default ProductModel;\n\n// export default new ProductModel();\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/Product/ProductModelInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/Product/ProductViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":48,"fix":{"range":[252,252],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":46,"fix":{"range":[148,299],"text":"import { eq, ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike, sql } from \"drizzle-orm\";\n\nimport {\n  product_tb_product_categories,\n  product_tb_product_variants,\n  product_tb_units_of_measure,\n} from \"../../schemas\";\nimport { product_tb_product_masters } from \"../../schemas/product.master\";\n\nimport { ProductFilter, ProductVariantElm } from \"./ProductModelInterface\";\n\nclass ProductViewListModel extends BaseViewListModel<\n  typeof product_tb_product_variants,\n  // use a view row shape (any) and cast in the public API\n  any,\n  ProductFilter\n> {\n  constructor() {\n    super({\n      table: product_tb_product_variants,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: product_tb_product_variants.id, sort: true }],\n      [\"name\", { column: product_tb_product_variants.name, sort: true }],\n      [\n        \"description\",\n        { column: product_tb_product_variants.description, sort: true },\n      ],\n      [\"sku\", { column: product_tb_product_variants.sku, sort: true }],\n      [\"barcode\", { column: product_tb_product_variants.barcode, sort: true }],\n      [\n        \"manufacturer\",\n        { column: product_tb_product_variants.manufacturer, sort: true },\n      ],\n      [\"images\", { column: product_tb_product_variants.images, sort: true }],\n      [\n        \"isActive\",\n        { column: product_tb_product_variants.isActive, sort: true },\n      ],\n      [\n        \"productMasterId\",\n        { column: product_tb_product_variants.productMasterId, sort: true },\n      ],\n      [\n        \"productMasterName\",\n        { column: product_tb_product_masters.name, sort: true },\n      ],\n      [\n        \"productMasterType\",\n        { column: product_tb_product_masters.type, sort: true },\n      ],\n      [\n        \"productMasterBrand\",\n        { column: product_tb_product_masters.brand, sort: true },\n      ],\n      [\n        \"productMasterFeatures\",\n        { column: product_tb_product_masters.features, sort: true },\n      ],\n      [\"categoryId\", { column: product_tb_product_categories.id, sort: true }],\n      [\n        \"categoryName\",\n        { column: product_tb_product_categories.name, sort: true },\n      ],\n      [\n        \"categoryCode\",\n        { column: product_tb_product_categories.code, sort: true },\n      ],\n      [\n        \"baseUomId\",\n        { column: product_tb_product_variants.baseUomId, sort: true },\n      ],\n      [\"baseUomName\", { column: product_tb_units_of_measure.name, sort: true }],\n      [\n        \"createdAt\",\n        { column: product_tb_product_variants.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: product_tb_product_variants.updatedAt, sort: true },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"sku\", (text: string) => ilike(product_tb_product_variants.sku, text)],\n      [\n        \"barcode\",\n        (text: string) => ilike(product_tb_product_variants.barcode, text),\n      ],\n      [\n        \"manufacturer\",\n        (text: string) => ilike(product_tb_product_variants.manufacturer, text),\n      ],\n      [\"name\", (text: string) => ilike(product_tb_product_variants.name, text)],\n      [\n        \"productMasterCode\",\n        (text: string) => ilike(product_tb_product_masters.code, text),\n      ],\n      [\n        \"productMasterName\",\n        (text: string) =>\n          ilike(sql`${product_tb_product_masters.name}::text`, text),\n      ],\n      [\n        \"categoryCode\",\n        (text: string) => ilike(product_tb_product_categories.code, text),\n      ],\n      [\n        \"categoryName\",\n        (text: string) => ilike(product_tb_product_categories.name, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ProductFilter> =>\n    new Map([\n      [\n        \"status\",\n        (value?: unknown, _filters?: ProductFilter) =>\n          typeof value === \"boolean\"\n            ? eq(this.table.isActive, value)\n            : undefined,\n      ],\n      [\n        \"productMasterStatus\",\n        (value?: unknown, _filters?: ProductFilter) =>\n          typeof value === \"boolean\"\n            ? eq(product_tb_product_masters.isActive, value)\n            : undefined,\n      ],\n      [\n        \"productCategoryStatus\",\n        (value?: unknown, _filters?: ProductFilter) =>\n          typeof value === \"boolean\"\n            ? eq(product_tb_product_categories.isActive, value)\n            : undefined,\n      ],\n      [\n        \"baseUomStatus\",\n        (value?: unknown, _filters?: ProductFilter) =>\n          typeof value === \"boolean\"\n            ? eq(product_tb_units_of_measure.isActive, value)\n            : undefined,\n      ],\n    ]);\n\n  // Map raw DB row + joined columns -> view row\n\n  protected declarationMappingData = (row: any): ProductVariantElm => {\n    return {\n      id: row.id,\n      name: row.name,\n      description: row.description,\n      sku: row.sku,\n      barcode: row.barcode,\n      manufacturer: row.manufacturer,\n      images: row.images,\n      isActive: row.isActive,\n      productMaster: {\n        id: row.productMasterId,\n        name: row.productMasterName,\n        type: row.productMasterType,\n        brand: row.productMasterBrand,\n        features: row.productMasterFeatures,\n        category: {\n          id: row.categoryId,\n          name: row.categoryName,\n          code: row.categoryCode,\n        },\n      },\n      baseUom: {\n        id: row.baseUomId,\n        name: row.baseUomName,\n      },\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    } as unknown as ProductVariantElm;\n  };\n\n  getData = async (\n    params: ListParamsRequest<ProductFilter>,\n  ): Promise<ListParamsResponse<ProductVariantElm>> => {\n    // delegate to shared dataList (which already applies mapping)\n    const result = await this.buildQueryDataList(params, (query) => {\n      return query\n        .innerJoin(\n          product_tb_product_masters,\n          eq(this.table.productMasterId, product_tb_product_masters.id),\n        )\n        .leftJoin(\n          product_tb_product_categories,\n          eq(\n            product_tb_product_masters.categoryId,\n            product_tb_product_categories.id,\n          ),\n        )\n        .leftJoin(\n          product_tb_units_of_measure,\n          eq(this.table.baseUomId, product_tb_units_of_measure.id),\n        );\n    });\n\n    return result as ListParamsResponse<ProductVariantElm>;\n  };\n}\n\nexport default ProductViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/Product/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/ProductCategory/ProductCategoryModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":59,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/shared/interface/Locale`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":34,"fix":{"range":[0,157],"text":"import { eq } from \"drizzle-orm\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm/pg-core` import should occur before import of `@base/shared/interface/Locale`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":45,"fix":{"range":[0,202],"text":"import { alias } from \"drizzle-orm/pg-core\";\nimport { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { LocaleDataType } from \"@base/shared/interface/Locale\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { eq } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport {\n  NewProductTbProductCategory,\n  product_tb_product_categories,\n} from \"../../schemas\";\n\nconst parentCategory = alias(product_tb_product_categories, \"parent_category\");\n\nexport interface ProductCategoryRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  level?: number;\n  isActive?: boolean;\n  parent?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface ProductCategoryInput {\n  code: string;\n  name: LocaleDataType<string>;\n  description?: LocaleDataType<string> | null;\n  parentId?: string | null;\n  level?: number | null;\n  isActive?: boolean;\n}\n\nexport default class ProductCategoryModel extends BaseModel<\n  typeof product_tb_product_categories\n> {\n  constructor() {\n    super(product_tb_product_categories);\n  }\n\n  private normalizeLocaleInput(value: unknown): LocaleDataType<string> | null {\n    if (!value) return null;\n    if (typeof value === \"string\") return { en: value };\n    if (typeof value === \"object\") return value as LocaleDataType<string>;\n\n    return null;\n  }\n\n  getCategoryById = async (id: string): Promise<ProductCategoryRow | null> => {\n    const result = await this.db\n      .select({\n        id: this.table.id,\n        code: this.table.code,\n        name: this.table.name,\n        description: this.table.description,\n        level: this.table.level,\n        isActive: this.table.isActive,\n        parentId: this.table.parentId,\n        parentName: parentCategory.name,\n        createdAt: this.table.createdAt,\n        updatedAt: this.table.updatedAt,\n      })\n      .from(this.table)\n      .leftJoin(parentCategory, eq(this.table.parentId, parentCategory.id))\n      .where(eq(this.table.id, id))\n      .limit(1);\n\n    const row = result[0];\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      id: row.id,\n      code: row.code,\n      name: row.name,\n      description: row.description,\n      level: row.level ?? undefined,\n      isActive: row.isActive ?? undefined,\n      parent: row.parentId\n        ? {\n            id: row.parentId,\n            name: row.parentName ?? undefined,\n          }\n        : null,\n      createdAt: row.createdAt?.getTime(),\n      updatedAt: row.updatedAt?.getTime(),\n    };\n  };\n\n  // Helper for API dispatcher (getModuleQueryByModel) - expects params object\n  getDataById = async (params: {\n    id: string;\n  }): Promise<ProductCategoryRow | null> => {\n    return this.getCategoryById(params.id);\n  };\n\n  createCategory = async (\n    payload: ProductCategoryInput,\n  ): Promise<ProductCategoryRow> => {\n    const now = new Date();\n    const insertData: NewProductTbProductCategory = {\n      code: payload.code,\n      name: this.normalizeLocaleInput(payload.name) ?? { en: payload.code },\n      description: payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null,\n      parentId: payload.parentId ?? null,\n      isActive:\n        payload.isActive === undefined || payload.isActive === null\n          ? true\n          : payload.isActive,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    if (payload.level !== undefined && payload.level !== null) {\n      insertData.level = payload.level;\n    }\n\n    const [created] = await this.db\n      .insert(this.table)\n      .values(insertData)\n      .returning({ id: this.table.id });\n\n    if (!created) {\n      throw new Error(\"Failed to create product category\");\n    }\n\n    const row = await this.getCategoryById(created.id);\n\n    if (!row) {\n      throw new Error(\"Failed to load product category after creation\");\n    }\n\n    return row;\n  };\n\n  updateCategory = async (\n    id: string,\n    payload: Partial<ProductCategoryInput>,\n  ): Promise<ProductCategoryRow | null> => {\n    const updateData: Partial<typeof this.table.$inferInsert> = {\n      updatedAt: new Date(),\n    };\n\n    if (payload.code !== undefined) updateData.code = payload.code;\n    if (payload.name !== undefined)\n      updateData.name = this.normalizeLocaleInput(payload.name) ?? undefined;\n    if (payload.description !== undefined)\n      updateData.description = payload.description\n        ? typeof payload.description === \"string\"\n          ? payload.description\n          : JSON.stringify(payload.description)\n        : null;\n    if (payload.parentId !== undefined)\n      updateData.parentId = payload.parentId ?? null;\n    if (payload.level !== undefined) {\n      if (payload.level !== null) {\n        updateData.level = payload.level;\n      }\n    }\n    if (payload.isActive !== undefined) updateData.isActive = payload.isActive;\n\n    await this.db\n      .update(this.table)\n      .set(updateData)\n      .where(eq(this.table.id, id));\n\n    return this.getCategoryById(id);\n  };\n\n  /**\n   * Wrapper used by getModuleQueryByModel for update via API\n   * Accepts raw payload from controller and applies normalization logic.\n   */\n\n  updateData = async (params: { id: string; payload: any }) => {\n    const { id, payload } = params;\n\n    const normalizedPayload: Partial<ProductCategoryInput> = {};\n\n    if (payload.code !== undefined) {\n      normalizedPayload.code = String(payload.code);\n    }\n    if (payload.name !== undefined) {\n      normalizedPayload.name = this.normalizeLocaleInput(payload.name) ?? {\n        en: \"\",\n      };\n    }\n    if (payload.description !== undefined) {\n      normalizedPayload.description = this.normalizeLocaleInput(\n        payload.description,\n      );\n    }\n    if (payload.parentId !== undefined) {\n      normalizedPayload.parentId =\n        payload.parentId === null || payload.parentId === \"\"\n          ? null\n          : String(payload.parentId);\n    }\n    if (payload.level !== undefined) {\n      normalizedPayload.level =\n        payload.level === null || payload.level === \"\"\n          ? null\n          : Number(payload.level);\n    }\n    if (payload.isActive !== undefined) {\n      normalizedPayload.isActive = Boolean(payload.isActive);\n    }\n\n    return this.updateCategory(id, normalizedPayload);\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/ProductCategory/ProductCategoryViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/server/models/BaseViewListModel` import should occur after import of `drizzle-orm/pg-core`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[223,414],"text":"import { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { eq, ilike } from \"drizzle-orm\";\nimport { alias } from \"drizzle-orm/pg-core\";\n\nimport { product_tb_product_categories } from \"../../schemas\";\n\nconst parentCategory = alias(product_tb_product_categories, \"parent_category\");\n\nexport interface ProductCategoryRow {\n  id: string;\n  code: string;\n  name?: unknown;\n  description?: unknown;\n  level?: number;\n  isActive?: boolean;\n  parent?: {\n    id: string;\n    name?: unknown;\n  } | null;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nclass ProductCategoryViewListModel extends BaseViewListModel<\n  typeof product_tb_product_categories,\n  ProductCategoryRow\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: product_tb_product_categories.id, sort: true }],\n      [\"code\", { column: product_tb_product_categories.code, sort: true }],\n      [\"name\", { column: product_tb_product_categories.name, sort: true }],\n      [\n        \"description\",\n        { column: product_tb_product_categories.description, sort: false },\n      ],\n      [\"level\", { column: product_tb_product_categories.level, sort: true }],\n      [\n        \"isActive\",\n        { column: product_tb_product_categories.isActive, sort: true },\n      ],\n      [\n        \"parentId\",\n        { column: product_tb_product_categories.parentId, sort: true },\n      ],\n      [\n        \"createdAt\",\n        { column: product_tb_product_categories.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: product_tb_product_categories.updatedAt, sort: true },\n      ],\n    ]);\n\n  constructor() {\n    super({ table: product_tb_product_categories });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"code\",\n        (text: string) => ilike(product_tb_product_categories.code, text),\n      ],\n      [\n        \"name\",\n        (text: string) => ilike(product_tb_product_categories.name, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): ProductCategoryRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    description: row.description,\n    level: row.level ?? undefined,\n    isActive: row.isActive ?? undefined,\n    parent: row.parentId\n      ? {\n          id: row.parentId,\n          name: row.parentName ?? undefined,\n        }\n      : null,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<ProductCategoryRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query.leftJoin(\n        parentCategory,\n        eq(this.table.parentId, parentCategory.id),\n      ),\n    );\n  };\n}\n\nexport default ProductCategoryViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/ProductFeatures/ProductFeaturesDropdownListModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/ProductMasterType/ProductMasterTypeDropdownListModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/ProductUom/ProductUomDropdownListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[276,276],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":51,"fix":{"range":[148,328],"text":"import { asc, eq, ilike, sql } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterCondition,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { Column } from \"drizzle-orm\";\n\nimport {\n  BaseViewListModel,\n  type FilterCondition,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { asc, eq, ilike, sql } from \"drizzle-orm\";\n\nimport { product_tb_units_of_measure } from \"../../schemas\";\n\ntype UomFilter = {\n  isActive?: boolean;\n};\n\ntype ProductUomDropdownOption = {\n  label: string;\n  value: string;\n  [key: string]: any;\n};\n\nclass ProductUomDropdownListModel extends BaseViewListModel<\n  typeof product_tb_units_of_measure,\n  ProductUomDropdownOption,\n  UomFilter\n> {\n  constructor() {\n    super({\n      table: product_tb_units_of_measure,\n      sortDefault: [\n        {\n          column: \"name\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: product_tb_units_of_measure.id, sort: false }],\n      [\"name\", { column: product_tb_units_of_measure.name, sort: false }],\n      [\"symbol\", { column: product_tb_units_of_measure.symbol, sort: false }],\n      [\n        \"isActive\",\n        { column: product_tb_units_of_measure.isActive, sort: false },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      // name is jsonb, need to cast to text before using ilike\n      [\n        \"name\",\n        (text: string) =>\n          ilike(sql`${product_tb_units_of_measure.name}::text`, `%${text}%`),\n      ],\n      [\n        \"symbol\",\n        (text: string) =>\n          ilike(product_tb_units_of_measure.symbol, `%${text}%`),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<UomFilter> => {\n    const filters: Array<[string, FilterCondition<UomFilter>]> = [\n      [\n        \"isActive\",\n        (value?: unknown) =>\n          typeof value === \"boolean\"\n            ? eq(product_tb_units_of_measure.isActive, value)\n            : undefined,\n      ],\n    ];\n\n    return new Map(filters);\n  };\n\n  protected declarationMappingData = (row: any): ProductUomDropdownOption => {\n    return {\n      label: row.name,\n      value: row.id,\n      symbol: row.symbol,\n    };\n  };\n\n  getData = async (\n    params: ListParamsRequest<UomFilter>,\n  ): Promise<ListParamsResponse<ProductUomDropdownOption>> => {\n    return this.buildQueryDataList(params, (query) => {\n      return query.orderBy(asc(product_tb_units_of_measure.name));\n    });\n  };\n}\n\nexport default ProductUomDropdownListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductAttribute.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductCategory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductMaster.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductPacking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductUom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/models/interfaces/ProductVariant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.attribute.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.category.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.master.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.packing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-asset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-consumable.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-finished-good.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-goods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-raw-material.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.type-tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.uom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/product.variant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/asset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/consumable.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/finished-good.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/goods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/raw-material.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/optional-fields/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/product/server/utils/product-features-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/client/interface/PurchaseOrder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/client/pages/Orders/PurchaseOrderCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `valibot`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":34,"fix":{"range":[15,732],"text":"import LinkAs from \"@base/client/components/LinkAs\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  array,\n  custom,\n  minLength,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components/LinkAs` import should occur after import of `valibot`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":53,"fix":{"range":[113,732],"text":"import { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  array,\n  custom,\n  minLength,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":70,"fix":{"range":[235,235],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `valibot`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":70,"fix":{"range":[166,732],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  array,\n  custom,\n  minLength,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":31,"endColumn":18,"fix":{"range":[731,731],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"\"use client\";\n\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useMemo } from \"react\";\nimport {\n  Controller,\n  useFieldArray,\n  useForm,\n  type SubmitHandler,\n} from \"react-hook-form\";\nimport {\n  array,\n  custom,\n  minLength,\n  object,\n  optional,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport StockService from \"@mdl/stock/client/services/StockService\";\n\nimport { purchaseOrderService } from \"../../services/PurchaseOrderService\";\n\nconst quantitySchema = pipe(\n  string(),\n  trim(),\n  minLength(1, \"Quantity is required\"),\n  custom(\n    (value) => !Number.isNaN(Number(value)) && Number(value) > 0,\n    \"Quantity must be a positive number\",\n  ),\n);\n\nconst unitPriceSchema = pipe(\n  string(),\n  trim(),\n  custom(\n    (value) =>\n      value === \"\" || (!Number.isNaN(Number(value)) && Number(value) >= 0),\n    \"Unit price must be a number greater than or equal to 0\",\n  ),\n);\n\nconst orderLineSchema = object({\n  productId: pipe(string(), trim(), minLength(1, \"Product ID is required\")),\n  quantity: quantitySchema,\n  unitPrice: unitPriceSchema,\n  description: optional(pipe(string(), trim())),\n});\n\nconst purchaseOrderFormSchema = object({\n  vendorName: pipe(string(), trim(), minLength(1, \"Vendor name is required\")),\n  warehouseId: optional(pipe(string(), trim())),\n  expectedDate: optional(pipe(string(), trim())),\n  currency: pipe(string(), trim(), minLength(1, \"Currency is required\")),\n  notes: optional(pipe(string(), trim())),\n  lines: pipe(\n    array(orderLineSchema),\n    minLength(1, \"At least one order line is required\"),\n  ),\n});\n\ntype PurchaseOrderFormValues = {\n  vendorName: string;\n  warehouseId?: string;\n  expectedDate?: string;\n  currency: string;\n  notes?: string;\n  lines: Array<{\n    productId: string;\n    quantity: string;\n    unitPrice: string;\n    description?: string;\n  }>;\n};\n\nconst defaultLine: PurchaseOrderFormValues[\"lines\"][number] = {\n  productId: \"\",\n  quantity: \"\",\n  unitPrice: \"\",\n  description: \"\",\n};\n\nexport default function PurchaseOrderCreatePage(): React.ReactNode {\n  const router = useRouter();\n\n  const {\n    control,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm<PurchaseOrderFormValues>({\n    resolver: valibotResolver(purchaseOrderFormSchema),\n    defaultValues: {\n      vendorName: \"\",\n      warehouseId: \"\",\n      expectedDate: \"\",\n      currency: \"USD\",\n      notes: \"\",\n      lines: [defaultLine],\n    },\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: \"lines\",\n  });\n\n  const warehousesQuery = useQuery({\n    queryKey: [\"warehouses\"],\n    queryFn: async () => {\n      const response = await StockService.listWarehouses();\n\n      return response.data ?? [];\n    },\n  });\n\n  const { handleSubmit: submitOrder, error: submitError } = useCreateUpdate<\n    {\n      vendorName: string;\n      warehouseId?: string;\n      expectedDate?: string;\n      currency?: string;\n      notes?: string;\n      lines: Array<{\n        productId: string;\n        quantity: number;\n        unitPrice?: number;\n        description?: string;\n      }>;\n    },\n    {\n      order: { id: string };\n    }\n  >({\n    mutationFn: async (payload) => {\n      const response = await purchaseOrderService.create(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Failed to create purchase order.\");\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"purchaseOrders\"]],\n    onSuccess: (data) => {\n      router.push(`/workspace/modules/purchase/view/${data.order.id}`);\n    },\n  });\n\n  const onSubmit: SubmitHandler<PurchaseOrderFormValues> = async (values) => {\n    const payload = {\n      vendorName: values.vendorName.trim(),\n      warehouseId: values.warehouseId?.trim() || undefined,\n      expectedDate: values.expectedDate?.trim() || undefined,\n      currency: values.currency.trim(),\n      notes: values.notes?.trim() || undefined,\n      lines: values.lines\n        .map((line) => ({\n          productId: line.productId.trim(),\n          quantity: Number(line.quantity),\n          unitPrice: line.unitPrice ? Number(line.unitPrice) : undefined,\n          description: line.description?.trim() || undefined,\n        }))\n        .filter((line) => line.productId && line.quantity > 0),\n    };\n\n    await submitOrder(payload);\n  };\n\n  const warehouseOptions = useMemo<SelectItemOption[]>(\n    () =>\n      (warehousesQuery.data ?? []).map((warehouse) => ({\n        value: warehouse.id,\n        label: `${warehouse.code} — ${warehouse.name}`,\n      })),\n    [warehousesQuery.data],\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-end\">\n        <Button\n          as={LinkAs as any}\n          href=\"/workspace/modules/purchase\"\n          size=\"sm\"\n          variant=\"light\"\n        >\n          Back to list\n        </Button>\n      </div>\n\n      <Card>\n        <CardBody>\n          {submitError ? (\n            <div className=\"mb-4 rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n              {submitError}\n            </div>\n          ) : null}\n          {warehousesQuery.isError ? (\n            <div className=\"mb-4 rounded-large border border-warning-200 bg-warning-50 px-3 py-2 text-sm text-warning-600\">\n              {warehousesQuery.error instanceof Error\n                ? warehousesQuery.error.message\n                : \"Unable to load warehouses. You can continue without selecting one.\"}\n            </div>\n          ) : null}\n          <form className=\"space-y-6\" onSubmit={handleSubmit(onSubmit)}>\n            <div className=\"grid gap-4 md:grid-cols-2\">\n              <Controller\n                control={control}\n                name=\"vendorName\"\n                render={({ field, fieldState }) => (\n                  <IBaseInput\n                    {...field}\n                    isRequired\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label=\"Vendor name\"\n                    value={field.value}\n                    onValueChange={field.onChange}\n                  />\n                )}\n              />\n              <Controller\n                control={control}\n                name=\"warehouseId\"\n                render={({ field, fieldState }) => (\n                  <IBaseSingleSelect\n                    errorMessage={fieldState.error?.message}\n                    isDisabled={warehousesQuery.isLoading}\n                    isInvalid={fieldState.invalid}\n                    items={warehouseOptions}\n                    label=\"Warehouse (optional)\"\n                    selectedKey={field.value}\n                    onSelectionChange={(key) => {\n                      field.onChange(key || undefined);\n                    }}\n                  />\n                )}\n              />\n              <Controller\n                control={control}\n                name=\"expectedDate\"\n                render={({ field, fieldState }) => (\n                  <IBaseInput\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label=\"Expected date\"\n                    type=\"date\"\n                    value={field.value ?? \"\"}\n                    onValueChange={field.onChange}\n                  />\n                )}\n              />\n              <Controller\n                control={control}\n                name=\"currency\"\n                render={({ field, fieldState }) => (\n                  <IBaseInput\n                    {...field}\n                    errorMessage={fieldState.error?.message}\n                    isInvalid={fieldState.invalid}\n                    label=\"Currency\"\n                    value={field.value}\n                    onValueChange={field.onChange}\n                  />\n                )}\n              />\n            </div>\n\n            <Controller\n              control={control}\n              name=\"notes\"\n              render={({ field, fieldState }) => (\n                <Textarea\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label=\"Notes\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <h2 className=\"text-lg font-semibold\">Order lines</h2>\n                <Button\n                  size=\"sm\"\n                  variant=\"bordered\"\n                  onPress={() => append(defaultLine)}\n                >\n                  Add line\n                </Button>\n              </div>\n\n              {fields.map((fieldItem, index) => (\n                <Card key={fieldItem.id} className=\"border border-content3/40\">\n                  <CardBody className=\"space-y-3\">\n                    <div className=\"grid gap-3 md:grid-cols-4\">\n                      <Controller\n                        control={control}\n                        name={`lines.${index}.productId`}\n                        render={({ field, fieldState }) => (\n                          <IBaseInput\n                            {...field}\n                            isRequired\n                            errorMessage={fieldState.error?.message}\n                            isInvalid={fieldState.invalid}\n                            label=\"Product ID\"\n                            value={field.value}\n                            onValueChange={field.onChange}\n                          />\n                        )}\n                      />\n                      <Controller\n                        control={control}\n                        name={`lines.${index}.quantity`}\n                        render={({ field, fieldState }) => (\n                          <IBaseInput\n                            {...field}\n                            isRequired\n                            errorMessage={fieldState.error?.message}\n                            isInvalid={fieldState.invalid}\n                            label=\"Quantity\"\n                            type=\"number\"\n                            value={field.value}\n                            onValueChange={field.onChange}\n                          />\n                        )}\n                      />\n                      <Controller\n                        control={control}\n                        name={`lines.${index}.unitPrice`}\n                        render={({ field, fieldState }) => (\n                          <IBaseInput\n                            {...field}\n                            errorMessage={fieldState.error?.message}\n                            isInvalid={fieldState.invalid}\n                            label=\"Unit price\"\n                            type=\"number\"\n                            value={field.value}\n                            onValueChange={field.onChange}\n                          />\n                        )}\n                      />\n                      <Controller\n                        control={control}\n                        name={`lines.${index}.description`}\n                        render={({ field, fieldState }) => (\n                          <IBaseInput\n                            {...field}\n                            errorMessage={fieldState.error?.message}\n                            isInvalid={fieldState.invalid}\n                            label=\"Description\"\n                            value={field.value ?? \"\"}\n                            onValueChange={field.onChange}\n                          />\n                        )}\n                      />\n                    </div>\n                    {fields.length > 1 ? (\n                      <div className=\"flex justify-end\">\n                        <Button\n                          size=\"sm\"\n                          variant=\"light\"\n                          onPress={() => remove(index)}\n                        >\n                          Remove\n                        </Button>\n                      </div>\n                    ) : null}\n                  </CardBody>\n                </Card>\n              ))}\n              {errors.lines?.message ? (\n                <p className=\"text-sm text-danger-600\">\n                  {errors.lines.message as string}\n                </p>\n              ) : null}\n            </div>\n\n            <Button\n              color=\"primary\"\n              disabled={isSubmitting}\n              isLoading={isSubmitting}\n              type=\"submit\"\n            >\n              Create purchase order\n            </Button>\n          </form>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/client/pages/Orders/PurchaseOrderDetailPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":54,"fix":{"range":[15,553],"text":"import LinkAs from \"@base/client/components/LinkAs\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport {\n  Card,\n  CardBody,\n  Chip,\n  Divider,\n  Spinner,\n  Table,\n  TableBody,\n  TableCell,\n  TableColumn,\n  TableHeader,\n  TableRow,\n} from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { IBaseInput } from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components/LinkAs` import should occur after import of `react`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":53,"fix":{"range":[69,553],"text":"import { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport {\n  Card,\n  CardBody,\n  Chip,\n  Divider,\n  Spinner,\n  Table,\n  TableBody,\n  TableCell,\n  TableColumn,\n  TableHeader,\n  TableRow,\n} from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":70,"fix":{"range":[191,191],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":70,"fix":{"range":[122,553],"text":"import { Button } from \"@heroui/button\";\nimport {\n  Card,\n  CardBody,\n  Chip,\n  Divider,\n  Spinner,\n  Table,\n  TableBody,\n  TableCell,\n  TableColumn,\n  TableHeader,\n  TableRow,\n} from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport { IBaseInput } from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport {\n  Card,\n  CardBody,\n  Chip,\n  Divider,\n  Spinner,\n  Table,\n  TableBody,\n  TableCell,\n  TableColumn,\n  TableHeader,\n  TableRow,\n} from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport {\n  PurchaseOrderDto,\n  PurchaseOrderLineDto,\n  purchaseOrderService,\n} from \"../../services/PurchaseOrderService\";\n\nexport default function PurchaseOrderDetailPage(): React.ReactNode {\n  const params = useParams<{ id: string }>();\n  const router = useRouter();\n  const orderId = Array.isArray(params?.id) ? params?.id[0] : params?.id;\n\n  const [receiveNote, setReceiveNote] = useState(\"\");\n  const [receiveWarehouseId, setReceiveWarehouseId] = useState<string>(\"\");\n  const [quantities, setQuantities] = useState<Record<string, string>>({});\n  const [localError, setLocalError] = useState<string | null>(null);\n\n  const orderQuery = useQuery({\n    queryKey: [\"purchaseOrder\", orderId],\n    enabled: Boolean(orderId),\n    queryFn: async () => {\n      if (!orderId) {\n        throw new Error(\"Purchase order identifier is missing.\");\n      }\n\n      const response = await purchaseOrderService.getById(orderId);\n\n      if (!response.data) {\n        throw new Error(\"Failed to fetch purchase order.\");\n      }\n\n      return response.data;\n    },\n  });\n\n  const order = orderQuery.data?.order ?? null;\n  const lines = orderQuery.data?.lines ?? [];\n\n  useEffect(() => {\n    if (!order || lines.length === 0) {\n      return;\n    }\n\n    setReceiveWarehouseId(order.warehouseId ?? \"\");\n    setQuantities(\n      lines.reduce<Record<string, string>>((acc, line) => {\n        acc[line.id] = \"0\";\n\n        return acc;\n      }, {}),\n    );\n  }, [order?.id, order?.warehouseId, lines]);\n\n  const pendingLines = useMemo(\n    () =>\n      lines.filter(\n        (line) =>\n          Number(line.quantityOrdered) - Number(line.quantityReceived) > 0.0001,\n      ),\n    [lines],\n  );\n\n  const {\n    handleSubmit: confirmOrder,\n    isPending: isConfirming,\n    error: confirmError,\n  } = useCreateUpdate<string, PurchaseOrderDto>({\n    mutationFn: async (id) => {\n      const response = await purchaseOrderService.confirm(id);\n\n      if (!response.data) {\n        throw new Error(\"Failed to confirm purchase order.\");\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"purchaseOrder\", orderId], [\"purchaseOrders\"]],\n    onSuccess: () => {\n      orderQuery.refetch();\n    },\n  });\n\n  const {\n    handleSubmit: receiveOrder,\n    isPending: isReceiving,\n    error: receiveError,\n  } = useCreateUpdate<\n    {\n      orderId: string;\n      warehouseId?: string;\n      note?: string;\n      lines: Array<{ lineId: string; quantity: number }>;\n    },\n    { order: PurchaseOrderDto; lines: PurchaseOrderLineDto[] }\n  >({\n    mutationFn: async (payload) => {\n      const response = await purchaseOrderService.receive(payload);\n\n      if (!response.data) {\n        throw new Error(\"Failed to receive products.\");\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"purchaseOrder\", orderId], [\"purchaseOrders\"]],\n    onSuccess: () => {\n      setReceiveNote(\"\");\n      setLocalError(null);\n      orderQuery.refetch();\n    },\n  });\n\n  const actionError = confirmError ?? receiveError ?? localError;\n\n  if (!orderId) {\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-600\">\n          Purchase order identifier is missing.\n        </div>\n        <Button\n          as={LinkAs as any}\n          href=\"/workspace/modules/purchase\"\n          size=\"sm\"\n          variant=\"light\"\n        >\n          Back to list\n        </Button>\n      </div>\n    );\n  }\n\n  if (orderQuery.isLoading) {\n    return (\n      <div className=\"flex h-full items-center justify-center\">\n        <Spinner label=\"Loading purchase order...\" />\n      </div>\n    );\n  }\n\n  if (orderQuery.isError) {\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-600\">\n          {orderQuery.error instanceof Error\n            ? orderQuery.error.message\n            : \"Failed to fetch purchase order.\"}\n        </div>\n        <Button\n          as={LinkAs as any}\n          href=\"/workspace/modules/purchase\"\n          size=\"sm\"\n          variant=\"light\"\n        >\n          Back to list\n        </Button>\n      </div>\n    );\n  }\n\n  if (!order) {\n    return (\n      <div className=\"space-y-4\">\n        <p className=\"text-default-500\">Purchase order not found.</p>\n        <Button\n          as={LinkAs as any}\n          href=\"/workspace/modules/purchase\"\n          size=\"sm\"\n          variant=\"light\"\n        >\n          Back to list\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-end\">\n        <Button\n          as={LinkAs as any}\n          href=\"/workspace/modules/purchase\"\n          size=\"sm\"\n          variant=\"light\"\n        >\n          Back to list\n        </Button>\n      </div>\n\n      {actionError ? (\n        <div className=\"rounded-medium border border-danger-200 bg-danger-50 px-4 py-3 text-sm text-danger-600\">\n          {actionError}\n        </div>\n      ) : null}\n\n      <Card>\n        <CardBody className=\"space-y-3\">\n          <div className=\"flex flex-wrap items-center gap-3\">\n            <Chip color=\"primary\" variant=\"flat\">\n              Status: {order.status}\n            </Chip>\n            <Chip variant=\"flat\">\n              Expected:{\" \"}\n              {order.expectedDate\n                ? new Date(order.expectedDate).toLocaleDateString()\n                : \"—\"}\n            </Chip>\n            <Chip variant=\"flat\">\n              Total:{\" \"}\n              {Number(order.totalAmount || 0).toLocaleString(undefined, {\n                style: \"currency\",\n                currency: order.currency || \"USD\",\n              })}\n            </Chip>\n            <Chip variant=\"flat\">Vendor: {order.vendorName}</Chip>\n          </div>\n          {order.notes ? (\n            <p className=\"text-default-500\">Notes: {order.notes}</p>\n          ) : null}\n        </CardBody>\n      </Card>\n\n      <Card>\n        <CardBody className=\"space-y-3\">\n          <h2 className=\"text-lg font-semibold\">Lines</h2>\n          <Table removeWrapper aria-label=\"Purchase order lines\">\n            <TableHeader>\n              <TableColumn>Product</TableColumn>\n              <TableColumn>Description</TableColumn>\n              <TableColumn>Ordered</TableColumn>\n              <TableColumn>Received</TableColumn>\n              <TableColumn>Unit Price</TableColumn>\n            </TableHeader>\n            <TableBody>\n              {lines.map((line) => (\n                <TableRow key={line.id}>\n                  <TableCell>{line.productId}</TableCell>\n                  <TableCell>{line.description || \"—\"}</TableCell>\n                  <TableCell>\n                    {Number(line.quantityOrdered).toFixed(2)}\n                  </TableCell>\n                  <TableCell>\n                    {Number(line.quantityReceived).toFixed(2)}\n                  </TableCell>\n                  <TableCell>\n                    {Number(line.unitPrice).toLocaleString(undefined, {\n                      style: \"currency\",\n                      currency: order.currency || \"USD\",\n                    })}\n                  </TableCell>\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </CardBody>\n      </Card>\n\n      <div className=\"flex items-center gap-3\">\n        <Button\n          color=\"primary\"\n          isDisabled={order.status !== \"draft\"}\n          isLoading={isConfirming}\n          size=\"sm\"\n          onPress={() => confirmOrder(orderId)}\n        >\n          Confirm order\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/stock\")}\n        >\n          Go to stock dashboard\n        </Button>\n      </div>\n\n      <Divider />\n\n      <Card>\n        <CardBody className=\"space-y-4\">\n          <div>\n            <h2 className=\"text-lg font-semibold\">Receive products</h2>\n            <p className=\"text-default-500\">\n              Record products received from the vendor. Enter only the\n              quantities being received now.\n            </p>\n          </div>\n          <div className=\"grid gap-3 md:grid-cols-2\">\n            <IBaseInput\n              label=\"Warehouse\"\n              placeholder=\"Warehouse ID (fallback to order warehouse)\"\n              value={receiveWarehouseId}\n              onValueChange={setReceiveWarehouseId}\n            />\n            <IBaseInput\n              label=\"Reference\"\n              placeholder=\"Optional reference\"\n              value={receiveNote}\n              onValueChange={setReceiveNote}\n            />\n          </div>\n\n          {pendingLines.length === 0 ? (\n            <p className=\"text-default-500\">\n              All lines have been fully received.\n            </p>\n          ) : (\n            <div className=\"space-y-3\">\n              {pendingLines.map((line) => {\n                const openQty =\n                  Number(line.quantityOrdered) - Number(line.quantityReceived);\n\n                return (\n                  <div\n                    key={line.id}\n                    className=\"grid gap-3 rounded-medium border border-content3/50 p-3 md:grid-cols-4\"\n                  >\n                    <div>\n                      <p className=\"font-medium\">{line.productId}</p>\n                      <p className=\"text-xs text-default-500\">\n                        Remaining: {openQty.toFixed(2)}\n                      </p>\n                    </div>\n                    <IBaseInput\n                      label=\"Quantity to receive\"\n                      max={openQty}\n                      min={0}\n                      type=\"number\"\n                      value={quantities[line.id] ?? \"0\"}\n                      onValueChange={(value: string) =>\n                        setQuantities((prev) => ({\n                          ...prev,\n                          [line.id]: value,\n                        }))\n                      }\n                    />\n                    <IBaseInput\n                      isReadOnly\n                      label=\"Description\"\n                      value={line.description ?? \"\"}\n                    />\n                    <IBaseInput\n                      isReadOnly\n                      label=\"Ordered / Received\"\n                      value={`${Number(line.quantityOrdered).toFixed(\n                        2,\n                      )} / ${Number(line.quantityReceived).toFixed(2)}`}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          )}\n\n          <Button\n            color=\"primary\"\n            isDisabled={pendingLines.length === 0}\n            isLoading={isReceiving}\n            onPress={async () => {\n              if (!orderId) return;\n\n              const payloadLines = Object.entries(quantities)\n                .map(([lineId, quantity]) => ({\n                  lineId,\n                  quantity: Number(quantity),\n                }))\n                .filter((line) => line.quantity > 0);\n\n              if (payloadLines.length === 0) {\n                setLocalError(\"Enter at least one quantity to receive.\");\n\n                return;\n              }\n\n              await receiveOrder({\n                orderId,\n                warehouseId: receiveWarehouseId || undefined,\n                note: receiveNote || undefined,\n                lines: payloadLines,\n              });\n            }}\n          >\n            Receive selected quantities\n          </Button>\n        </CardBody>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/client/pages/Orders/PurchaseOrdersListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":65,"fix":{"range":[373,373],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[15,412],"text":"import { Chip } from \"@heroui/react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[15,457],"text":"import { useTranslations } from \"next-intl\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components/ActionMenu/ActionMenu`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[15,490],"text":"import { useMemo } from \"react\";\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport ActionMenu from \"@base/client/components/ActionMenu/ActionMenu\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { formatDate } from \"@base/client/utils/date/formatDate\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nimport { PurchaseOrder } from \"../../interface/PurchaseOrder\";\n\ntype PurchaseOrderRow = PurchaseOrder & {\n  expectedDate?: number | string | null;\n  createdAt?: number | string | null;\n};\n\nexport default function PurchaseOrdersListPage(): React.ReactNode {\n  const t = useTranslations(\"purchase.orders.list\");\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<PurchaseOrderRow>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"columns.code\"),\n        render: (value, row) => {\n          if (!row?.id) return value;\n\n          return (\n            <LinkAs href={`/workspace/modules/purchase/view/${row.id}`}>\n              {row.code}\n            </LinkAs>\n          );\n        },\n      },\n      {\n        key: \"vendorName\",\n        label: t(\"columns.vendor\"),\n      },\n      {\n        key: \"status\",\n        label: t(\"columns.status\"),\n        render: (value) => (\n          <Chip className=\"capitalize\" size=\"sm\" variant=\"flat\">\n            {t(`status.${value || \"draft\"}`)}\n          </Chip>\n        ),\n      },\n      {\n        key: \"expectedDate\",\n        label: t(\"columns.expectedDate\"),\n        render: (value) => formatDate(value),\n      },\n      {\n        key: \"totalAmount\",\n        label: t(\"columns.totalAmount\"),\n        render: (_, row) =>\n          new Intl.NumberFormat(undefined, {\n            style: \"currency\",\n            currency: row.currency || \"USD\",\n          }).format(Number(row.totalAmount ?? 0)),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => {\n          if (!row?.id) return null;\n          const viewLink = `/workspace/modules/purchase/view/${row.id}`;\n\n          return (\n            <ActionMenu\n              actions={[\n                {\n                  key: \"view\",\n                  label: t(\"actions.view\"),\n                  href: viewLink,\n                },\n              ]}\n            />\n          );\n        },\n      },\n    ],\n    [t, tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<PurchaseOrderRow>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"actions.new\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/purchase/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"purchase-order\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/client/services/PurchaseOrderService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/models/Purchase/PurchaseOrderModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":45,"fix":{"range":[244,244],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type {\n  NewPurchaseTbPurchaseOrder,\n  PurchaseTbPurchaseOrder,\n  PurchaseTbPurchaseOrderLine,\n} from \"../../schemas\";\nimport type StockModel from \"@mdl/stock/server/models/Stock/StockModel\";\n\nimport { desc, eq, sql } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\n\nimport {\n  purchase_tb_purchase_orders,\n  purchase_tb_purchase_orders_line,\n} from \"../../schemas\";\n\ntype PurchaseStatus = \"draft\" | \"confirmed\" | \"received\" | \"cancelled\";\n\ninterface PurchaseOrderLineInput {\n  productId: string;\n  quantity: number;\n  unitPrice?: number;\n  description?: string;\n}\n\ninterface CreatePurchaseOrderInput {\n  code?: string;\n  vendorName: string;\n  warehouseId?: string;\n  expectedDate?: string;\n  currency?: string;\n  notes?: string;\n  lines: PurchaseOrderLineInput[];\n  userId?: string;\n}\n\ninterface ReceivePurchaseOrderInput {\n  orderId: string;\n  warehouseId?: string;\n  lines: Array<{\n    lineId: string;\n    quantity: number;\n  }>;\n  reference?: string;\n  note?: string;\n  userId?: string;\n}\n\nexport default class PurchaseOrderModel extends BaseModel<\n  typeof purchase_tb_purchase_orders\n> {\n  constructor() {\n    super(purchase_tb_purchase_orders);\n  }\n\n  list = async (): Promise<PurchaseTbPurchaseOrder[]> => {\n    return this.db\n      .select()\n      .from(purchase_tb_purchase_orders)\n      .orderBy(desc(purchase_tb_purchase_orders.createdAt));\n  };\n\n  getById = async (id: string) => {\n    const [order] = await this.db\n      .select()\n      .from(purchase_tb_purchase_orders)\n      .where(eq(purchase_tb_purchase_orders.id, id))\n      .limit(1);\n\n    if (!order) {\n      return null;\n    }\n    const lines = await this.db\n      .select()\n      .from(purchase_tb_purchase_orders_line)\n      .where(eq(purchase_tb_purchase_orders_line.orderId, order.id));\n\n    return { order, lines };\n  };\n\n  create = async (input: CreatePurchaseOrderInput) => {\n    if (!input.lines?.length) {\n      throw new Error(\"Purchase order requires at least one line\");\n    }\n\n    const now = new Date();\n    const generatedCode =\n      input.code?.trim() ||\n      `PO-${now.getFullYear()}${(now.getMonth() + 1)\n        .toString()\n        .padStart(2, \"0\")}${now\n        .getDate()\n        .toString()\n        .padStart(\n          2,\n          \"0\",\n        )}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;\n\n    return this.db.transaction(async (tx) => {\n      const orderPayload: NewPurchaseTbPurchaseOrder = {\n        code: generatedCode,\n        vendorName: input.vendorName.trim(),\n        status: \"draft\",\n        expectedDate: input.expectedDate\n          ? new Date(input.expectedDate)\n          : undefined,\n        warehouseId: input.warehouseId,\n        currency: input.currency ?? \"USD\",\n        notes: input.notes,\n        totalAmount: \"0\",\n        createdBy: input.userId,\n      };\n\n      const [order] = await tx\n        .insert(purchase_tb_purchase_orders)\n        .values(orderPayload)\n        .returning();\n\n      let totalAmount = 0;\n\n      for (const line of input.lines) {\n        const quantity = Number(line.quantity ?? 0);\n\n        if (quantity <= 0) continue;\n\n        const unitPrice = Number(line.unitPrice ?? 0);\n\n        totalAmount += quantity * unitPrice;\n\n        await tx.insert(purchase_tb_purchase_orders_line).values({\n          orderId: order.id,\n          productId: line.productId,\n          description: line.description,\n          quantityOrdered: quantity.toString(),\n          quantityReceived: \"0\",\n          unitPrice: unitPrice.toString(),\n        });\n      }\n\n      await tx\n        .update(purchase_tb_purchase_orders)\n        .set({\n          totalAmount: totalAmount.toString(),\n          updatedAt: now,\n        })\n        .where(eq(purchase_tb_purchase_orders.id, order.id));\n\n      const result = await this.getById(order.id);\n\n      if (!result) {\n        throw new Error(\"Failed to load purchase order after creation\");\n      }\n\n      return result;\n    });\n  };\n\n  confirm = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(purchase_tb_purchase_orders)\n      .set({\n        status: \"confirmed\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(purchase_tb_purchase_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Purchase order not found\");\n    }\n\n    return updated;\n  };\n\n  receive = async (input: ReceivePurchaseOrderInput) => {\n    const stockModel =\n      await RuntimeContext.getModelInstanceBy<StockModel>(\"stock\");\n\n    if (!stockModel) {\n      throw new Error(\"Stock model is not registered\");\n    }\n\n    const orderData = await this.getById(input.orderId);\n\n    if (!orderData) {\n      throw new Error(\"Purchase order not found\");\n    }\n    const { order, lines } = orderData;\n\n    const defaultWarehouseId =\n      input.warehouseId ?? order.warehouseId ?? undefined;\n\n    if (!defaultWarehouseId) {\n      throw new Error(\"Warehouse is required to receive purchase order\");\n    }\n\n    const linesById = new Map<string, PurchaseTbPurchaseOrderLine>();\n\n    for (const line of lines) {\n      linesById.set(line.id, line);\n    }\n\n    const now = new Date();\n\n    await this.db.transaction(async (tx) => {\n      for (const receivedLine of input.lines) {\n        const line = linesById.get(receivedLine.lineId);\n\n        if (!line) {\n          throw new Error(\n            `Purchase order line ${receivedLine.lineId} not found`,\n          );\n        }\n\n        const receiveQty = Number(receivedLine.quantity ?? 0);\n\n        if (receiveQty <= 0) {\n          continue;\n        }\n\n        const alreadyReceived = Number(line.quantityReceived ?? 0);\n        const orderedQty = Number(line.quantityOrdered ?? 0);\n        const nextReceived = alreadyReceived + receiveQty;\n\n        if (nextReceived - orderedQty > 0.0001) {\n          throw new Error(\n            `Cannot receive more than ordered for product ${line.productId}`,\n          );\n        }\n\n        await tx\n          .update(purchase_tb_purchase_orders_line)\n          .set({\n            quantityReceived: nextReceived.toString(),\n            updatedAt: now,\n          })\n          .where(eq(purchase_tb_purchase_orders_line.id, line.id));\n\n        await stockModel.receiveStock({\n          productId: line.productId,\n          warehouseId: defaultWarehouseId,\n          quantity: receiveQty,\n          reference: `PO:${order.code}`,\n          note: input.note,\n          userId: input.userId,\n        });\n      }\n\n      const [sumRow] = await tx\n        .select({\n          unreceivedCount: sql`\n            count(*) FILTER (\n              WHERE ${purchase_tb_purchase_orders_line.quantityOrdered} > ${purchase_tb_purchase_orders_line.quantityReceived}\n            )\n          `,\n        })\n        .from(purchase_tb_purchase_orders_line)\n        .where(eq(purchase_tb_purchase_orders_line.orderId, order.id));\n\n      const status: PurchaseStatus =\n        Number(sumRow?.unreceivedCount ?? 0) === 0 ? \"received\" : \"confirmed\";\n\n      await tx\n        .update(purchase_tb_purchase_orders)\n        .set({\n          status,\n          warehouseId: defaultWarehouseId,\n          updatedAt: now,\n        })\n        .where(eq(purchase_tb_purchase_orders.id, order.id));\n    });\n\n    return this.getById(order.id);\n  };\n\n  cancel = async (orderId: string) => {\n    const [updated] = await this.db\n      .update(purchase_tb_purchase_orders)\n      .set({\n        status: \"cancelled\",\n        updatedAt: sql`now()`,\n      })\n      .where(eq(purchase_tb_purchase_orders.id, orderId))\n      .returning();\n\n    if (!updated) {\n      throw new Error(\"Purchase order not found\");\n    }\n\n    return updated;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/models/Purchase/PurchaseOrderViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":37,"fix":{"range":[259,259],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n\nimport { purchase_tb_purchase_orders } from \"../../schemas\";\n\nclass PurchaseOrderViewListModel extends BaseViewListModel<\n  typeof purchase_tb_purchase_orders,\n  any\n> {\n  constructor() {\n    super({\n      table: purchase_tb_purchase_orders,\n      sortDefault: [\n        {\n          column: \"createdAt\",\n          direction: \"descending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: purchase_tb_purchase_orders.id, sort: true }],\n      [\"code\", { column: purchase_tb_purchase_orders.code, sort: true }],\n      [\n        \"vendorName\",\n        { column: purchase_tb_purchase_orders.vendorName, sort: true },\n      ],\n      [\"status\", { column: purchase_tb_purchase_orders.status, sort: true }],\n      [\n        \"expectedDate\",\n        { column: purchase_tb_purchase_orders.expectedDate, sort: true },\n      ],\n      [\n        \"warehouseId\",\n        { column: purchase_tb_purchase_orders.warehouseId, sort: true },\n      ],\n      [\n        \"totalAmount\",\n        { column: purchase_tb_purchase_orders.totalAmount, sort: true },\n      ],\n      [\n        \"currency\",\n        { column: purchase_tb_purchase_orders.currency, sort: true },\n      ],\n      [\"notes\", { column: purchase_tb_purchase_orders.notes, sort: false }],\n      [\n        \"createdAt\",\n        { column: purchase_tb_purchase_orders.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: purchase_tb_purchase_orders.updatedAt, sort: true },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(purchase_tb_purchase_orders.code, text)],\n      [\n        \"vendorName\",\n        (text: string) => ilike(purchase_tb_purchase_orders.vendorName, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): any => ({\n    id: row.id,\n    code: row.code,\n    vendorName: row.vendorName,\n    status: row.status,\n    warehouseId: row.warehouseId ?? undefined,\n    expectedDate: row.expectedDate?.getTime(),\n    totalAmount: row.totalAmount ?? \"0\",\n    currency: row.currency ?? \"USD\",\n    notes: row.notes ?? undefined,\n    createdAt: row.createdAt?.getTime(),\n    updatedAt: row.updatedAt?.getTime(),\n  });\n\n  getData = async (\n    params: ListParamsRequest,\n  ): Promise<ListParamsResponse<any>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default PurchaseOrderViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/models/Purchase/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/schemas/purchase.order-line.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/schemas/purchase.order.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/purchase/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/report/client/pages/ReportCenterPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":58,"fix":{"range":[72,72],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `echarts-for-react`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":58,"fix":{"range":[15,156],"text":"import { Card } from \"@heroui/card\";\nimport ReactECharts from \"echarts-for-react\";\nimport { IBaseTabs, Tab } from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport { IBaseTabs, Tab } from \"@base/client/components\";\nimport { Card } from \"@heroui/card\";\nimport ReactECharts from \"echarts-for-react\";\n\nconst overviewOption: echarts.EChartsOption = {\n  tooltip: { trigger: \"axis\" },\n  grid: { left: 32, right: 24, top: 32, bottom: 32 },\n  xAxis: {\n    type: \"category\",\n    data: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"],\n    boundaryGap: false,\n  },\n  yAxis: {\n    type: \"value\",\n    splitLine: { lineStyle: { type: \"dashed\" } },\n  },\n  series: [\n    {\n      name: \"Sales\",\n      type: \"line\",\n      smooth: true,\n      showSymbol: false,\n      areaStyle: {\n        opacity: 0.18,\n      },\n      data: [120, 200, 150, 80, 70, 110],\n    },\n  ],\n};\n\nexport default function ReportCenterPage() {\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex items-center justify-between gap-2\">\n        <div>\n          <h1 className=\"text-xl font-semibold text-slate-900\">\n            Report Center\n          </h1>\n          <p className=\"text-sm text-slate-500\">\n            Tổng quan báo cáo chính theo Sales, Purchasing, Inventory, Product.\n          </p>\n        </div>\n      </div>\n\n      <IBaseTabs aria-label=\"Report groups\" color=\"primary\">\n        <Tab key=\"overview\" title=\"Overview\">\n          <Card className=\"p-4\">\n            <div className=\"mb-3 text-sm font-medium text-slate-700\">\n              Sales over time (sample)\n            </div>\n            <ReactECharts\n              lazyUpdate\n              notMerge\n              option={overviewOption}\n              style={{ width: \"100%\", height: 360 }}\n            />\n          </Card>\n        </Tab>\n\n        <Tab key=\"inventory\" title=\"Inventory\">\n          <Card className=\"p-4\">\n            <div className=\"text-sm text-slate-500\">\n              Bạn có thể thêm biểu đồ tồn kho, vòng quay kho, v.v. ở đây.\n            </div>\n          </Card>\n        </Tab>\n      </IBaseTabs>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/StockDashboardPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":53,"fix":{"range":[129,129],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components/LinkAs` import should occur after import of `react`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":53,"fix":{"range":[77,313],"text":"import { Button } from \"@heroui/button\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\nimport LinkAs from \"@base/client/components/LinkAs\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { MovementResult, StockFilters } from \"./types\";\n\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport { Button } from \"@heroui/button\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\n\nimport QuickActionsSection from \"./components/QuickActionsSection\";\nimport StockSummarySection from \"./components/StockSummarySection\";\nimport { useStockMutations } from \"./hooks/useStockMutations\";\n\nexport default function StockDashboardPage(): React.ReactNode {\n  const router = useRouter();\n  const [filters, setFilters] = useState<StockFilters>({});\n  const [appliedFilters, setAppliedFilters] = useState<StockFilters>({});\n  const [movementResult, setMovementResult] = useState<MovementResult | null>(\n    null,\n  );\n\n  const {\n    adjustMutation,\n    receiveMutation,\n    issueMutation,\n    transferMutation,\n    handleMovement,\n  } = useStockMutations();\n\n  const warehousesQuery = useQuery({\n    queryKey: [\"warehouses\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/modules/stock/warehouses\");\n\n      if (!res.ok) {\n        throw new Error(\"Failed to load warehouses.\");\n      }\n      const json = await res.json();\n\n      return json.data ?? [];\n    },\n  });\n\n  const handleFilterChange = useCallback((newFilters: StockFilters) => {\n    setAppliedFilters(newFilters);\n  }, []);\n\n  const handleResetFilters = useCallback(() => {\n    setFilters({});\n    setAppliedFilters({});\n  }, []);\n\n  const handleAdjust = useCallback(\n    async (data: {\n      productId: string;\n      quantity: string;\n      reference?: string;\n      note?: string;\n      primaryWarehouseId: string;\n      secondaryWarehouseId?: string;\n    }): Promise<void> => {\n      setMovementResult(null);\n      const result = await handleMovement(\"adjust\", {\n        productId: data.productId,\n        warehouseId: data.primaryWarehouseId,\n        quantityDelta: Number(data.quantity),\n        reference: data.reference,\n        note: data.note,\n      });\n\n      if (result) {\n        setMovementResult(result);\n      }\n    },\n    [handleMovement],\n  );\n\n  const handleReceive = useCallback(\n    async (data: {\n      productId: string;\n      quantity: string;\n      reference?: string;\n      note?: string;\n      primaryWarehouseId: string;\n      secondaryWarehouseId?: string;\n    }): Promise<void> => {\n      setMovementResult(null);\n      const result = await handleMovement(\"inbound\", {\n        productId: data.productId,\n        warehouseId: data.primaryWarehouseId,\n        quantity: Number(data.quantity),\n        reference: data.reference,\n        note: data.note,\n      });\n\n      if (result) {\n        setMovementResult(result);\n      }\n    },\n    [handleMovement],\n  );\n\n  const handleIssue = useCallback(\n    async (data: {\n      productId: string;\n      quantity: string;\n      reference?: string;\n      note?: string;\n      primaryWarehouseId: string;\n      secondaryWarehouseId?: string;\n    }): Promise<void> => {\n      setMovementResult(null);\n      const result = await handleMovement(\"outbound\", {\n        productId: data.productId,\n        warehouseId: data.primaryWarehouseId,\n        quantity: Number(data.quantity),\n        reference: data.reference,\n        note: data.note,\n      });\n\n      if (result) {\n        setMovementResult(result);\n      }\n    },\n    [handleMovement],\n  );\n\n  const handleTransfer = useCallback(\n    async (data: {\n      productId: string;\n      quantity: string;\n      reference?: string;\n      note?: string;\n      primaryWarehouseId: string;\n      secondaryWarehouseId?: string;\n    }): Promise<void> => {\n      setMovementResult(null);\n      const result = await handleMovement(\"transfer\", {\n        productId: data.productId,\n        sourceWarehouseId: data.primaryWarehouseId,\n        targetWarehouseId: data.secondaryWarehouseId as string,\n        quantity: Number(data.quantity),\n        reference: data.reference,\n        note: data.note,\n      });\n\n      if (result) {\n        setMovementResult(result);\n      }\n    },\n    [handleMovement],\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-end\">\n        <Button\n          as={LinkAs as any}\n          color=\"primary\"\n          href=\"/workspace/modules/stock/warehouses\"\n          size=\"sm\"\n        >\n          Manage warehouses\n        </Button>\n      </div>\n\n      <StockSummarySection\n        appliedFilters={appliedFilters}\n        filters={filters}\n        warehouses={warehousesQuery.data ?? []}\n        warehousesLoading={warehousesQuery.isLoading}\n        onFilterChange={handleFilterChange}\n        onResetFilters={handleResetFilters}\n      />\n\n      <QuickActionsSection\n        adjustMutationPending={adjustMutation.isPending}\n        issueMutationPending={issueMutation.isPending}\n        movementResult={movementResult}\n        receiveMutationPending={receiveMutation.isPending}\n        transferMutationPending={transferMutation.isPending}\n        warehouses={warehousesQuery.data ?? []}\n        onAdjust={handleAdjust}\n        onIssue={handleIssue}\n        onReceive={handleReceive}\n        onTransfer={handleTransfer}\n      />\n\n      <div className=\"flex items-center justify-end\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/purchase\")}\n        >\n          Go to Purchase Orders\n        </Button>\n        <Button\n          className=\"ml-2\"\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/b2b-sales/orders\")}\n        >\n          Go to Sales Orders\n        </Button>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/components/MovementCard.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[230,230],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `react`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":34,"fix":{"range":[133,363],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { useMemo, useState } from \"react\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type { WarehouseDto } from \"../../../services/StockService\";\nimport type { MovementPayload } from \"../types\";\n\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody } from \"@heroui/react\";\nimport { useMemo, useState } from \"react\";\n\ninterface MovementCardProps {\n  title: string;\n  description: string;\n  actionLabel: string;\n  warehouses: WarehouseDto[];\n  requireSecondaryWarehouse?: boolean;\n  submitting?: boolean;\n  onSubmit: (payload: MovementPayload) => Promise<void>;\n}\n\nexport default function MovementCard({\n  title,\n  description,\n  actionLabel,\n  warehouses,\n  requireSecondaryWarehouse,\n  submitting = false,\n  onSubmit,\n}: MovementCardProps) {\n  const [formValues, setFormValues] = useState<MovementPayload>({\n    productId: \"\",\n    quantity: \"\",\n    primaryWarehouseId: \"\",\n    secondaryWarehouseId: \"\",\n    reference: \"\",\n    note: \"\",\n  });\n\n  const warehouseItems = useMemo<SelectItemOption[]>(\n    () =>\n      warehouses.map((warehouse) => ({\n        value: warehouse.id,\n        label: `${warehouse.code} — ${warehouse.name}`,\n      })),\n    [warehouses],\n  );\n\n  const handleChange = (field: keyof MovementPayload, value: string) => {\n    setFormValues((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleSubmit = async () => {\n    if (\n      !formValues.productId ||\n      !formValues.quantity ||\n      !formValues.primaryWarehouseId ||\n      (requireSecondaryWarehouse && !formValues.secondaryWarehouseId)\n    ) {\n      return;\n    }\n\n    try {\n      await onSubmit(formValues);\n      setFormValues({\n        productId: \"\",\n        quantity: \"\",\n        primaryWarehouseId: \"\",\n        secondaryWarehouseId: \"\",\n        reference: \"\",\n        note: \"\",\n      });\n    } finally {\n      // handled by parent\n    }\n  };\n\n  return (\n    <Card className=\"border border-content3/40\">\n      <CardBody className=\"space-y-3\">\n        <div>\n          <h3 className=\"text-base font-semibold\">{title}</h3>\n          <p className=\"text-sm text-default-500\">{description}</p>\n        </div>\n        <IBaseInput\n          label=\"Product ID\"\n          placeholder=\"Product identifier\"\n          value={formValues.productId}\n          onValueChange={(value) => handleChange(\"productId\", value)}\n        />\n        <IBaseInput\n          label=\"Quantity\"\n          type=\"number\"\n          value={formValues.quantity}\n          onValueChange={(value) => handleChange(\"quantity\", value)}\n        />\n        <IBaseSingleSelect\n          items={warehouseItems}\n          label=\"Warehouse\"\n          selectedKey={formValues.primaryWarehouseId}\n          onSelectionChange={(key) => {\n            handleChange(\"primaryWarehouseId\", key || \"\");\n          }}\n        />\n        {requireSecondaryWarehouse ? (\n          <IBaseSingleSelect\n            items={warehouseItems}\n            label=\"Target Warehouse\"\n            selectedKey={formValues.secondaryWarehouseId}\n            onSelectionChange={(key) => {\n              handleChange(\"secondaryWarehouseId\", key || \"\");\n            }}\n          />\n        ) : null}\n        <IBaseInput\n          label=\"Reference\"\n          placeholder=\"Optional reference\"\n          value={formValues.reference}\n          onValueChange={(value) => handleChange(\"reference\", value)}\n        />\n        <IBaseInput\n          label=\"Note\"\n          placeholder=\"Optional note\"\n          value={formValues.note}\n          onValueChange={(value) => handleChange(\"note\", value)}\n        />\n        <Button\n          color=\"primary\"\n          isLoading={submitting}\n          size=\"sm\"\n          onPress={handleSubmit}\n        >\n          {actionLabel}\n        </Button>\n      </CardBody>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/components/QuickActionsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/components/StockSummarySection.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":75,"fix":{"range":[462,462],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/button` import should occur before import of `@base/client/components`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":41,"fix":{"range":[217,504],"text":"import { Button } from \"@heroui/button\";\nimport {\n  IBaseDigitViewer,\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":57,"fix":{"range":[217,561],"text":"import { Card, CardBody, Divider } from \"@heroui/react\";\nimport {\n  IBaseDigitViewer,\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Button } from \"@heroui/button\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":33,"fix":{"range":[217,594],"text":"import { useMemo } from \"react\";\nimport {\n  IBaseDigitViewer,\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'appliedFilters' is defined but never used. Allowed unused args must match /^_.*?$/u.","line":33,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport type { DataTableColumn } from \"@base/client/components\";\nimport type {\n  StockSummaryItem,\n  WarehouseDto,\n} from \"../../../services/StockService\";\nimport type { StockFilters } from \"../types\";\n\nimport {\n  IBaseDigitViewer,\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Divider } from \"@heroui/react\";\nimport { useMemo } from \"react\";\n\ninterface StockSummarySectionProps {\n  filters: StockFilters;\n  appliedFilters: StockFilters;\n  onFilterChange: (filters: StockFilters) => void;\n  onResetFilters: () => void;\n  warehouses: WarehouseDto[];\n  warehousesLoading: boolean;\n}\n\nexport default function StockSummarySection({\n  filters,\n  appliedFilters,\n  onFilterChange,\n  onResetFilters,\n  warehouses,\n  warehousesLoading,\n}: StockSummarySectionProps) {\n  const warehouseItems = useMemo<SelectItemOption[]>(\n    () =>\n      warehouses.map((warehouse) => ({\n        value: warehouse.id,\n        label: `${warehouse.code} — ${warehouse.name}`,\n      })),\n    [warehouses],\n  );\n\n  const columns = useMemo<DataTableColumn<StockSummaryItem>[]>(() => {\n    return [\n      {\n        key: \"productCode\",\n        label: \"Product Code\",\n        render: (_, row) => (\n          <LinkAs href={`/workspace/modules/product/view/${row.productId}`}>\n            {row.productCode}\n          </LinkAs>\n        ),\n      },\n      {\n        key: \"productName\",\n        label: \"Product Name\",\n        render: (_, row) => (\n          <LinkAs href={`/workspace/modules/product/view/${row.productId}`}>\n            {row.productName}\n          </LinkAs>\n        ),\n      },\n      {\n        key: \"warehouse\",\n        label: \"Warehouse\",\n        render: (_, row) => (\n          <LinkAs\n            href={`/workspace/modules/stock/warehouses/edit/${row.warehouseId}`}\n          >\n            {`${row.warehouseCode} - ${row.warehouseName}`}\n          </LinkAs>\n        ),\n      },\n      {\n        key: \"quantity\",\n        label: \"On Hand\",\n        render: (_, row) => {\n          let colorClass = \"\";\n\n          if (row.quantity <= 0) {\n            colorClass = \"text-danger\";\n          } else if (\n            row.minStock !== null &&\n            row.quantity <= Number(row.minStock)\n          ) {\n            colorClass = \"text-warning-600\";\n          }\n\n          return (\n            <IBaseDigitViewer className={colorClass} value={row.quantity} />\n          );\n        },\n      },\n      {\n        key: \"reservedQuantity\",\n        label: \"Reserved\",\n        render: (_, row) => <IBaseDigitViewer value={row.reservedQuantity} />,\n      },\n    ];\n  }, []);\n\n  return (\n    <Card>\n      <CardBody className=\"space-y-4\">\n        <div className=\"flex flex-col gap-3 md:flex-row md:items-end\">\n          <IBaseInput\n            label=\"Product ID\"\n            placeholder=\"Optional product ID filter\"\n            value={filters.productId ?? \"\"}\n            onValueChange={(value) =>\n              onFilterChange({\n                ...filters,\n                productId: value || undefined,\n              })\n            }\n          />\n          <IBaseSingleSelect\n            className=\"max-w-xs\"\n            isDisabled={warehousesLoading || warehouseItems.length === 0}\n            items={warehouseItems}\n            label=\"Warehouse\"\n            selectedKey={filters.warehouseId}\n            onSelectionChange={(key) => {\n              onFilterChange({\n                ...filters,\n                warehouseId: key || undefined,\n              });\n            }}\n          />\n          <div className=\"flex items-center gap-2\">\n            <Button\n              color=\"primary\"\n              size=\"sm\"\n              onPress={() => onFilterChange(filters)}\n            >\n              Apply\n            </Button>\n            <Button size=\"sm\" variant=\"light\" onPress={onResetFilters}>\n              Reset\n            </Button>\n          </div>\n        </div>\n\n        <Divider />\n\n        <ViewListDataTable<StockSummaryItem & { id: string }>\n          columnVisibility={{ hidden: true }}\n          columns={columns}\n          favorite={{ hidden: true }}\n          filter={{ hidden: true }}\n          groupBy={{ hidden: true }}\n          isDummyData={false}\n          model=\"stock-summary\"\n          rowKey=\"id\"\n          search={{ hidden: true }}\n        />\n      </CardBody>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/hooks/useStockMutations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Dashboard/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Warehouse/WarehouseCreatePage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":70,"fix":{"range":[173,173],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `react`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":70,"fix":{"range":[104,297],"text":"import { Button } from \"@heroui/button\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback } from \"react\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type {\n  WarehouseDto,\n  WarehousePayload,\n} from \"../../services/StockService\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback } from \"react\";\n\nimport StockService from \"../../services/StockService\";\n\nimport WarehouseForm from \"./components/WarehouseForm\";\n\nexport default function WarehouseCreatePage(): React.ReactNode {\n  const router = useRouter();\n\n  const { handleSubmit, error } = useCreateUpdate<\n    WarehousePayload,\n    WarehouseDto\n  >({\n    mutationFn: async (payload) => {\n      const response = await StockService.createWarehouse(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Failed to create warehouse.\");\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"warehouses\"]],\n    onSuccess: () => {\n      router.push(\"/workspace/modules/stock/warehouses\");\n    },\n  });\n\n  const handleFormSubmit = useCallback(\n    async (payload: WarehousePayload) => {\n      await handleSubmit(payload);\n    },\n    [handleSubmit],\n  );\n\n  return (\n    <div className=\"w-full space-y-6\">\n      <WarehouseForm\n        secondaryAction={\n          <Button\n            size=\"sm\"\n            variant=\"light\"\n            onPress={() => router.push(\"/workspace/modules/stock/warehouses\")}\n          >\n            Cancel\n          </Button>\n        }\n        submitError={error}\n        submitLabel=\"Create warehouse\"\n        onSubmit={handleFormSubmit}\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Warehouse/WarehouseEditPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":70,"fix":{"range":[173,173],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/hooks/useCreateUpdate` import should occur after import of `react`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":70,"fix":{"range":[104,424],"text":"import { Button } from \"@heroui/button\";\nimport { Card, CardBody, Spinner } from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\"use client\";\n\nimport type {\n  WarehouseDto,\n  WarehousePayload,\n} from \"../../services/StockService\";\n\nimport { useCreateUpdate } from \"@base/client/hooks/useCreateUpdate\";\nimport { Button } from \"@heroui/button\";\nimport { Card, CardBody, Spinner } from \"@heroui/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport { useCallback, useMemo } from \"react\";\n\nimport StockService from \"../../services/StockService\";\n\nimport WarehouseForm from \"./components/WarehouseForm\";\n\nexport default function WarehouseEditPage(): React.ReactNode {\n  const router = useRouter();\n  const params = useParams<{ id: string }>();\n\n  const warehouseId = useMemo(() => {\n    const value = params?.id;\n\n    if (!value) return undefined;\n\n    return Array.isArray(value) ? value[0] : value;\n  }, [params]);\n\n  const warehouseQuery = useQuery({\n    queryKey: [\"warehouses\", warehouseId],\n    enabled: Boolean(warehouseId),\n    queryFn: async () => {\n      if (!warehouseId) {\n        throw new Error(\"Warehouse identifier is missing.\");\n      }\n\n      const response = await StockService.getWarehouseById(warehouseId);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Unable to load warehouse.\");\n      }\n\n      return response.data;\n    },\n  });\n\n  const { handleSubmit, error } = useCreateUpdate<\n    WarehousePayload & { id: string },\n    WarehouseDto\n  >({\n    mutationFn: async (payload) => {\n      const response = await StockService.updateWarehouse(payload);\n\n      if (!response.data) {\n        throw new Error(response.message ?? \"Failed to update warehouse.\");\n      }\n\n      return response.data;\n    },\n    invalidateQueries: [[\"warehouses\"], [\"warehouses\", warehouseId]],\n    onSuccess: () => {\n      router.push(\"/workspace/modules/stock/warehouses\");\n    },\n  });\n\n  const handleFormSubmit = useCallback(\n    async (payload: WarehousePayload) => {\n      if (!warehouseId) {\n        return;\n      }\n\n      await handleSubmit({ ...payload, id: warehouseId });\n    },\n    [handleSubmit, warehouseId],\n  );\n\n  return (\n    <div className=\"w-full space-y-6\">\n      <div className=\"flex justify-end\">\n        <Button\n          size=\"sm\"\n          variant=\"light\"\n          onPress={() => router.push(\"/workspace/modules/stock/warehouses\")}\n        >\n          Back to list\n        </Button>\n      </div>\n\n      {warehouseQuery.isLoading ? (\n        <Card>\n          <CardBody className=\"flex items-center justify-center py-10\">\n            <Spinner label=\"Loading warehouse...\" />\n          </CardBody>\n        </Card>\n      ) : warehouseQuery.isError ? (\n        <Card>\n          <CardBody className=\"space-y-3\">\n            <p className=\"text-default-500\">\n              {warehouseQuery.error instanceof Error\n                ? warehouseQuery.error.message\n                : \"Failed to load warehouse.\"}\n            </p>\n            <Button\n              size=\"sm\"\n              onPress={() => router.push(\"/workspace/modules/stock/warehouses\")}\n            >\n              Back to list\n            </Button>\n          </CardBody>\n        </Card>\n      ) : warehouseQuery.data ? (\n        <WarehouseForm\n          initialData={warehouseQuery.data}\n          secondaryAction={\n            <Button\n              size=\"sm\"\n              variant=\"light\"\n              onPress={() => router.push(\"/workspace/modules/stock/warehouses\")}\n            >\n              Cancel\n            </Button>\n          }\n          submitError={error}\n          submitLabel=\"Save changes\"\n          onSubmit={handleFormSubmit}\n        />\n      ) : null}\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Warehouse/WarehouseListPage.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":75,"fix":{"range":[307,307],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@heroui/react` import should occur before import of `@base/client/components`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":38,"fix":{"range":[81,346],"text":"import { Chip } from \"@heroui/react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\n"}},{"ruleId":"import/order","severity":1,"message":"`next-intl` import should occur before import of `@base/client/components`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":45,"fix":{"range":[81,391],"text":"import { useTranslations } from \"next-intl\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\n"}},{"ruleId":"import/order","severity":1,"message":"`react` import should occur before import of `@base/client/components`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":33,"fix":{"range":[81,424],"text":"import { useMemo } from \"react\";\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\"use client\";\n\nimport type { WarehouseDto } from \"../../services/StockService\";\n\nimport {\n  DATA_TABLE_COLUMN_KEY_ACTION,\n  type DataTableColumn,\n} from \"@base/client/components\";\nimport LinkAs from \"@base/client/components/LinkAs\";\nimport ViewListDataTable from \"@base/client/components/ViewListDataTable\";\nimport { Chip } from \"@heroui/react\";\nimport { useTranslations } from \"next-intl\";\nimport { useMemo } from \"react\";\n\nconst statusColorMap: Record<string, \"success\" | \"warning\" | \"danger\"> = {\n  ACTIVE: \"success\",\n  MAINTENANCE: \"warning\",\n  SUSPENDED: \"danger\",\n  CLOSED: \"danger\",\n};\n\nconst formatLocation = (warehouse: WarehouseDto) => {\n  if (!warehouse.address || warehouse.address.length === 0) {\n    return \"—\";\n  }\n  const address = warehouse.address[0];\n  const getLocalizedName = (name: any): string => {\n    if (!name) return \"\";\n    if (typeof name === \"string\") return name;\n\n    return name.vi || name.en || \"\";\n  };\n  const parts = [\n    address.administrativeUnits?.find((u) => u.level === 2)\n      ? getLocalizedName(\n          address.administrativeUnits.find((u) => u.level === 2)?.name,\n        )\n      : undefined,\n    address.country ? getLocalizedName(address.country.name) : undefined,\n  ].filter(\n    (value): value is string =>\n      Boolean(value) && typeof value === \"string\" && value.trim().length > 0,\n  );\n\n  return parts.length ? parts.join(\", \") : \"—\";\n};\n\nconst formatStockRange = (warehouse: WarehouseDto) => {\n  if (warehouse.maxStock === null || warehouse.maxStock === undefined) {\n    return `≥ ${warehouse.minStock}`;\n  }\n\n  return `${warehouse.minStock} - ${warehouse.maxStock}`;\n};\n\nexport default function WarehouseListPage(): React.ReactNode {\n  const t = useTranslations(\"stock.warehouse.list\");\n  const tDataTable = useTranslations(\"dataTable\");\n\n  const columns = useMemo<DataTableColumn<WarehouseDto>[]>(\n    () => [\n      {\n        key: \"code\",\n        label: t(\"columns.code\"),\n        render: (_, row) => (\n          <LinkAs href={`/workspace/modules/stock/warehouses/edit/${row.id}`}>\n            {row.code}\n          </LinkAs>\n        ),\n      },\n      {\n        key: \"name\",\n        label: t(\"columns.name\"),\n      },\n      {\n        key: \"typeCode\",\n        label: t(\"columns.type\"),\n      },\n      {\n        key: \"address\",\n        label: t(\"columns.location\"),\n        render: (_, row) => formatLocation(row),\n      },\n      {\n        key: \"stockRange\",\n        label: t(\"columns.stockRange\"),\n        render: (_, row) => formatStockRange(row),\n      },\n      {\n        key: \"status\",\n        label: t(\"columns.status\"),\n        render: (_, row) => (\n          <Chip\n            color={statusColorMap[row.status] ?? \"warning\"}\n            size=\"sm\"\n            variant=\"flat\"\n          >\n            {t(`status.${row.status}`)}\n          </Chip>\n        ),\n      },\n      {\n        key: DATA_TABLE_COLUMN_KEY_ACTION,\n        label: tDataTable(\"columns.action\"),\n        align: \"end\",\n        render: (_, row) => (\n          <LinkAs href={`/workspace/modules/stock/warehouses/edit/${row.id}`}>\n            {t(\"actions.edit\")}\n          </LinkAs>\n        ),\n      },\n    ],\n    [t, tDataTable],\n  );\n\n  return (\n    <div className=\"space-y-4\">\n      <ViewListDataTable<WarehouseDto>\n        actionsRight={[\n          {\n            key: \"new\",\n            title: t(\"actions.new\"),\n            type: \"link\",\n            color: \"primary\",\n            props: {\n              href: \"/workspace/modules/stock/warehouses/create\",\n            },\n          },\n        ]}\n        columns={columns}\n        isDummyData={false}\n        model=\"stock-warehouse\"\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/pages/Warehouse/components/WarehouseForm.tsx","messages":[{"ruleId":"import/order","severity":1,"message":"`@base/client/components` import should occur after import of `valibot`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":34,"fix":{"range":[0,546],"text":"import AddressPicker from \"@base/client/components/AddressPicker/AddressPicker\";\nimport { Button } from \"@heroui/button\";\nimport { Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { type Key, type ReactNode, useMemo } from \"react\";\nimport { Controller, useForm } from \"react-hook-form\";\nimport {\n  any,\n  minLength,\n  object,\n  optional,\n  picklist,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":81,"fix":{"range":[178,178],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@base/client/components/AddressPicker/AddressPicker` import should occur after import of `valibot`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":81,"fix":{"range":[98,546],"text":"import { Button } from \"@heroui/button\";\nimport { Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { type Key, type ReactNode, useMemo } from \"react\";\nimport { Controller, useForm } from \"react-hook-form\";\nimport {\n  any,\n  minLength,\n  object,\n  optional,\n  picklist,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport AddressPicker from \"@base/client/components/AddressPicker/AddressPicker\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":18,"fix":{"range":[545,545],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getSingleSelectionValue' is assigned a value but never used. Allowed unused vars must match /^_.*?$/u.","line":109,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import {\n  IBaseInput,\n  IBaseSingleSelect,\n  SelectItemOption,\n} from \"@base/client/components\";\nimport AddressPicker from \"@base/client/components/AddressPicker/AddressPicker\";\nimport { Button } from \"@heroui/button\";\nimport { Textarea } from \"@heroui/react\";\nimport { valibotResolver } from \"@hookform/resolvers/valibot\";\nimport { type Key, type ReactNode, useMemo } from \"react\";\nimport { Controller, useForm } from \"react-hook-form\";\nimport {\n  any,\n  minLength,\n  object,\n  optional,\n  picklist,\n  pipe,\n  string,\n  trim,\n} from \"valibot\";\nimport { useLocalizedText } from \"@base/client/hooks/useLocalizedText\";\nimport { Address } from \"@base/client/interface/Address\";\n\nimport {\n  warehouseStatuses,\n  warehouseValuationMethods,\n} from \"../../../../common/constants\";\nimport { WarehouseDto, WarehousePayload } from \"../../../services/StockService\";\n\nconst warehouseFormSchema = object({\n  code: pipe(string(), trim(), minLength(1, \"Code is required\")),\n  name: pipe(string(), trim(), minLength(1, \"Name is required\")),\n  typeCode: pipe(string(), trim(), minLength(1, \"Type code is required\")),\n  status: pipe(\n    string(),\n    trim(),\n    picklist(warehouseStatuses, \"Invalid warehouse status\"),\n  ),\n  companyId: optional(pipe(string(), trim())),\n  managerId: optional(pipe(string(), trim())),\n  contactId: optional(pipe(string(), trim())),\n  address1: any(), // Address object, validated manually\n  address2: optional(any()), // Address object, optional\n  valuationMethod: pipe(\n    string(),\n    trim(),\n    picklist(warehouseValuationMethods, \"Invalid valuation method\"),\n  ),\n  minStock: optional(pipe(string(), trim())),\n  maxStock: optional(pipe(string(), trim())),\n  accountInventory: optional(pipe(string(), trim())),\n  accountAdjustment: optional(pipe(string(), trim())),\n  notes: optional(pipe(string(), trim())),\n});\n\ntype WarehouseFormValues = {\n  code: string;\n  name: string;\n  typeCode: string;\n  status: string;\n  companyId?: string;\n  managerId?: string;\n  contactId?: string;\n  address1: Address;\n  address2?: Address;\n  valuationMethod: string;\n  minStock?: string;\n  maxStock?: string;\n  accountInventory?: string;\n  accountAdjustment?: string;\n  notes?: string;\n};\n\nconst statusOptions: SelectItemOption[] = warehouseStatuses.map((status) => ({\n  value: status,\n  label: status.charAt(0) + status.slice(1).toLowerCase(),\n}));\n\nconst valuationOptions: SelectItemOption[] = warehouseValuationMethods.map(\n  (method) => ({\n    value: method,\n    label: method,\n  }),\n);\n\nconst toNullableString = (value?: string) => {\n  if (!value) return undefined;\n  const trimmed = value.trim();\n\n  return trimmed.length > 0 ? trimmed : undefined;\n};\n\nconst toNullableNumber = (value?: string) => {\n  if (!value || value.trim().length === 0) {\n    return null;\n  }\n  const numeric = Number(value);\n\n  if (!Number.isFinite(numeric)) {\n    throw new Error(\"Invalid number\");\n  }\n\n  return numeric;\n};\n\ntype SingleSelection = \"all\" | Set<Key>;\n\nconst getSingleSelectionValue = (selection: SingleSelection) => {\n  if (selection === \"all\") {\n    return undefined;\n  }\n  const [first] = Array.from(selection);\n\n  return typeof first === \"string\" ? first : undefined;\n};\n\ninterface WarehouseFormProps {\n  initialData?: WarehouseDto;\n  onSubmit: (payload: WarehousePayload) => Promise<void>;\n  submitLabel: string;\n  secondaryAction?: ReactNode;\n  submitError?: string | null;\n}\n\nexport default function WarehouseForm({\n  initialData,\n  onSubmit,\n  submitLabel,\n  secondaryAction,\n  submitError,\n}: WarehouseFormProps) {\n  const getLocalizedName = useLocalizedText();\n  const defaultValues: WarehouseFormValues = useMemo(\n    () => ({\n      code: initialData?.code ?? \"\",\n      name: initialData?.name ?? \"\",\n      typeCode: initialData?.typeCode ?? \"\",\n      status: initialData?.status ?? \"ACTIVE\",\n      companyId: initialData?.companyId ?? \"\",\n      managerId: initialData?.managerId ?? \"\",\n      contactId: initialData?.contactId ?? \"\",\n      address1: initialData?.address?.[0] ?? {\n        street: \"\",\n        postalCode: \"\",\n        country: {\n          id: \"VN\",\n          name: { vi: \"Việt Nam\", en: \"Vietnam\" },\n          code: \"VN\",\n        },\n        administrativeUnits: [],\n        formattedAddress: \"\",\n      },\n      address2: initialData?.address?.[1],\n      valuationMethod: initialData?.valuationMethod ?? \"FIFO\",\n      minStock:\n        initialData?.minStock !== undefined\n          ? String(initialData.minStock ?? 0)\n          : \"0\",\n      maxStock:\n        initialData?.maxStock !== undefined && initialData?.maxStock !== null\n          ? String(initialData.maxStock)\n          : undefined,\n      accountInventory: initialData?.accountInventory ?? \"\",\n      accountAdjustment: initialData?.accountAdjustment ?? \"\",\n      notes: initialData?.notes ?? \"\",\n    }),\n    [initialData],\n  );\n\n  const {\n    control,\n    handleSubmit,\n    formState: { isSubmitting, errors },\n    setError,\n  } = useForm<WarehouseFormValues>({\n    resolver: valibotResolver(warehouseFormSchema),\n    defaultValues,\n  });\n\n  const handleFormSubmit = async (values: WarehouseFormValues) => {\n    // Validate address1\n    if (!values.address1 || !values.address1.formattedAddress) {\n      setError(\"address1\", {\n        type: \"manual\",\n        message: \"Address 1 is required\",\n      });\n\n      return;\n    }\n\n    let minStock = 0;\n\n    if (values.minStock !== undefined) {\n      try {\n        minStock = toNullableNumber(values.minStock) ?? 0;\n      } catch (error) {\n        setError(\"minStock\", {\n          type: \"manual\",\n          message: error instanceof Error ? error.message : \"Invalid value\",\n        });\n\n        return;\n      }\n    }\n\n    let maxStock: number | null = null;\n\n    if (values.maxStock !== undefined) {\n      try {\n        maxStock = toNullableNumber(values.maxStock);\n      } catch (error) {\n        setError(\"maxStock\", {\n          type: \"manual\",\n          message: error instanceof Error ? error.message : \"Invalid value\",\n        });\n\n        return;\n      }\n    }\n\n    if (maxStock !== null && maxStock < minStock) {\n      setError(\"maxStock\", {\n        type: \"manual\",\n        message: \"Max stock must be greater than or equal to min stock\",\n      });\n\n      return;\n    }\n\n    const payload: WarehousePayload = {\n      code: values.code.trim().toUpperCase(),\n      name: values.name.trim(),\n      typeCode: values.typeCode.trim(),\n      status: values.status.trim().toUpperCase(),\n      companyId: toNullableString(values.companyId) ?? null,\n      managerId: toNullableString(values.managerId) ?? null,\n      contactId: toNullableString(values.contactId) ?? null,\n      address: [values.address1, values.address2].filter(\n        (x) => x !== undefined,\n      ) as Address[],\n      valuationMethod: values.valuationMethod.trim().toUpperCase(),\n      minStock,\n      maxStock,\n      accountInventory: toNullableString(values.accountInventory) ?? null,\n      accountAdjustment: toNullableString(values.accountAdjustment) ?? null,\n      notes: toNullableString(values.notes) ?? null,\n    };\n\n    await onSubmit(payload);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <form\n        noValidate\n        className=\"space-y-6\"\n        onSubmit={handleSubmit(handleFormSubmit)}\n      >\n        {submitError ? (\n          <div className=\"rounded-large border border-danger-200 bg-danger-50 px-3 py-2 text-sm text-danger-600\">\n            {submitError}\n          </div>\n        ) : null}\n\n        <div className=\"grid grid-cols-1 gap-4 md:grid-cols-2\">\n          <Controller\n            control={control}\n            name=\"code\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Code\"\n                placeholder=\"Unique warehouse code\"\n                value={field.value}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"name\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Name\"\n                placeholder=\"Warehouse name\"\n                value={field.value}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"typeCode\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Type\"\n                placeholder=\"e.g. RAW_MATERIAL, FINISHED_GOODS\"\n                value={field.value}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"status\"\n            render={({ field, fieldState }) => (\n              <IBaseSingleSelect\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                items={statusOptions}\n                label=\"Status\"\n                selectedKey={field.value}\n                onSelectionChange={(key) => {\n                  field.onChange(key);\n                }}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"valuationMethod\"\n            render={({ field, fieldState }) => (\n              <IBaseSingleSelect\n                isRequired\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                items={valuationOptions}\n                label=\"Valuation method\"\n                selectedKey={field.value}\n                onSelectionChange={(key) => {\n                  field.onChange(key);\n                }}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"companyId\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Company ID\"\n                placeholder=\"Optional company relationship\"\n                value={field.value ?? \"\"}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"managerId\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Manager (user ID)\"\n                placeholder=\"Optional manager user ID\"\n                value={field.value ?? \"\"}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n          <Controller\n            control={control}\n            name=\"contactId\"\n            render={({ field, fieldState }) => (\n              <IBaseInput\n                {...field}\n                errorMessage={fieldState.error?.message}\n                isInvalid={fieldState.invalid}\n                label=\"Contact (user ID)\"\n                placeholder=\"Optional contact user ID\"\n                value={field.value ?? \"\"}\n                onValueChange={field.onChange}\n              />\n            )}\n          />\n        </div>\n\n        <div>\n          <h2 className=\"text-lg font-semibold mb-4\">Address</h2>\n          <div className=\"space-y-4\">\n            <Controller\n              control={control}\n              name=\"address1\"\n              render={({ field, fieldState }) => (\n                <div className=\"flex gap-2 justify-between items-end\">\n                  <div className=\"flex-1\">\n                    <IBaseInput\n                      isDisabled\n                      isRequired\n                      errorMessage={fieldState.error?.message}\n                      isInvalid={fieldState.invalid}\n                      label=\"Main\"\n                      placeholder=\"Please select address\"\n                      value={getLocalizedName(field.value.formattedAddress)}\n                    />\n                  </div>\n                  <AddressPicker\n                    value={field.value}\n                    onChange={(addressString) => {\n                      // AddressPicker returns string, but we need to update the Address object\n                      // For now, we'll update the formattedAddress in the existing Address object\n                      if (field.value) {\n                        field.onChange({\n                          ...field.value,\n                          formattedAddress: addressString,\n                        });\n                      }\n                    }}\n                  />\n                </div>\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"address2\"\n              render={({ field, fieldState }) => (\n                <div className=\"flex gap-2 justify-between items-end\">\n                  <div className=\"flex-1\">\n                    <IBaseInput\n                      isDisabled\n                      errorMessage={fieldState.error?.message}\n                      isInvalid={fieldState.invalid}\n                      label=\"Secondary\"\n                      placeholder=\"Please select address\"\n                      value={getLocalizedName(\n                        field.value?.formattedAddress ?? \"\",\n                      )}\n                    />\n                  </div>\n                  <AddressPicker\n                    value={field.value}\n                    onChange={(addressString) => {\n                      // AddressPicker returns string, but we need to update the Address object\n                      // For now, we'll update the formattedAddress in the existing Address object\n                      if (field.value) {\n                        field.onChange({\n                          ...field.value,\n                          formattedAddress: addressString,\n                        });\n                      }\n                    }}\n                  />\n                </div>\n              )}\n            />\n          </div>\n        </div>\n\n        <div>\n          <h2 className=\"text-lg font-semibold\">Inventory Controls</h2>\n          <div className=\"mt-3 grid grid-cols-1 gap-4 md:grid-cols-2\">\n            <Controller\n              control={control}\n              name=\"minStock\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  isRequired\n                  errorMessage={\n                    fieldState.error?.message ?? errors.minStock?.message\n                  }\n                  isInvalid={fieldState.invalid}\n                  label=\"Minimum stock\"\n                  type=\"number\"\n                  value={field.value ?? \"\"}\n                  onValueChange={(value) =>\n                    field.onChange(value === \"\" ? undefined : value)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"maxStock\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label=\"Maximum stock\"\n                  type=\"number\"\n                  value={field.value ?? \"\"}\n                  onValueChange={(value) =>\n                    field.onChange(value === \"\" ? undefined : value)\n                  }\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"accountInventory\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label=\"Inventory account\"\n                  placeholder=\"Optional account code\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n            <Controller\n              control={control}\n              name=\"accountAdjustment\"\n              render={({ field, fieldState }) => (\n                <IBaseInput\n                  {...field}\n                  errorMessage={fieldState.error?.message}\n                  isInvalid={fieldState.invalid}\n                  label=\"Adjustment account\"\n                  placeholder=\"Optional adjustment account\"\n                  value={field.value ?? \"\"}\n                  onValueChange={field.onChange}\n                />\n              )}\n            />\n          </div>\n        </div>\n\n        <Controller\n          control={control}\n          name=\"notes\"\n          render={({ field, fieldState }) => (\n            <Textarea\n              {...field}\n              errorMessage={fieldState.error?.message}\n              isInvalid={fieldState.invalid}\n              label=\"Notes\"\n              placeholder=\"Internal notes (optional)\"\n              value={field.value ?? \"\"}\n              onValueChange={field.onChange}\n            />\n          )}\n        />\n\n        <div className=\"flex flex-col-reverse gap-3 md:flex-row md:items-center md:justify-between\">\n          {secondaryAction && <div>{secondaryAction}</div>}\n          <div className=\"flex gap-3\">\n            <Button\n              color=\"primary\"\n              disabled={isSubmitting}\n              isLoading={isSubmitting}\n              type=\"submit\"\n            >\n              {submitLabel}\n            </Button>\n          </div>\n        </div>\n      </form>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/client/services/StockService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/common/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Stock/StockModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":44,"fix":{"range":[100,100],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { StockTbStockLevel } from \"../../schemas\";\n\nimport { and, eq, sql } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n\nimport { stock_tb_stock_levels, stock_tb_stock_moves } from \"../../schemas\";\n\ntype StockMovementKind = \"inbound\" | \"outbound\" | \"adjustment\" | \"transfer\";\n\ninterface MovementBaseInput {\n  productId: string;\n  reference?: string;\n  note?: string;\n  userId?: string;\n}\n\ninterface AdjustStockInput extends MovementBaseInput {\n  warehouseId: string;\n  quantityDelta: number;\n}\n\ninterface InboundStockInput extends MovementBaseInput {\n  warehouseId: string;\n  quantity: number;\n}\n\ninterface OutboundStockInput extends MovementBaseInput {\n  warehouseId: string;\n  quantity: number;\n}\n\ninterface TransferStockInput extends MovementBaseInput {\n  sourceWarehouseId: string;\n  targetWarehouseId: string;\n  quantity: number;\n}\n\nexport default class StockModel extends BaseModel<typeof stock_tb_stock_moves> {\n  constructor() {\n    super(stock_tb_stock_moves);\n  }\n\n  adjustStock = async (input: AdjustStockInput) => {\n    if (!input.quantityDelta) {\n      return this.getStockLevel(input.productId, input.warehouseId);\n    }\n\n    return this.applyDelta({\n      ...input,\n      type: \"adjustment\",\n    });\n  };\n\n  receiveStock = async (input: InboundStockInput) => {\n    if (input.quantity <= 0) {\n      throw new Error(\"Inbound quantity must be positive\");\n    }\n\n    return this.applyDelta({\n      ...input,\n      warehouseId: input.warehouseId,\n      quantityDelta: input.quantity,\n      type: \"inbound\",\n    });\n  };\n\n  issueStock = async (input: OutboundStockInput) => {\n    if (input.quantity <= 0) {\n      throw new Error(\"Outbound quantity must be positive\");\n    }\n\n    return this.applyDelta({\n      ...input,\n      warehouseId: input.warehouseId,\n      quantityDelta: -Math.abs(input.quantity),\n      type: \"outbound\",\n    });\n  };\n\n  transferStock = async (input: TransferStockInput) => {\n    if (input.sourceWarehouseId === input.targetWarehouseId) {\n      throw new Error(\"Source and destination warehouses must be different\");\n    }\n    if (input.quantity <= 0) {\n      throw new Error(\"Transfer quantity must be positive\");\n    }\n\n    return this.db.transaction(async (tx) => {\n      await this.applyDelta(\n        {\n          productId: input.productId,\n          warehouseId: input.sourceWarehouseId,\n          quantityDelta: -Math.abs(input.quantity),\n          reference: input.reference,\n          note: input.note,\n          userId: input.userId,\n          type: \"transfer\",\n          relatedWarehouseId: input.targetWarehouseId,\n        },\n        tx,\n      );\n\n      await this.applyDelta(\n        {\n          productId: input.productId,\n          warehouseId: input.targetWarehouseId,\n          quantityDelta: Math.abs(input.quantity),\n          reference: input.reference,\n          note: input.note,\n          userId: input.userId,\n          type: \"transfer\",\n          relatedWarehouseId: input.sourceWarehouseId,\n        },\n        tx,\n      );\n\n      return true;\n    });\n  };\n\n  getStockLevel = async (\n    productId: string,\n    warehouseId: string,\n  ): Promise<StockTbStockLevel | null> => {\n    const [record] = await this.db\n      .select()\n      .from(stock_tb_stock_levels)\n      .where(\n        and(\n          eq(stock_tb_stock_levels.productId, productId),\n          eq(stock_tb_stock_levels.warehouseId, warehouseId),\n        ),\n      )\n      .limit(1);\n\n    return record ?? null;\n  };\n\n  private applyDelta = async (\n    input: AdjustStockInput & {\n      type: StockMovementKind;\n      relatedWarehouseId?: string;\n    },\n    tx?: any,\n  ) => {\n    const now = new Date();\n    const quantityDelta = Number(input.quantityDelta);\n    const db = tx ?? this.db;\n\n    const [currentLevel] = await db\n      .select()\n      .from(stock_tb_stock_levels)\n      .where(\n        and(\n          eq(stock_tb_stock_levels.productId, input.productId),\n          eq(stock_tb_stock_levels.warehouseId, input.warehouseId),\n        ),\n      )\n      .limit(1);\n\n    const currentQty = currentLevel ? Number(currentLevel.quantity) : 0;\n    const nextQty = currentQty + quantityDelta;\n\n    if (nextQty < 0) {\n      throw new Error(\n        `Insufficient stock for product ${input.productId} in warehouse ${input.warehouseId}`,\n      );\n    }\n\n    await db\n      .insert(stock_tb_stock_levels)\n      .values({\n        productId: input.productId,\n        warehouseId: input.warehouseId,\n        quantity: nextQty.toString(),\n        reservedQuantity: currentLevel?.reservedQuantity ?? \"0\",\n        updatedAt: now,\n      })\n      .onConflictDoUpdate({\n        target: [\n          stock_tb_stock_levels.productId,\n          stock_tb_stock_levels.warehouseId,\n        ],\n        set: {\n          quantity: sql`${stock_tb_stock_levels.quantity} + ${quantityDelta}`,\n          updatedAt: now,\n        },\n      });\n\n    const [moveRecord] = await db\n      .insert(stock_tb_stock_moves)\n      .values({\n        productId: input.productId,\n        quantity: quantityDelta.toString(),\n        type: input.type,\n        sourceWarehouseId:\n          input.type === \"outbound\" || quantityDelta < 0\n            ? input.warehouseId\n            : input.relatedWarehouseId,\n        targetWarehouseId:\n          input.type === \"inbound\" || quantityDelta > 0\n            ? input.warehouseId\n            : input.relatedWarehouseId,\n        reference: input.reference,\n        note: input.note,\n        createdBy: input.userId,\n        createdAt: now,\n      })\n      .returning();\n\n    return moveRecord;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Stock/StockSummaryViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":46,"fix":{"range":[193,193],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\n\nimport { eq, ilike, sql } from \"drizzle-orm\";\nimport { ParamFilter } from \"@base/server\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { product_tb_product_masters } from \"@mdl/product/server/schemas/product.master\";\n\nimport {\n  stock_tb_stock_levels,\n  stock_tb_stock_warehouses,\n} from \"../../schemas\";\n\nexport interface StockSummaryViewRow {\n  id: string;\n  productId: string;\n  productCode: string;\n  productName: string;\n  warehouseId: string;\n  warehouseCode: string;\n  warehouseName: string;\n  quantity: number;\n  reservedQuantity: number;\n  minStock: number | null;\n}\n\ninterface StockSummaryFilter extends ParamFilter {\n  productId?: string;\n  warehouseId?: string;\n}\n\nclass StockSummaryViewListModel extends BaseViewListModel<\n  typeof stock_tb_stock_levels,\n  StockSummaryViewRow,\n  StockSummaryFilter\n> {\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\n        \"productId\",\n        {\n          column: stock_tb_stock_levels.productId,\n          sort: true,\n        },\n      ],\n      [\n        \"productCode\",\n        {\n          column: product_tb_product_masters.code,\n          sort: true,\n        },\n      ],\n      [\n        \"productName\",\n        {\n          column: product_tb_product_masters.name,\n          sort: true,\n        },\n      ],\n      [\n        \"warehouseId\",\n        {\n          column: stock_tb_stock_levels.warehouseId,\n          sort: true,\n        },\n      ],\n      [\n        \"warehouseCode\",\n        {\n          column: stock_tb_stock_warehouses.code,\n          sort: true,\n        },\n      ],\n      [\n        \"warehouseName\",\n        {\n          column: stock_tb_stock_warehouses.name,\n          sort: true,\n        },\n      ],\n      [\n        \"quantity\",\n        {\n          column: stock_tb_stock_levels.quantity,\n          sort: true,\n        },\n      ],\n      [\n        \"reservedQuantity\",\n        {\n          column: stock_tb_stock_levels.reservedQuantity,\n          sort: true,\n        },\n      ],\n      [\n        \"minStock\",\n        {\n          column: stock_tb_stock_warehouses.minStock,\n          sort: true,\n        },\n      ],\n    ]);\n\n  constructor() {\n    super({\n      table: stock_tb_stock_levels,\n      sortDefault: [\n        {\n          column: \"productId\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationSearch = () =>\n    new Map([\n      [\n        \"productId\",\n        (text: string) => ilike(stock_tb_stock_levels.productId, text),\n      ],\n      [\n        \"productCode\",\n        (text: string) => ilike(product_tb_product_masters.code, text),\n      ],\n      [\n        \"productName\",\n        (text: string) =>\n          ilike(sql`${product_tb_product_masters.name}::text`, text),\n      ],\n      [\n        \"warehouseId\",\n        (text: string) => ilike(stock_tb_stock_levels.warehouseId, text),\n      ],\n      [\n        \"warehouseCode\",\n        (text: string) => ilike(stock_tb_stock_warehouses.code, text),\n      ],\n      [\n        \"warehouseName\",\n        (text: string) => ilike(stock_tb_stock_warehouses.name, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<StockSummaryFilter> =>\n    new Map([\n      [\n        \"productId\",\n        (value?: unknown, _filters?: StockSummaryFilter) => {\n          if (typeof value !== \"string\" || !value) return undefined;\n\n          return eq(stock_tb_stock_levels.productId, value);\n        },\n      ],\n      [\n        \"warehouseId\",\n        (value?: unknown, _filters?: StockSummaryFilter) => {\n          if (typeof value !== \"string\" || !value) return undefined;\n\n          return eq(stock_tb_stock_levels.warehouseId, value);\n        },\n      ],\n    ]);\n\n  protected declarationMappingData = (row: any): StockSummaryViewRow => ({\n    id: `${row.productId}-${row.warehouseId}`,\n    productId: row.productId,\n    productCode: row.productCode || row.productId,\n    productName:\n      typeof row.productName === \"string\"\n        ? row.productName\n        : row.productName?.en || row.productName?.vi || row.productId,\n    warehouseId: row.warehouseId,\n    warehouseCode: row.warehouseCode || row.warehouseId,\n    warehouseName: row.warehouseName || row.warehouseId,\n    quantity: Number(row.quantity),\n    reservedQuantity: Number(row.reservedQuantity),\n    minStock: row.minStock ? Number(row.minStock) : null,\n  });\n\n  getData = async (\n    params: ListParamsRequest<StockSummaryFilter> = {},\n  ): Promise<ListParamsResponse<StockSummaryViewRow>> => {\n    return this.buildQueryDataList(params, (query) =>\n      query\n        .leftJoin(\n          product_tb_product_masters,\n          eq(stock_tb_stock_levels.productId, product_tb_product_masters.id),\n        )\n        .leftJoin(\n          stock_tb_stock_warehouses,\n          eq(stock_tb_stock_levels.warehouseId, stock_tb_stock_warehouses.id),\n        ),\n    );\n  };\n}\n\nexport default StockSummaryViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Stock/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Warehouse/WarehouseModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":44,"fix":{"range":[135,135],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import type {\n  NewStockTbStockWarehouse,\n  StockTbStockWarehouse,\n} from \"../../schemas\";\n\nimport { asc, eq, sql } from \"drizzle-orm\";\nimport { BaseModel } from \"@base/server/models/BaseModel\";\n\nimport {\n  WarehouseAddress,\n  WarehouseStatus,\n  WarehouseValuationMethod,\n  warehouseStatuses,\n  warehouseValuationMethods,\n} from \"../../../common/constants\";\nimport { stock_tb_stock_warehouses } from \"../../schemas\";\n\nexport interface WarehousePayload {\n  code: string;\n  name: string;\n  typeCode: string;\n  status?: string | null;\n  companyId?: string | null;\n  managerId?: string | null;\n  contactId?: string | null;\n  address: WarehouseAddress;\n  valuationMethod?: string | null;\n  minStock?: number | null;\n  maxStock?: number | null;\n  accountInventory?: string | null;\n  accountAdjustment?: string | null;\n  notes?: string | null;\n}\n\nexport interface WarehouseViewRow {\n  id: string;\n  code: string;\n  name: string;\n  typeCode: string;\n  status: string;\n  companyId: string | null;\n  managerId: string | null;\n  contactId: string | null;\n  address: WarehouseAddress;\n  valuationMethod: string;\n  minStock: number;\n  maxStock: number | null;\n  accountInventory: string | null;\n  accountAdjustment: string | null;\n  notes: string | null;\n  createdAt: string | null;\n  updatedAt: string | null;\n}\n\nexport default class WarehouseModel extends BaseModel<\n  typeof stock_tb_stock_warehouses\n> {\n  constructor() {\n    super(stock_tb_stock_warehouses);\n  }\n\n  listWarehouses = async (): Promise<StockTbStockWarehouse[]> => {\n    return this.db\n      .select()\n      .from(stock_tb_stock_warehouses)\n      .orderBy(asc(stock_tb_stock_warehouses.name));\n  };\n\n  getWarehouse = async (id: string): Promise<StockTbStockWarehouse | null> => {\n    const [record] = await this.db\n      .select()\n      .from(stock_tb_stock_warehouses)\n      .where(eq(stock_tb_stock_warehouses.id, id))\n      .limit(1);\n\n    return record ?? null;\n  };\n\n  createWarehouse = async (\n    payload: WarehousePayload,\n  ): Promise<StockTbStockWarehouse> => {\n    const insertPayload = this.normalizeWarehousePayload(payload);\n\n    const [record] = await this.db\n      .insert(stock_tb_stock_warehouses)\n      .values(insertPayload)\n      .returning();\n\n    return record;\n  };\n\n  updateWarehouse = async (\n    id: string,\n    payload: WarehousePayload,\n  ): Promise<StockTbStockWarehouse> => {\n    const [record] = await this.db\n      .update(stock_tb_stock_warehouses)\n      .set({\n        ...this.normalizeWarehousePayload(payload),\n        updatedAt: sql`now()`,\n      })\n      .where(eq(stock_tb_stock_warehouses.id, id))\n      .returning();\n\n    if (!record) {\n      throw new Error(\"Warehouse not found\");\n    }\n\n    return record;\n  };\n\n  private normalizeWarehousePayload = (\n    payload: WarehousePayload,\n  ): Omit<NewStockTbStockWarehouse, \"id\" | \"createdAt\" | \"updatedAt\"> => {\n    return {\n      code: payload.code.trim(),\n      name: payload.name.trim(),\n      typeCode: payload.typeCode.trim(),\n      status: this.validateStatus(payload.status),\n      companyId: payload.companyId ?? null,\n      managerId: payload.managerId ?? null,\n      contactId: payload.contactId ?? null,\n      address: payload.address,\n      valuationMethod: this.validateValuationMethod(payload.valuationMethod),\n      minStock:\n        payload.minStock === undefined || payload.minStock === null\n          ? undefined\n          : payload.minStock.toString(),\n      maxStock:\n        payload.maxStock === undefined\n          ? undefined\n          : payload.maxStock === null\n            ? null\n            : payload.maxStock.toString(),\n      accountInventory: payload.accountInventory ?? null,\n      accountAdjustment: payload.accountAdjustment ?? null,\n      notes: payload.notes ?? null,\n    };\n  };\n\n  private validateStatus = (status?: string | null): WarehouseStatus => {\n    if (!status) {\n      return \"ACTIVE\";\n    }\n\n    const normalized = status.toUpperCase() as WarehouseStatus;\n\n    if (!warehouseStatuses.includes(normalized)) {\n      throw new Error(`Invalid warehouse status: ${status}`);\n    }\n\n    return normalized;\n  };\n\n  private validateValuationMethod = (\n    value?: string | null,\n  ): WarehouseValuationMethod => {\n    if (!value) {\n      return \"FIFO\";\n    }\n\n    const normalized = value.toUpperCase() as WarehouseValuationMethod;\n\n    if (!warehouseValuationMethods.includes(normalized)) {\n      throw new Error(`Invalid warehouse valuation method: ${value}`);\n    }\n\n    return normalized;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Warehouse/WarehouseViewListModel.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[327,327],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`drizzle-orm` import should occur before import of `@base/server/models/BaseViewListModel`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":37,"fix":{"range":[223,365],"text":"import { ilike } from \"drizzle-orm\";\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type { Column } from \"drizzle-orm\";\nimport type {\n  ListParamsRequest,\n  ListParamsResponse,\n} from \"@base/shared/interface/ListInterface\";\nimport type { ParamFilter } from \"@base/shared/interface/FilterInterface\";\n\nimport {\n  BaseViewListModel,\n  type FilterConditionMap,\n} from \"@base/server/models/BaseViewListModel\";\nimport { ilike } from \"drizzle-orm\";\n\nimport { WarehouseAddress } from \"../../../common/constants\";\nimport { stock_tb_stock_warehouses } from \"../../schemas\";\n\nexport interface WarehouseViewRow {\n  id: string;\n  code: string;\n  name: string;\n  typeCode: string;\n  status: string;\n  companyId: string | null;\n  managerId: string | null;\n  contactId: string | null;\n  address: WarehouseAddress;\n  valuationMethod: string;\n  minStock: number;\n  maxStock: number | null;\n  accountInventory: string | null;\n  accountAdjustment: string | null;\n  notes: string | null;\n  createdAt: string | null;\n  updatedAt: string | null;\n}\n\nclass WarehouseViewListModel extends BaseViewListModel<\n  typeof stock_tb_stock_warehouses,\n  WarehouseViewRow\n> {\n  constructor() {\n    super({\n      table: stock_tb_stock_warehouses,\n      sortDefault: [\n        {\n          column: \"name\",\n          direction: \"ascending\",\n        },\n      ],\n    });\n  }\n\n  protected declarationColumns = () =>\n    new Map<\n      string,\n      {\n        column: Column<any>;\n        sort?: boolean;\n      }\n    >([\n      [\"id\", { column: stock_tb_stock_warehouses.id, sort: true }],\n      [\"code\", { column: stock_tb_stock_warehouses.code, sort: true }],\n      [\"name\", { column: stock_tb_stock_warehouses.name, sort: true }],\n      [\"typeCode\", { column: stock_tb_stock_warehouses.typeCode, sort: true }],\n      [\"status\", { column: stock_tb_stock_warehouses.status, sort: true }],\n      [\n        \"companyId\",\n        { column: stock_tb_stock_warehouses.companyId, sort: true },\n      ],\n      [\n        \"managerId\",\n        { column: stock_tb_stock_warehouses.managerId, sort: true },\n      ],\n      [\n        \"contactId\",\n        { column: stock_tb_stock_warehouses.contactId, sort: true },\n      ],\n      [\"address\", { column: stock_tb_stock_warehouses.address, sort: false }],\n      [\n        \"valuationMethod\",\n        { column: stock_tb_stock_warehouses.valuationMethod, sort: true },\n      ],\n      [\"minStock\", { column: stock_tb_stock_warehouses.minStock, sort: true }],\n      [\"maxStock\", { column: stock_tb_stock_warehouses.maxStock, sort: true }],\n      [\n        \"accountInventory\",\n        { column: stock_tb_stock_warehouses.accountInventory, sort: false },\n      ],\n      [\n        \"accountAdjustment\",\n        { column: stock_tb_stock_warehouses.accountAdjustment, sort: false },\n      ],\n      [\"notes\", { column: stock_tb_stock_warehouses.notes, sort: false }],\n      [\n        \"createdAt\",\n        { column: stock_tb_stock_warehouses.createdAt, sort: true },\n      ],\n      [\n        \"updatedAt\",\n        { column: stock_tb_stock_warehouses.updatedAt, sort: true },\n      ],\n    ]);\n\n  protected declarationSearch = () =>\n    new Map([\n      [\"code\", (text: string) => ilike(stock_tb_stock_warehouses.code, text)],\n      [\"name\", (text: string) => ilike(stock_tb_stock_warehouses.name, text)],\n      [\n        \"typeCode\",\n        (text: string) => ilike(stock_tb_stock_warehouses.typeCode, text),\n      ],\n      [\n        \"status\",\n        (text: string) => ilike(stock_tb_stock_warehouses.status, text),\n      ],\n    ]);\n\n  protected declarationFilter = (): FilterConditionMap<ParamFilter> =>\n    new Map() as FilterConditionMap<ParamFilter>;\n\n  protected declarationMappingData = (row: any): WarehouseViewRow => ({\n    id: row.id,\n    code: row.code,\n    name: row.name,\n    typeCode: row.typeCode,\n    status: row.status,\n    companyId: row.companyId ?? null,\n    managerId: row.managerId ?? null,\n    contactId: row.contactId ?? null,\n    address: row.address as WarehouseAddress,\n    valuationMethod: row.valuationMethod,\n    minStock: Number(row.minStock ?? 0),\n    maxStock:\n      row.maxStock === null || row.maxStock === undefined\n        ? null\n        : Number(row.maxStock),\n    accountInventory: row.accountInventory ?? null,\n    accountAdjustment: row.accountAdjustment ?? null,\n    notes: row.notes ?? null,\n    createdAt: row.createdAt ? row.createdAt.toISOString() : null,\n    updatedAt: row.updatedAt ? row.updatedAt.toISOString() : null,\n  });\n\n  getData = async (\n    params: ListParamsRequest = {},\n  ): Promise<ListParamsResponse<WarehouseViewRow>> => {\n    return this.buildQueryDataList(params);\n  };\n}\n\nexport default WarehouseViewListModel;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/models/Warehouse/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.cost-variance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.level.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.lot-move.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.lot.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.move.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/modules/stock/server/schemas/stock.warehouse.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":30,"fix":{"range":[166,166],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { sql } from \"drizzle-orm\";\nimport {\n  check,\n  index,\n  jsonb,\n  numeric,\n  text,\n  timestamp,\n  uniqueIndex,\n  uuid,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport { base_tb_users } from \"@base/server/schemas/base.user\";\n\nimport {\n  WarehouseAddress,\n  warehouseStatuses,\n  warehouseValuationMethods,\n} from \"../../common/constants\";\n\nimport { mdlStockSchema } from \"./schema\";\n\nexport const stock_tb_stock_warehouses = mdlStockSchema.table(\n  \"warehouses\",\n  {\n    id: uuid(\"id\")\n      .primaryKey()\n      .default(sql`uuid_generate_v7()`),\n    code: varchar(\"code\", { length: 64 }).notNull(),\n    name: varchar(\"name\", { length: 128 }).notNull(),\n    typeCode: varchar(\"type_code\", { length: 30 }).notNull(),\n    status: varchar(\"status\", { length: 20 }).notNull().default(\"ACTIVE\"),\n    companyId: uuid(\"company_id\"),\n    managerId: uuid(\"manager_id\").references(() => base_tb_users.id, {\n      onDelete: \"set null\",\n    }),\n    contactId: uuid(\"contact_id\").references(() => base_tb_users.id, {\n      onDelete: \"set null\",\n    }),\n    address: jsonb(\"address\").$type<WarehouseAddress>().notNull(),\n    valuationMethod: varchar(\"valuation_method\", { length: 10 })\n      .notNull()\n      .default(\"FIFO\"),\n    minStock: numeric(\"min_stock\", { precision: 18, scale: 4 })\n      .notNull()\n      .default(\"0\"),\n    maxStock: numeric(\"max_stock\", { precision: 18, scale: 4 }),\n    accountInventory: varchar(\"account_inventory\", { length: 30 }),\n    accountAdjustment: varchar(\"account_adjustment\", { length: 30 }),\n    notes: text(\"notes\"),\n    createdAt: timestamp(\"created_at\", { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n    updatedAt: timestamp(\"updated_at\", { withTimezone: true })\n      .notNull()\n      .defaultNow(),\n  },\n  (table) => [\n    uniqueIndex(\"warehouses_code_unique\").on(table.code),\n    index(\"warehouses_company_idx\").on(table.companyId),\n    index(\"warehouses_status_idx\").on(table.status),\n    index(\"warehouses_type_idx\").on(table.typeCode),\n    check(\n      \"warehouses_status_check\",\n      sql`${table.status} IN (${sql.join(\n        warehouseStatuses.map((status) => sql.raw(`'${status}'`)),\n        sql`, `,\n      )})`,\n    ),\n    check(\n      \"warehouses_valuation_check\",\n      sql`${table.valuationMethod} IN (${sql.join(\n        warehouseValuationMethods.map((method) => sql.raw(`'${method}'`)),\n        sql`, `,\n      )})`,\n    ),\n    check(\"warehouses_min_stock_check\", sql`${table.minStock}::numeric >= 0`),\n    check(\n      \"warehouses_min_max_check\",\n      sql`(${table.maxStock} IS NULL) OR (${table.maxStock}::numeric >= ${table.minStock}::numeric)`,\n    ),\n  ],\n);\n\nexport type StockTbStockWarehouse =\n  typeof stock_tb_stock_warehouses.$inferSelect;\nexport type NewStockTbStockWarehouse =\n  typeof stock_tb_stock_warehouses.$inferInsert;\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/proxy.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":77,"fix":{"range":[272,272],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next/server` import should occur before import of `@base/server/middleware`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":44,"fix":{"range":[49,317],"text":"import { NextResponse } from \"next/server\";\nimport {\n  addPageHeaders,\n  addSecurityHeaders,\n  authenticateRequest,\n  checkCsrfProtection,\n  checkRateLimit,\n} from \"@base/server/middleware\";\nimport { checkSuspiciousRequest } from \"@base/server/utils/request-monitor\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import type { NextRequest } from \"next/server\";\n\nimport {\n  addPageHeaders,\n  addSecurityHeaders,\n  authenticateRequest,\n  checkCsrfProtection,\n  checkRateLimit,\n} from \"@base/server/middleware\";\nimport { checkSuspiciousRequest } from \"@base/server/utils/request-monitor\";\nimport { NextResponse } from \"next/server\";\n\n// Public routes that don't require authentication\nconst PUBLIC_ROUTES = [\n  \"/api/base/auth/login\",\n  \"/api/base/auth/logout\",\n  \"/api/base/health\",\n  \"/api/base/health/ping\",\n  \"/api/base/media\", // Allow public access to media files (images/files) for viewing\n  \"/login\",\n  \"/reset-password\",\n  \"/\",\n];\n\n// Protected routes that require authentication\nconst PROTECTED_ROUTES = [\"/workspace\"];\n\n// Routes that should be excluded from proxy\nconst EXCLUDED_PATHS = [\"/_next\", \"/static\", \"/favicon\"];\n\n/**\n * Check if a path is a public route\n */\nfunction isPublicRoute(pathname: string): boolean {\n  return PUBLIC_ROUTES.some(\n    (route) => pathname === route || pathname.startsWith(route + \"/\"),\n  );\n}\n\n/**\n * Check if a path is a protected route\n */\nfunction isProtectedRoute(pathname: string): boolean {\n  return PROTECTED_ROUTES.some((route) => pathname.startsWith(route));\n}\n\n/**\n * Check if a path should be excluded from proxy\n */\nfunction isExcludedPath(pathname: string): boolean {\n  return EXCLUDED_PATHS.some((path) => pathname.startsWith(path));\n}\n\n/**\n * Check if pathname is an API route\n */\nfunction isApiRoute(pathname: string): boolean {\n  return pathname.startsWith(\"/api/\");\n}\n\n/**\n * Check if pathname is a page route\n */\nfunction isPageRoute(pathname: string): boolean {\n  return !isApiRoute(pathname) && !isExcludedPath(pathname);\n}\n\n/**\n * Handle API routes security\n * - Rate limiting\n * - CSRF protection\n * - Authentication\n */\nasync function handleApiRoute(\n  req: NextRequest,\n  pathname: string,\n  nextHeaders: Headers,\n): Promise<NextResponse | null> {\n  // 1. Rate Limiting\n  const rateLimitResponse = checkRateLimit(req, pathname);\n\n  if (rateLimitResponse) {\n    return addSecurityHeaders(rateLimitResponse);\n  }\n\n  // 2. CSRF Protection (skip for public routes and GET requests)\n  // Also skip CSRF endpoint itself\n  // Upload endpoint requires CSRF even if media viewing is public\n  if (\n    !isPublicRoute(pathname) &&\n    pathname !== \"/api/base/utils/get-csrf-token\"\n  ) {\n    const csrfResponse = checkCsrfProtection(req);\n\n    if (csrfResponse) {\n      return addSecurityHeaders(csrfResponse);\n    }\n  } else if (pathname === \"/api/base/media/upload\") {\n    // Upload endpoint requires CSRF protection even though media viewing is public\n    const csrfResponse = checkCsrfProtection(req);\n\n    if (csrfResponse) {\n      return addSecurityHeaders(csrfResponse);\n    }\n  }\n\n  // 3. Authentication (skip for public routes)\n  // Upload endpoint requires authentication even though media viewing is public\n  if (!isPublicRoute(pathname) || pathname === \"/api/base/media/upload\") {\n    const authResponse = await authenticateRequest(req, nextHeaders);\n\n    if (authResponse) {\n      return addSecurityHeaders(authResponse);\n    }\n  }\n\n  return null; // Continue processing\n}\n\n/**\n * Handle page routes\n * - Authentication check for protected routes\n * - Locale and workspace headers\n */\nasync function handlePageRoute(\n  req: NextRequest,\n  pathname: string,\n  nextHeaders: Headers,\n): Promise<NextResponse | null> {\n  // Check authentication for protected routes\n  if (isProtectedRoute(pathname) && !isPublicRoute(pathname)) {\n    const authResponse = await authenticateRequest(req, nextHeaders);\n\n    if (authResponse) {\n      // Redirect to login page if not authenticated\n      const loginUrl = new URL(\"/login\", req.url);\n\n      loginUrl.searchParams.set(\"redirect\", pathname);\n\n      return NextResponse.redirect(loginUrl);\n    }\n  }\n\n  addPageHeaders(req, nextHeaders, pathname);\n\n  return null;\n}\n\n/**\n * Next.js 16 Proxy - Centralized Security Handler\n *\n * This proxy handles all security concerns:\n * - API Routes: Rate limiting, CSRF protection, Authentication\n * - Page Routes: Locale headers, workspace headers, optional auth info\n * - All Routes: Security headers\n */\nexport async function proxy(req: NextRequest) {\n  const { nextUrl, headers } = req;\n  const pathname = nextUrl.pathname;\n  const nextHeaders = new Headers(headers);\n\n  // Skip excluded paths (static files, Next.js internals)\n  if (isExcludedPath(pathname)) {\n    return NextResponse.next();\n  }\n\n  // Check for suspicious requests (non-blocking, just logs)\n  checkSuspiciousRequest(req, pathname);\n\n  // Handle API routes\n  if (isApiRoute(pathname)) {\n    const apiResponse = await handleApiRoute(req, pathname, nextHeaders);\n\n    if (apiResponse) {\n      // Record error response for monitoring\n      if (apiResponse.status >= 400) {\n        const { recordErrorResponse } =\n          await import(\"@base/server/utils/request-monitor\");\n\n        recordErrorResponse(req, pathname, apiResponse.status);\n      }\n\n      return apiResponse; // Rate limit, CSRF, or auth error\n    }\n  }\n\n  // Handle page routes\n  if (isPageRoute(pathname)) {\n    const pageResponse = await handlePageRoute(req, pathname, nextHeaders);\n\n    if (pageResponse) {\n      return addSecurityHeaders(pageResponse); // Redirect to login\n    }\n  }\n\n  // Continue with modified headers\n  const response = NextResponse.next({ request: { headers: nextHeaders } });\n\n  // Add security headers to all responses\n  return addSecurityHeaders(response);\n}\n// Next.js 16 uses proxy.ts instead of middleware.ts\n// Export config for Next.js to recognize this as the proxy middleware\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    \"/((?!_next/static|_next/image|favicon.ico).*)\",\n  ],\n};\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/server.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":70,"fix":{"range":[263,263],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`next` import should occur before import of `@base/server/runtime/RuntimeContext`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":25,"fix":{"range":[194,289],"text":"import next from \"next\";\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\n"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":16,"suggestions":[{"fix":{"range":[929,973],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":16,"suggestions":[{"fix":{"range":[1081,1120],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":18,"suggestions":[{"fix":{"range":[1921,2014],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":18,"suggestions":[{"fix":{"range":[2043,2109],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":18,"suggestions":[{"fix":{"range":[2566,2622],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":20,"suggestions":[{"fix":{"range":[2834,2876],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":103,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":103,"endColumn":22,"suggestions":[{"fix":{"range":[2934,2983],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":114,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":114,"endColumn":18,"suggestions":[{"fix":{"range":[3290,3339],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":18,"suggestions":[{"fix":{"range":[3346,3417],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":18,"suggestions":[{"fix":{"range":[3450,3500],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":2,"source":"/**\n * Custom Next.js 16 Server with Fastify\n * Latest example for Next.js 16 + Fastify integration\n * Loads all models at server startup before handling requests\n */\n\nimport http from \"http\";\n\nimport { RuntimeContext } from \"@base/server/runtime/RuntimeContext\";\nimport next from \"next\";\n\nimport { ScheduledTask } from \"./cron\";\n\n// Mark that we're running custom server to skip instrumentation\nprocess.env.RUNNING_CUSTOM_SERVER = \"true\";\n\nconst dev = process.env.NODE_ENV !== \"production\";\nconst hostname = process.env.HOSTNAME || \"localhost\";\nconst port = parseInt(process.env.PORT || \"3000\", 10);\n\n// Create Next.js app\nconst app = next({\n  dev,\n  hostname,\n  port,\n  dir: process.cwd(),\n});\n\nconst handle = app.getRequestHandler();\n\nasync function startServer(): Promise<void> {\n  try {\n    await app.prepare();\n\n    // Initialize runtime using RuntimeContext\n    // This handles database and environment initialization\n    console.log(\"> 🔧 Initializing runtime...\");\n    const context = RuntimeContext.getInstance(process.cwd());\n\n    await context.ensureInitialized();\n    console.log(\"> ✅ Runtime initialized\");\n\n    // Get instances from context\n    const connectionPool = context.getConnectionPool();\n    const modelInstance = context.getModelInstance();\n\n    // Calculate and log modelInstance size in KB\n    try {\n      const seen = new Set();\n      const envProcessJson = JSON.stringify(modelInstance, (key, value) => {\n        // Skip functions\n        if (typeof value === \"function\") {\n          return \"[Function]\";\n        }\n        // Handle circular references\n        if (typeof value === \"object\" && value !== null) {\n          if (seen.has(value)) {\n            return \"[Circular]\";\n          }\n          seen.add(value);\n        }\n\n        return value;\n      });\n      const sizeInBytes = Buffer.byteLength(envProcessJson, \"utf8\");\n      const sizeInKB = (sizeInBytes / 1024).toFixed(2);\n\n      console.log(\n        `> 📊 Environment size: ${sizeInKB} KB (${sizeInBytes} bytes)`,\n      );\n    } catch (error) {\n      console.log(`> ⚠️  Could not calculate environment size:`, error);\n    }\n\n    // Initialize and start cron scheduler\n    const scheduler = new ScheduledTask();\n\n    scheduler.start();\n\n    const server = http.createServer(async (req, res) => {\n      await handle(req, res);\n    });\n\n    // Graceful shutdown\n    const closeServer = () =>\n      new Promise<void>((resolve, reject) => {\n        server.close((err) => (err ? reject(err) : resolve()));\n      });\n\n    const gracefulShutdown = async (signal: string) => {\n      console.log(`ℹ️  Received ${signal}, shutting down...`);\n      try {\n        // Stop cron scheduler\n        if (scheduler) {\n          scheduler.stop();\n        }\n        await closeServer();\n        await connectionPool.closeAll();\n        await app.close();\n        console.log(\"✅ Server closed gracefully\");\n        process.exit(0);\n      } catch (error) {\n        console.error(\"❌ Error during shutdown:\", error);\n        process.exit(1);\n      }\n    };\n\n    process.on(\"SIGTERM\", () => gracefulShutdown(\"SIGTERM\"));\n    process.on(\"SIGINT\", () => gracefulShutdown(\"SIGINT\"));\n\n    server.listen(port, hostname === \"localhost\" ? \"0.0.0.0\" : hostname, () => {\n      const serverUrl = `http://${hostname}:${port}`;\n\n      console.log(`> 🚀 Server ready on ${serverUrl}`);\n      console.log(`> 📦 Environment: ${dev ? \"development\" : \"production\"}`);\n    });\n  } catch (error) {\n    console.error(\"❌ Failed to start server:\", error);\n    process.exit(1);\n  }\n}\n\nstartServer();\n","usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/server/db/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]},{"filePath":"/home/hoatd/workspaces/Bavadu/web/types/minisearch.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"padding-line-between-statements","replacedBy":["@stylistic/padding-line-between-statements"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"padding-line-between-statements","url":"https://eslint.style/rules/padding-line-between-statements"}}]}}]}]
